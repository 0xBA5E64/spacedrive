// Code generated by Prisma Client Rust. DO NOT EDIT.

use prisma_client_rust::chrono;
use prisma_client_rust::datamodel::parse_configuration;
use prisma_client_rust::prisma_models::InternalDataModelBuilder;
use prisma_client_rust::query::*;
use prisma_client_rust::query_core::{
    executor, schema_builder, BuildMode, CoreError, QueryExecutor, QuerySchema,
};
use prisma_client_rust::serde_json;
use prisma_client_rust::DeleteResult;
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
pub struct PrismaClient {
    executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
    query_schema: Arc<QuerySchema>,
}
impl PrismaClient {
    pub async fn new() -> Self {
        let datamodel_str = "datasource db {\n    provider = \"sqlite\"\n    url      = \"file:dev.db\"\n}\n\ngenerator client {\n    provider = \"prisma-client-rust\"\n    output   = \"../src/prisma.rs\"\n}\n\ngenerator js {\n    provider = \"prisma-client-js\"\n    output   = \"../types\"\n}\n\nmodel Migration {\n    id            Int      @id @default(autoincrement())\n    name          String\n    checksum      String   @unique\n    steps_applied Int      @default(0)\n    applied_at    DateTime @default(now())\n\n    @@map(\"_migrations\")\n}\n\nmodel Library {\n    id                  Int      @id @default(autoincrement())\n    uuid                String   @unique\n    name                String\n    remote_id           String?\n    is_primary          Boolean  @default(true)\n    encryption          Int      @default(0)\n    total_file_count    Int      @default(0)\n    total_bytes_used    String   @default(\"0\")\n    total_byte_capacity String   @default(\"0\")\n    total_unique_bytes  String   @default(\"0\")\n    date_created        DateTime @default(now())\n    timezone            String?\n    spaces              Space[]\n\n    @@map(\"libraries\")\n}\n\nmodel Client {\n    id           Int      @id @default(autoincrement())\n    uuid         String   @unique\n    name         String\n    platform     Int      @default(0)\n    version      String?\n    online       Boolean? @default(true)\n    last_seen    DateTime @default(now())\n    timezone     String?\n    date_created DateTime @default(now())\n    jobs         Job[]\n\n    @@map(\"clients\")\n}\n\nmodel Location {\n    id                 Int      @id @default(autoincrement())\n    name               String?\n    path               String?\n    total_capacity     Int?\n    available_capacity Int?\n    is_removable       Boolean  @default(true)\n    is_ejectable       Boolean  @default(true)\n    is_root_filesystem Boolean  @default(true)\n    is_online          Boolean  @default(true)\n    date_created       DateTime @default(now())\n    files              File[]\n\n    @@map(\"locations\")\n}\n\nmodel File {\n    id             Int      @id @default(autoincrement())\n    is_dir         Boolean  @default(false)\n    location_id    Int\n    stem           String\n    name           String\n    extension      String?\n    path_checksum  String   @unique // combo of location_id, stem, name, extension\n    quick_checksum String? // 100 * 100 byte samples\n    full_checksum  String? // full byte to byte hash\n    size_in_bytes  String\n    encryption     Int      @default(0)\n    date_created   DateTime @default(now())\n    date_modified  DateTime @default(now())\n    date_indexed   DateTime @default(now())\n    ipfs_id        String?\n\n    location Location? @relation(fields: [location_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    parent    File?  @relation(\"directory_files\", fields: [parent_id], references: [id])\n    parent_id Int?\n    children  File[] @relation(\"directory_files\")\n\n    file_tags TagOnFile[]\n    @@map(\"files\")\n}\n\nmodel Tag {\n    id              Int      @id @default(autoincrement())\n    name            String?\n    encryption      Int?     @default(0)\n    total_files     Int?     @default(0)\n    redundancy_goal Int?     @default(1)\n    date_created    DateTime @default(now())\n    date_modified   DateTime @default(now())\n\n    tag_files TagOnFile[]\n\n    @@map(\"tags\")\n}\n\nmodel TagOnFile {\n    date_created DateTime @default(now())\n\n    tag_id Int\n    tag    Tag @relation(fields: [tag_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    file_id Int\n    file    File @relation(fields: [file_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@id([tag_id, file_id])\n    @@map(\"tags_on_files\")\n}\n\nmodel Job {\n    id                   Int      @id @default(autoincrement())\n    client_id            Int\n    action               Int\n    status               Int      @default(0)\n    percentage_complete  Int      @default(0)\n    task_count           Int      @default(1)\n    completed_task_count Int      @default(0)\n    date_created         DateTime @default(now())\n    date_modified        DateTime @default(now())\n    clients              Client   @relation(fields: [client_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@map(\"jobs\")\n}\n\nmodel Space {\n    id            Int      @id @default(autoincrement())\n    name          String\n    encryption    Int?     @default(0)\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n\n    Library   Library? @relation(fields: [libraryId], references: [id])\n    libraryId Int?\n    @@map(\"spaces\")\n}\n" ;
        let config = parse_configuration(datamodel_str).unwrap().subject;
        let source = config
            .datasources
            .first()
            .expect("Pleasy supply a datasource in your schema.prisma file");
        let url = if let Some(url) = source.load_shadow_database_url().unwrap() {
            url
        } else {
            source.load_url(|key| std::env::var(key).ok()).unwrap()
        };
        let url = if url.starts_with("file:") {
            let path = url.split(":").nth(1).unwrap();
            if Path::new("./schema.prisma").exists() {
                url
            } else if Path::new("./prisma/schema.prisma").exists() {
                format!("file:./prisma/{}", path)
            } else {
                url
            }
        } else {
            url
        };
        let (db_name, executor) = executor::load(&source, &[], &url).await.unwrap();
        let internal_model = InternalDataModelBuilder::new(&datamodel_str).build(db_name);
        let query_schema = Arc::new(schema_builder::build(
            internal_model,
            BuildMode::Modern,
            true,
            source.capabilities(),
            vec![],
            source.referential_integrity(),
        ));
        executor.primary_connector().get_connection().await.unwrap();
        Self {
            executor,
            query_schema,
        }
    }
    pub async fn new_with_url(url: &str) -> Self {
        let datamodel_str = "datasource db {\n    provider = \"sqlite\"\n    url      = \"file:dev.db\"\n}\n\ngenerator client {\n    provider = \"prisma-client-rust\"\n    output   = \"../src/prisma.rs\"\n}\n\ngenerator js {\n    provider = \"prisma-client-js\"\n    output   = \"../types\"\n}\n\nmodel Migration {\n    id            Int      @id @default(autoincrement())\n    name          String\n    checksum      String   @unique\n    steps_applied Int      @default(0)\n    applied_at    DateTime @default(now())\n\n    @@map(\"_migrations\")\n}\n\nmodel Library {\n    id                  Int      @id @default(autoincrement())\n    uuid                String   @unique\n    name                String\n    remote_id           String?\n    is_primary          Boolean  @default(true)\n    encryption          Int      @default(0)\n    total_file_count    Int      @default(0)\n    total_bytes_used    String   @default(\"0\")\n    total_byte_capacity String   @default(\"0\")\n    total_unique_bytes  String   @default(\"0\")\n    date_created        DateTime @default(now())\n    timezone            String?\n    spaces              Space[]\n\n    @@map(\"libraries\")\n}\n\nmodel Client {\n    id           Int      @id @default(autoincrement())\n    uuid         String   @unique\n    name         String\n    platform     Int      @default(0)\n    version      String?\n    online       Boolean? @default(true)\n    last_seen    DateTime @default(now())\n    timezone     String?\n    date_created DateTime @default(now())\n    jobs         Job[]\n\n    @@map(\"clients\")\n}\n\nmodel Location {\n    id                 Int      @id @default(autoincrement())\n    name               String?\n    path               String?\n    total_capacity     Int?\n    available_capacity Int?\n    is_removable       Boolean  @default(true)\n    is_ejectable       Boolean  @default(true)\n    is_root_filesystem Boolean  @default(true)\n    is_online          Boolean  @default(true)\n    date_created       DateTime @default(now())\n    files              File[]\n\n    @@map(\"locations\")\n}\n\nmodel File {\n    id             Int      @id @default(autoincrement())\n    is_dir         Boolean  @default(false)\n    location_id    Int\n    stem           String\n    name           String\n    extension      String?\n    path_checksum  String   @unique // combo of location_id, stem, name, extension\n    quick_checksum String? // 100 * 100 byte samples\n    full_checksum  String? // full byte to byte hash\n    size_in_bytes  String\n    encryption     Int      @default(0)\n    date_created   DateTime @default(now())\n    date_modified  DateTime @default(now())\n    date_indexed   DateTime @default(now())\n    ipfs_id        String?\n\n    location Location? @relation(fields: [location_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    parent    File?  @relation(\"directory_files\", fields: [parent_id], references: [id])\n    parent_id Int?\n    children  File[] @relation(\"directory_files\")\n\n    file_tags TagOnFile[]\n    @@map(\"files\")\n}\n\nmodel Tag {\n    id              Int      @id @default(autoincrement())\n    name            String?\n    encryption      Int?     @default(0)\n    total_files     Int?     @default(0)\n    redundancy_goal Int?     @default(1)\n    date_created    DateTime @default(now())\n    date_modified   DateTime @default(now())\n\n    tag_files TagOnFile[]\n\n    @@map(\"tags\")\n}\n\nmodel TagOnFile {\n    date_created DateTime @default(now())\n\n    tag_id Int\n    tag    Tag @relation(fields: [tag_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    file_id Int\n    file    File @relation(fields: [file_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@id([tag_id, file_id])\n    @@map(\"tags_on_files\")\n}\n\nmodel Job {\n    id                   Int      @id @default(autoincrement())\n    client_id            Int\n    action               Int\n    status               Int      @default(0)\n    percentage_complete  Int      @default(0)\n    task_count           Int      @default(1)\n    completed_task_count Int      @default(0)\n    date_created         DateTime @default(now())\n    date_modified        DateTime @default(now())\n    clients              Client   @relation(fields: [client_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@map(\"jobs\")\n}\n\nmodel Space {\n    id            Int      @id @default(autoincrement())\n    name          String\n    encryption    Int?     @default(0)\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n\n    Library   Library? @relation(fields: [libraryId], references: [id])\n    libraryId Int?\n    @@map(\"spaces\")\n}\n" ;
        let config = parse_configuration(datamodel_str).unwrap().subject;
        let source = config
            .datasources
            .first()
            .expect("Pleasy supply a datasource in your schema.prisma file");
        let (db_name, executor) = executor::load(&source, &[], &url).await.unwrap();
        let internal_model = InternalDataModelBuilder::new(&datamodel_str).build(db_name);
        let query_schema = Arc::new(schema_builder::build(
            internal_model,
            BuildMode::Modern,
            true,
            source.capabilities(),
            vec![],
            source.referential_integrity(),
        ));
        executor.primary_connector().get_connection().await.unwrap();
        Self {
            executor,
            query_schema,
        }
    }
    pub async fn _query_raw<T: serde::de::DeserializeOwned>(
        &self,
        query: &str,
    ) -> Result<Vec<T>, CoreError> {
        let query = Query {
            ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
            operation: "mutation".into(),
            method: "queryRaw".into(),
            inputs: vec![
                Input {
                    name: "query".into(),
                    value: Some(query.into()),
                    ..Default::default()
                },
                Input {
                    name: "parameters".into(),
                    value: Some("[]".into()),
                    ..Default::default()
                },
            ],
            name: "".into(),
            model: "".into(),
            outputs: vec![],
        };
        query.perform().await
    }
    pub async fn _execute_raw(&self, query: &str) -> Result<i64, CoreError> {
        let query = Query {
            ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
            operation: "mutation".into(),
            method: "executeRaw".into(),
            inputs: vec![
                Input {
                    name: "query".into(),
                    value: Some(query.into()),
                    ..Default::default()
                },
                Input {
                    name: "parameters".into(),
                    value: Some("[]".into()),
                    ..Default::default()
                },
            ],
            name: "".into(),
            model: "".into(),
            outputs: vec![],
        };
        query.perform().await.map(|result: i64| result)
    }
    pub fn migration(&self) -> MigrationActions {
        MigrationActions { client: &self }
    }
    pub fn library(&self) -> LibraryActions {
        LibraryActions { client: &self }
    }
    pub fn client(&self) -> ClientActions {
        ClientActions { client: &self }
    }
    pub fn location(&self) -> LocationActions {
        LocationActions { client: &self }
    }
    pub fn file(&self) -> FileActions {
        FileActions { client: &self }
    }
    pub fn tag(&self) -> TagActions {
        TagActions { client: &self }
    }
    pub fn tag_on_file(&self) -> TagOnFileActions {
        TagOnFileActions { client: &self }
    }
    pub fn job(&self) -> JobActions {
        JobActions { client: &self }
    }
    pub fn space(&self) -> SpaceActions {
        SpaceActions { client: &self }
    }
}
fn migration_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("name"),
        Output::new("checksum"),
        Output::new("steps_applied"),
        Output::new("applied_at"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MigrationData {
    #[serde(rename = "id")]
    pub id: i64,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "checksum")]
    pub checksum: String,
    #[serde(rename = "steps_applied")]
    pub steps_applied: i64,
    #[serde(rename = "applied_at")]
    pub applied_at: chrono::DateTime<chrono::Utc>,
}
impl MigrationData {}
pub struct Migration;
impl Migration {
    pub fn id() -> MigrationIdField {
        MigrationIdField {}
    }
    pub fn name() -> MigrationNameField {
        MigrationNameField {}
    }
    pub fn checksum() -> MigrationChecksumField {
        MigrationChecksumField {}
    }
    pub fn steps_applied() -> MigrationStepsAppliedField {
        MigrationStepsAppliedField {}
    }
    pub fn applied_at() -> MigrationAppliedAtField {
        MigrationAppliedAtField {}
    }
    pub fn not(params: Vec<MigrationWhereParam>) -> MigrationWhereParam {
        MigrationWhereParam::Not(params)
    }
    pub fn or(params: Vec<MigrationWhereParam>) -> MigrationWhereParam {
        MigrationWhereParam::Or(params)
    }
    pub fn and(params: Vec<MigrationWhereParam>) -> MigrationWhereParam {
        MigrationWhereParam::And(params)
    }
}
pub struct MigrationIdField {}
pub struct MigrationSetId(i64);
impl From<MigrationSetId> for MigrationSetParam {
    fn from(value: MigrationSetId) -> Self {
        Self::Id(value.0)
    }
}
impl MigrationIdField {
    pub fn lt(&self, value: i64) -> MigrationWhereParam {
        MigrationWhereParam::IdLT(value)
    }
    pub fn gt(&self, value: i64) -> MigrationWhereParam {
        MigrationWhereParam::IdGT(value)
    }
    pub fn lte(&self, value: i64) -> MigrationWhereParam {
        MigrationWhereParam::IdLTE(value)
    }
    pub fn gte(&self, value: i64) -> MigrationWhereParam {
        MigrationWhereParam::IdGTE(value)
    }
    pub fn equals(&self, value: i64) -> MigrationWhereParam {
        MigrationWhereParam::IdEquals(value)
    }
    pub fn set<T: From<MigrationSetId>>(&self, value: i64) -> T {
        MigrationSetId(value).into()
    }
}
pub struct MigrationNameField {}
pub struct MigrationSetName(String);
impl From<MigrationSetName> for MigrationSetParam {
    fn from(value: MigrationSetName) -> Self {
        Self::Name(value.0)
    }
}
impl MigrationNameField {
    pub fn contains(&self, value: String) -> MigrationWhereParam {
        MigrationWhereParam::NameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> MigrationWhereParam {
        MigrationWhereParam::NameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> MigrationWhereParam {
        MigrationWhereParam::NameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> MigrationWhereParam {
        MigrationWhereParam::NameEquals(value)
    }
    pub fn set<T: From<MigrationSetName>>(&self, value: String) -> T {
        MigrationSetName(value).into()
    }
}
pub struct MigrationChecksumField {}
pub struct MigrationSetChecksum(String);
impl From<MigrationSetChecksum> for MigrationSetParam {
    fn from(value: MigrationSetChecksum) -> Self {
        Self::Checksum(value.0)
    }
}
impl MigrationChecksumField {
    pub fn contains(&self, value: String) -> MigrationWhereParam {
        MigrationWhereParam::ChecksumContains(value)
    }
    pub fn has_prefix(&self, value: String) -> MigrationWhereParam {
        MigrationWhereParam::ChecksumHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> MigrationWhereParam {
        MigrationWhereParam::ChecksumHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> MigrationWhereParam {
        MigrationWhereParam::ChecksumEquals(value)
    }
    pub fn set<T: From<MigrationSetChecksum>>(&self, value: String) -> T {
        MigrationSetChecksum(value).into()
    }
}
pub struct MigrationStepsAppliedField {}
pub struct MigrationSetStepsApplied(i64);
impl From<MigrationSetStepsApplied> for MigrationSetParam {
    fn from(value: MigrationSetStepsApplied) -> Self {
        Self::StepsApplied(value.0)
    }
}
impl MigrationStepsAppliedField {
    pub fn lt(&self, value: i64) -> MigrationWhereParam {
        MigrationWhereParam::StepsAppliedLT(value)
    }
    pub fn gt(&self, value: i64) -> MigrationWhereParam {
        MigrationWhereParam::StepsAppliedGT(value)
    }
    pub fn lte(&self, value: i64) -> MigrationWhereParam {
        MigrationWhereParam::StepsAppliedLTE(value)
    }
    pub fn gte(&self, value: i64) -> MigrationWhereParam {
        MigrationWhereParam::StepsAppliedGTE(value)
    }
    pub fn equals(&self, value: i64) -> MigrationWhereParam {
        MigrationWhereParam::StepsAppliedEquals(value)
    }
    pub fn set<T: From<MigrationSetStepsApplied>>(&self, value: i64) -> T {
        MigrationSetStepsApplied(value).into()
    }
}
pub struct MigrationAppliedAtField {}
pub struct MigrationSetAppliedAt(chrono::DateTime<chrono::Utc>);
impl From<MigrationSetAppliedAt> for MigrationSetParam {
    fn from(value: MigrationSetAppliedAt) -> Self {
        Self::AppliedAt(value.0)
    }
}
impl MigrationAppliedAtField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
        MigrationWhereParam::AppliedAtBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
        MigrationWhereParam::AppliedAtAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
        MigrationWhereParam::AppliedAtBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
        MigrationWhereParam::AppliedAtAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
        MigrationWhereParam::AppliedAtEquals(value)
    }
    pub fn set<T: From<MigrationSetAppliedAt>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        MigrationSetAppliedAt(value).into()
    }
}
pub enum MigrationWhereParam {
    IdLT(i64),
    IdGT(i64),
    IdLTE(i64),
    IdGTE(i64),
    IdEquals(i64),
    NameContains(String),
    NameHasPrefix(String),
    NameHasSuffix(String),
    NameEquals(String),
    ChecksumContains(String),
    ChecksumHasPrefix(String),
    ChecksumHasSuffix(String),
    ChecksumEquals(String),
    StepsAppliedLT(i64),
    StepsAppliedGT(i64),
    StepsAppliedLTE(i64),
    StepsAppliedGTE(i64),
    StepsAppliedEquals(i64),
    AppliedAtBefore(chrono::DateTime<chrono::Utc>),
    AppliedAtAfter(chrono::DateTime<chrono::Utc>),
    AppliedAtBeforeEquals(chrono::DateTime<chrono::Utc>),
    AppliedAtAfterEquals(chrono::DateTime<chrono::Utc>),
    AppliedAtEquals(chrono::DateTime<chrono::Utc>),
    Not(Vec<MigrationWhereParam>),
    Or(Vec<MigrationWhereParam>),
    And(Vec<MigrationWhereParam>),
}
impl MigrationWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdLT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdLTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameContains(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasPrefix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasSuffix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameEquals(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ChecksumContains(value) => Field {
                name: "checksum".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ChecksumHasPrefix(value) => Field {
                name: "checksum".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ChecksumHasSuffix(value) => Field {
                name: "checksum".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ChecksumEquals(value) => Field {
                name: "checksum".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StepsAppliedLT(value) => Field {
                name: "steps_applied".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StepsAppliedGT(value) => Field {
                name: "steps_applied".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StepsAppliedLTE(value) => Field {
                name: "steps_applied".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StepsAppliedGTE(value) => Field {
                name: "steps_applied".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StepsAppliedEquals(value) => Field {
                name: "steps_applied".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AppliedAtBefore(value) => Field {
                name: "applied_at".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AppliedAtAfter(value) => Field {
                name: "applied_at".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AppliedAtBeforeEquals(value) => Field {
                name: "applied_at".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AppliedAtAfterEquals(value) => Field {
                name: "applied_at".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AppliedAtEquals(value) => Field {
                name: "applied_at".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct MigrationWith {
    pub param: MigrationWithParam,
}
pub enum MigrationWithParam {}
impl From<MigrationWithParam> for MigrationWith {
    fn from(param: MigrationWithParam) -> Self {
        Self { param }
    }
}
impl MigrationWithParam {
    pub fn output(self) -> Output {
        match self {}
    }
}
pub enum MigrationSetParam {
    Id(i64),
    Name(String),
    Checksum(String),
    StepsApplied(i64),
    AppliedAt(chrono::DateTime<chrono::Utc>),
}
impl MigrationSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Name(value) => Field {
                name: "name".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Checksum(value) => Field {
                name: "checksum".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::StepsApplied(value) => Field {
                name: "steps_applied".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::AppliedAt(value) => Field {
                name: "applied_at".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
        }
    }
}
pub struct MigrationFindMany<'a> {
    query: Query<'a>,
}
impl<'a> MigrationFindMany<'a> {
    pub async fn exec(self) -> Vec<MigrationData> {
        self.query.perform::<Vec<MigrationData>>().await.unwrap()
    }
    pub fn delete(self) -> MigrationDelete<'a> {
        MigrationDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "Migration".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<MigrationSetParam>) -> MigrationUpdateMany<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        MigrationUpdateMany {
            query: Query {
                operation: "mutation".into(),
                method: "updateMany".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<MigrationWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct MigrationFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> MigrationFindFirst<'a> {
    pub async fn exec(self) -> Option<MigrationData> {
        self.query.perform::<Option<MigrationData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<MigrationWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct MigrationFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> MigrationFindUnique<'a> {
    pub async fn exec(self) -> Option<MigrationData> {
        self.query.perform::<Option<MigrationData>>().await.unwrap()
    }
    pub fn delete(self) -> MigrationDelete<'a> {
        MigrationDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "Migration".into(),
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<MigrationSetParam>) -> MigrationUpdateUnique<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        MigrationUpdateUnique {
            query: Query {
                operation: "mutation".into(),
                method: "updateOne".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<MigrationWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct MigrationCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> MigrationCreateOne<'a> {
    pub async fn exec(self) -> MigrationData {
        self.query.perform::<MigrationData>().await.unwrap()
    }
}
pub struct MigrationUpdateUnique<'a> {
    query: Query<'a>,
}
impl<'a> MigrationUpdateUnique<'a> {
    pub async fn exec(self) -> MigrationData {
        self.query.perform::<MigrationData>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<MigrationWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct MigrationUpdateMany<'a> {
    query: Query<'a>,
}
impl<'a> MigrationUpdateMany<'a> {
    pub async fn exec(self) -> Vec<MigrationData> {
        self.query.perform::<Vec<MigrationData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<MigrationWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct MigrationDelete<'a> {
    query: Query<'a>,
}
impl<'a> MigrationDelete<'a> {
    pub async fn exec(self) -> isize {
        self.query.perform::<DeleteResult>().await.unwrap().count
    }
}
pub struct MigrationActions<'a> {
    client: &'a PrismaClient,
}
impl<'a> MigrationActions<'a> {
    pub fn find_unique(&self, param: MigrationWhereParam) -> MigrationFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "Migration".into(),
            outputs: migration_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        MigrationFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<MigrationWhereParam>) -> MigrationFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "Migration".into(),
            outputs: migration_outputs(),
            inputs,
        };
        MigrationFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<MigrationWhereParam>) -> MigrationFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "Migration".into(),
            outputs: migration_outputs(),
            inputs,
        };
        MigrationFindMany { query }
    }
    pub fn create_one(
        &self,
        name: MigrationSetName,
        checksum: MigrationSetChecksum,
        params: Vec<MigrationSetParam>,
    ) -> MigrationCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(MigrationSetParam::from(name).field());
        input_fields.push(MigrationSetParam::from(checksum).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "Migration".into(),
            outputs: migration_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        MigrationCreateOne { query }
    }
}
fn library_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("uuid"),
        Output::new("name"),
        Output::new("remote_id"),
        Output::new("is_primary"),
        Output::new("encryption"),
        Output::new("total_file_count"),
        Output::new("total_bytes_used"),
        Output::new("total_byte_capacity"),
        Output::new("total_unique_bytes"),
        Output::new("date_created"),
        Output::new("timezone"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LibraryData {
    #[serde(rename = "id")]
    pub id: i64,
    #[serde(rename = "uuid")]
    pub uuid: String,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "remote_id")]
    pub remote_id: Option<String>,
    #[serde(rename = "is_primary")]
    pub is_primary: bool,
    #[serde(rename = "encryption")]
    pub encryption: i64,
    #[serde(rename = "total_file_count")]
    pub total_file_count: i64,
    #[serde(rename = "total_bytes_used")]
    pub total_bytes_used: String,
    #[serde(rename = "total_byte_capacity")]
    pub total_byte_capacity: String,
    #[serde(rename = "total_unique_bytes")]
    pub total_unique_bytes: String,
    #[serde(rename = "date_created")]
    pub date_created: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "timezone")]
    pub timezone: Option<String>,
    #[serde(rename = "spaces")]
    spaces: Option<Vec<SpaceData>>,
}
impl LibraryData {
    pub fn spaces(&self) -> Result<&Vec<SpaceData>, String> {
        match self.spaces.as_ref() {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access spaces but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct Library;
impl Library {
    pub fn id() -> LibraryIdField {
        LibraryIdField {}
    }
    pub fn uuid() -> LibraryUuidField {
        LibraryUuidField {}
    }
    pub fn name() -> LibraryNameField {
        LibraryNameField {}
    }
    pub fn remote_id() -> LibraryRemoteIdField {
        LibraryRemoteIdField {}
    }
    pub fn is_primary() -> LibraryIsPrimaryField {
        LibraryIsPrimaryField {}
    }
    pub fn encryption() -> LibraryEncryptionField {
        LibraryEncryptionField {}
    }
    pub fn total_file_count() -> LibraryTotalFileCountField {
        LibraryTotalFileCountField {}
    }
    pub fn total_bytes_used() -> LibraryTotalBytesUsedField {
        LibraryTotalBytesUsedField {}
    }
    pub fn total_byte_capacity() -> LibraryTotalByteCapacityField {
        LibraryTotalByteCapacityField {}
    }
    pub fn total_unique_bytes() -> LibraryTotalUniqueBytesField {
        LibraryTotalUniqueBytesField {}
    }
    pub fn date_created() -> LibraryDateCreatedField {
        LibraryDateCreatedField {}
    }
    pub fn timezone() -> LibraryTimezoneField {
        LibraryTimezoneField {}
    }
    pub fn spaces() -> LibrarySpacesField {
        LibrarySpacesField {}
    }
    pub fn not(params: Vec<LibraryWhereParam>) -> LibraryWhereParam {
        LibraryWhereParam::Not(params)
    }
    pub fn or(params: Vec<LibraryWhereParam>) -> LibraryWhereParam {
        LibraryWhereParam::Or(params)
    }
    pub fn and(params: Vec<LibraryWhereParam>) -> LibraryWhereParam {
        LibraryWhereParam::And(params)
    }
}
pub struct LibraryIdField {}
pub struct LibrarySetId(i64);
impl From<LibrarySetId> for LibrarySetParam {
    fn from(value: LibrarySetId) -> Self {
        Self::Id(value.0)
    }
}
impl LibraryIdField {
    pub fn lt(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::IdLT(value)
    }
    pub fn gt(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::IdGT(value)
    }
    pub fn lte(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::IdLTE(value)
    }
    pub fn gte(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::IdGTE(value)
    }
    pub fn equals(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::IdEquals(value)
    }
    pub fn set<T: From<LibrarySetId>>(&self, value: i64) -> T {
        LibrarySetId(value).into()
    }
}
pub struct LibraryUuidField {}
pub struct LibrarySetUuid(String);
impl From<LibrarySetUuid> for LibrarySetParam {
    fn from(value: LibrarySetUuid) -> Self {
        Self::Uuid(value.0)
    }
}
impl LibraryUuidField {
    pub fn contains(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::UuidContains(value)
    }
    pub fn has_prefix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::UuidHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::UuidHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::UuidEquals(value)
    }
    pub fn set<T: From<LibrarySetUuid>>(&self, value: String) -> T {
        LibrarySetUuid(value).into()
    }
}
pub struct LibraryNameField {}
pub struct LibrarySetName(String);
impl From<LibrarySetName> for LibrarySetParam {
    fn from(value: LibrarySetName) -> Self {
        Self::Name(value.0)
    }
}
impl LibraryNameField {
    pub fn contains(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::NameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::NameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::NameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::NameEquals(value)
    }
    pub fn set<T: From<LibrarySetName>>(&self, value: String) -> T {
        LibrarySetName(value).into()
    }
}
pub struct LibraryRemoteIdField {}
pub struct LibrarySetRemoteId(String);
impl From<LibrarySetRemoteId> for LibrarySetParam {
    fn from(value: LibrarySetRemoteId) -> Self {
        Self::RemoteId(value.0)
    }
}
impl LibraryRemoteIdField {
    pub fn contains(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::RemoteIdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::RemoteIdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::RemoteIdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::RemoteIdEquals(value)
    }
    pub fn set<T: From<LibrarySetRemoteId>>(&self, value: String) -> T {
        LibrarySetRemoteId(value).into()
    }
}
pub struct LibraryIsPrimaryField {}
pub struct LibrarySetIsPrimary(bool);
impl From<LibrarySetIsPrimary> for LibrarySetParam {
    fn from(value: LibrarySetIsPrimary) -> Self {
        Self::IsPrimary(value.0)
    }
}
impl LibraryIsPrimaryField {
    pub fn equals(&self, value: bool) -> LibraryWhereParam {
        LibraryWhereParam::IsPrimaryEquals(value)
    }
    pub fn set<T: From<LibrarySetIsPrimary>>(&self, value: bool) -> T {
        LibrarySetIsPrimary(value).into()
    }
}
pub struct LibraryEncryptionField {}
pub struct LibrarySetEncryption(i64);
impl From<LibrarySetEncryption> for LibrarySetParam {
    fn from(value: LibrarySetEncryption) -> Self {
        Self::Encryption(value.0)
    }
}
impl LibraryEncryptionField {
    pub fn lt(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::EncryptionLT(value)
    }
    pub fn gt(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::EncryptionGT(value)
    }
    pub fn lte(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::EncryptionLTE(value)
    }
    pub fn gte(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::EncryptionGTE(value)
    }
    pub fn equals(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::EncryptionEquals(value)
    }
    pub fn set<T: From<LibrarySetEncryption>>(&self, value: i64) -> T {
        LibrarySetEncryption(value).into()
    }
}
pub struct LibraryTotalFileCountField {}
pub struct LibrarySetTotalFileCount(i64);
impl From<LibrarySetTotalFileCount> for LibrarySetParam {
    fn from(value: LibrarySetTotalFileCount) -> Self {
        Self::TotalFileCount(value.0)
    }
}
impl LibraryTotalFileCountField {
    pub fn lt(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::TotalFileCountLT(value)
    }
    pub fn gt(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::TotalFileCountGT(value)
    }
    pub fn lte(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::TotalFileCountLTE(value)
    }
    pub fn gte(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::TotalFileCountGTE(value)
    }
    pub fn equals(&self, value: i64) -> LibraryWhereParam {
        LibraryWhereParam::TotalFileCountEquals(value)
    }
    pub fn set<T: From<LibrarySetTotalFileCount>>(&self, value: i64) -> T {
        LibrarySetTotalFileCount(value).into()
    }
}
pub struct LibraryTotalBytesUsedField {}
pub struct LibrarySetTotalBytesUsed(String);
impl From<LibrarySetTotalBytesUsed> for LibrarySetParam {
    fn from(value: LibrarySetTotalBytesUsed) -> Self {
        Self::TotalBytesUsed(value.0)
    }
}
impl LibraryTotalBytesUsedField {
    pub fn contains(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalBytesUsedContains(value)
    }
    pub fn has_prefix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalBytesUsedHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalBytesUsedHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalBytesUsedEquals(value)
    }
    pub fn set<T: From<LibrarySetTotalBytesUsed>>(&self, value: String) -> T {
        LibrarySetTotalBytesUsed(value).into()
    }
}
pub struct LibraryTotalByteCapacityField {}
pub struct LibrarySetTotalByteCapacity(String);
impl From<LibrarySetTotalByteCapacity> for LibrarySetParam {
    fn from(value: LibrarySetTotalByteCapacity) -> Self {
        Self::TotalByteCapacity(value.0)
    }
}
impl LibraryTotalByteCapacityField {
    pub fn contains(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalByteCapacityContains(value)
    }
    pub fn has_prefix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalByteCapacityHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalByteCapacityHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalByteCapacityEquals(value)
    }
    pub fn set<T: From<LibrarySetTotalByteCapacity>>(&self, value: String) -> T {
        LibrarySetTotalByteCapacity(value).into()
    }
}
pub struct LibraryTotalUniqueBytesField {}
pub struct LibrarySetTotalUniqueBytes(String);
impl From<LibrarySetTotalUniqueBytes> for LibrarySetParam {
    fn from(value: LibrarySetTotalUniqueBytes) -> Self {
        Self::TotalUniqueBytes(value.0)
    }
}
impl LibraryTotalUniqueBytesField {
    pub fn contains(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalUniqueBytesContains(value)
    }
    pub fn has_prefix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalUniqueBytesHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalUniqueBytesHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TotalUniqueBytesEquals(value)
    }
    pub fn set<T: From<LibrarySetTotalUniqueBytes>>(&self, value: String) -> T {
        LibrarySetTotalUniqueBytes(value).into()
    }
}
pub struct LibraryDateCreatedField {}
pub struct LibrarySetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<LibrarySetDateCreated> for LibrarySetParam {
    fn from(value: LibrarySetDateCreated) -> Self {
        Self::DateCreated(value.0)
    }
}
impl LibraryDateCreatedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
        LibraryWhereParam::DateCreatedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
        LibraryWhereParam::DateCreatedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
        LibraryWhereParam::DateCreatedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
        LibraryWhereParam::DateCreatedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
        LibraryWhereParam::DateCreatedEquals(value)
    }
    pub fn set<T: From<LibrarySetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        LibrarySetDateCreated(value).into()
    }
}
pub struct LibraryTimezoneField {}
pub struct LibrarySetTimezone(String);
impl From<LibrarySetTimezone> for LibrarySetParam {
    fn from(value: LibrarySetTimezone) -> Self {
        Self::Timezone(value.0)
    }
}
impl LibraryTimezoneField {
    pub fn contains(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TimezoneContains(value)
    }
    pub fn has_prefix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TimezoneHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TimezoneHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> LibraryWhereParam {
        LibraryWhereParam::TimezoneEquals(value)
    }
    pub fn set<T: From<LibrarySetTimezone>>(&self, value: String) -> T {
        LibrarySetTimezone(value).into()
    }
}
pub struct LibrarySpacesField {}
pub struct LibraryLinkSpaces(Vec<SpaceWhereParam>);
impl From<LibraryLinkSpaces> for LibrarySetParam {
    fn from(value: LibraryLinkSpaces) -> Self {
        Self::LinkSpaces(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl LibrarySpacesField {
    pub fn some(&self, value: Vec<SpaceWhereParam>) -> LibraryWhereParam {
        LibraryWhereParam::SpacesSome(value)
    }
    pub fn every(&self, value: Vec<SpaceWhereParam>) -> LibraryWhereParam {
        LibraryWhereParam::SpacesEvery(value)
    }
    pub fn link<T: From<LibraryLinkSpaces>>(&self, value: Vec<SpaceWhereParam>) -> T {
        LibraryLinkSpaces(value).into()
    }
    pub fn unlink(&self, params: Vec<SpaceWhereParam>) -> LibrarySetParam {
        LibrarySetParam::UnlinkSpaces(params)
    }
    pub fn fetch(&self, params: Vec<SpaceWhereParam>) -> LibraryWith {
        LibraryWithParam::Spaces(params).into()
    }
}
pub enum LibraryWhereParam {
    IdLT(i64),
    IdGT(i64),
    IdLTE(i64),
    IdGTE(i64),
    IdEquals(i64),
    UuidContains(String),
    UuidHasPrefix(String),
    UuidHasSuffix(String),
    UuidEquals(String),
    NameContains(String),
    NameHasPrefix(String),
    NameHasSuffix(String),
    NameEquals(String),
    RemoteIdContains(String),
    RemoteIdHasPrefix(String),
    RemoteIdHasSuffix(String),
    RemoteIdEquals(String),
    IsPrimaryEquals(bool),
    EncryptionLT(i64),
    EncryptionGT(i64),
    EncryptionLTE(i64),
    EncryptionGTE(i64),
    EncryptionEquals(i64),
    TotalFileCountLT(i64),
    TotalFileCountGT(i64),
    TotalFileCountLTE(i64),
    TotalFileCountGTE(i64),
    TotalFileCountEquals(i64),
    TotalBytesUsedContains(String),
    TotalBytesUsedHasPrefix(String),
    TotalBytesUsedHasSuffix(String),
    TotalBytesUsedEquals(String),
    TotalByteCapacityContains(String),
    TotalByteCapacityHasPrefix(String),
    TotalByteCapacityHasSuffix(String),
    TotalByteCapacityEquals(String),
    TotalUniqueBytesContains(String),
    TotalUniqueBytesHasPrefix(String),
    TotalUniqueBytesHasSuffix(String),
    TotalUniqueBytesEquals(String),
    DateCreatedBefore(chrono::DateTime<chrono::Utc>),
    DateCreatedAfter(chrono::DateTime<chrono::Utc>),
    DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedEquals(chrono::DateTime<chrono::Utc>),
    TimezoneContains(String),
    TimezoneHasPrefix(String),
    TimezoneHasSuffix(String),
    TimezoneEquals(String),
    SpacesSome(Vec<SpaceWhereParam>),
    SpacesEvery(Vec<SpaceWhereParam>),
    Not(Vec<LibraryWhereParam>),
    Or(Vec<LibraryWhereParam>),
    And(Vec<LibraryWhereParam>),
}
impl LibraryWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdLT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdLTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UuidContains(value) => Field {
                name: "uuid".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UuidHasPrefix(value) => Field {
                name: "uuid".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UuidHasSuffix(value) => Field {
                name: "uuid".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UuidEquals(value) => Field {
                name: "uuid".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameContains(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasPrefix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasSuffix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameEquals(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::RemoteIdContains(value) => Field {
                name: "remote_id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::RemoteIdHasPrefix(value) => Field {
                name: "remote_id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::RemoteIdHasSuffix(value) => Field {
                name: "remote_id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::RemoteIdEquals(value) => Field {
                name: "remote_id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IsPrimaryEquals(value) => Field {
                name: "is_primary".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionLT(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionGT(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionLTE(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionGTE(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionEquals(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalFileCountLT(value) => Field {
                name: "total_file_count".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalFileCountGT(value) => Field {
                name: "total_file_count".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalFileCountLTE(value) => Field {
                name: "total_file_count".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalFileCountGTE(value) => Field {
                name: "total_file_count".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalFileCountEquals(value) => Field {
                name: "total_file_count".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalBytesUsedContains(value) => Field {
                name: "total_bytes_used".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalBytesUsedHasPrefix(value) => Field {
                name: "total_bytes_used".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalBytesUsedHasSuffix(value) => Field {
                name: "total_bytes_used".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalBytesUsedEquals(value) => Field {
                name: "total_bytes_used".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalByteCapacityContains(value) => Field {
                name: "total_byte_capacity".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalByteCapacityHasPrefix(value) => Field {
                name: "total_byte_capacity".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalByteCapacityHasSuffix(value) => Field {
                name: "total_byte_capacity".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalByteCapacityEquals(value) => Field {
                name: "total_byte_capacity".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalUniqueBytesContains(value) => Field {
                name: "total_unique_bytes".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalUniqueBytesHasPrefix(value) => Field {
                name: "total_unique_bytes".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalUniqueBytesHasSuffix(value) => Field {
                name: "total_unique_bytes".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalUniqueBytesEquals(value) => Field {
                name: "total_unique_bytes".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBefore(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfter(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBeforeEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfterEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TimezoneContains(value) => Field {
                name: "timezone".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TimezoneHasPrefix(value) => Field {
                name: "timezone".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TimezoneHasSuffix(value) => Field {
                name: "timezone".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TimezoneEquals(value) => Field {
                name: "timezone".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::SpacesSome(value) => Field {
                name: "spaces".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::SpacesEvery(value) => Field {
                name: "spaces".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct LibraryWith {
    pub param: LibraryWithParam,
}
pub enum LibraryWithParam {
    Spaces(Vec<SpaceWhereParam>),
}
impl From<LibraryWithParam> for LibraryWith {
    fn from(param: LibraryWithParam) -> Self {
        Self { param }
    }
}
impl LibraryWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Spaces(where_params) => Output {
                name: "spaces".into(),
                outputs: space_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
        }
    }
}
pub enum LibrarySetParam {
    Id(i64),
    Uuid(String),
    Name(String),
    RemoteId(String),
    IsPrimary(bool),
    Encryption(i64),
    TotalFileCount(i64),
    TotalBytesUsed(String),
    TotalByteCapacity(String),
    TotalUniqueBytes(String),
    DateCreated(chrono::DateTime<chrono::Utc>),
    Timezone(String),
    LinkSpaces(Vec<SpaceWhereParam>),
    UnlinkSpaces(Vec<SpaceWhereParam>),
}
impl LibrarySetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Uuid(value) => Field {
                name: "uuid".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Name(value) => Field {
                name: "name".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::RemoteId(value) => Field {
                name: "remote_id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::IsPrimary(value) => Field {
                name: "is_primary".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Encryption(value) => Field {
                name: "encryption".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::TotalFileCount(value) => Field {
                name: "total_file_count".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::TotalBytesUsed(value) => Field {
                name: "total_bytes_used".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::TotalByteCapacity(value) => Field {
                name: "total_byte_capacity".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::TotalUniqueBytes(value) => Field {
                name: "total_unique_bytes".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateCreated(value) => Field {
                name: "date_created".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Timezone(value) => Field {
                name: "timezone".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkSpaces(where_params) => Field {
                name: "spaces".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UnlinkSpaces(where_params) => Field {
                name: "spaces".into(),
                fields: Some(vec![Field {
                    name: "disconnect".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub struct LibraryFindMany<'a> {
    query: Query<'a>,
}
impl<'a> LibraryFindMany<'a> {
    pub async fn exec(self) -> Vec<LibraryData> {
        self.query.perform::<Vec<LibraryData>>().await.unwrap()
    }
    pub fn delete(self) -> LibraryDelete<'a> {
        LibraryDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "Library".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<LibrarySetParam>) -> LibraryUpdateMany<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        LibraryUpdateMany {
            query: Query {
                operation: "mutation".into(),
                method: "updateMany".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<LibraryWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct LibraryFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> LibraryFindFirst<'a> {
    pub async fn exec(self) -> Option<LibraryData> {
        self.query.perform::<Option<LibraryData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<LibraryWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct LibraryFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> LibraryFindUnique<'a> {
    pub async fn exec(self) -> Option<LibraryData> {
        self.query.perform::<Option<LibraryData>>().await.unwrap()
    }
    pub fn delete(self) -> LibraryDelete<'a> {
        LibraryDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "Library".into(),
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<LibrarySetParam>) -> LibraryUpdateUnique<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        LibraryUpdateUnique {
            query: Query {
                operation: "mutation".into(),
                method: "updateOne".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<LibraryWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct LibraryCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> LibraryCreateOne<'a> {
    pub async fn exec(self) -> LibraryData {
        self.query.perform::<LibraryData>().await.unwrap()
    }
}
pub struct LibraryUpdateUnique<'a> {
    query: Query<'a>,
}
impl<'a> LibraryUpdateUnique<'a> {
    pub async fn exec(self) -> LibraryData {
        self.query.perform::<LibraryData>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<LibraryWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct LibraryUpdateMany<'a> {
    query: Query<'a>,
}
impl<'a> LibraryUpdateMany<'a> {
    pub async fn exec(self) -> Vec<LibraryData> {
        self.query.perform::<Vec<LibraryData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<LibraryWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct LibraryDelete<'a> {
    query: Query<'a>,
}
impl<'a> LibraryDelete<'a> {
    pub async fn exec(self) -> isize {
        self.query.perform::<DeleteResult>().await.unwrap().count
    }
}
pub struct LibraryActions<'a> {
    client: &'a PrismaClient,
}
impl<'a> LibraryActions<'a> {
    pub fn find_unique(&self, param: LibraryWhereParam) -> LibraryFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "Library".into(),
            outputs: library_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        LibraryFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<LibraryWhereParam>) -> LibraryFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "Library".into(),
            outputs: library_outputs(),
            inputs,
        };
        LibraryFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<LibraryWhereParam>) -> LibraryFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "Library".into(),
            outputs: library_outputs(),
            inputs,
        };
        LibraryFindMany { query }
    }
    pub fn create_one(
        &self,
        uuid: LibrarySetUuid,
        name: LibrarySetName,
        params: Vec<LibrarySetParam>,
    ) -> LibraryCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(LibrarySetParam::from(uuid).field());
        input_fields.push(LibrarySetParam::from(name).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "Library".into(),
            outputs: library_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        LibraryCreateOne { query }
    }
}
fn client_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("uuid"),
        Output::new("name"),
        Output::new("platform"),
        Output::new("version"),
        Output::new("online"),
        Output::new("last_seen"),
        Output::new("timezone"),
        Output::new("date_created"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientData {
    #[serde(rename = "id")]
    pub id: i64,
    #[serde(rename = "uuid")]
    pub uuid: String,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "platform")]
    pub platform: i64,
    #[serde(rename = "version")]
    pub version: Option<String>,
    #[serde(rename = "online")]
    pub online: Option<bool>,
    #[serde(rename = "last_seen")]
    pub last_seen: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "timezone")]
    pub timezone: Option<String>,
    #[serde(rename = "date_created")]
    pub date_created: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "jobs")]
    jobs: Option<Vec<JobData>>,
}
impl ClientData {
    pub fn jobs(&self) -> Result<&Vec<JobData>, String> {
        match self.jobs.as_ref() {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access jobs but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct Client;
impl Client {
    pub fn id() -> ClientIdField {
        ClientIdField {}
    }
    pub fn uuid() -> ClientUuidField {
        ClientUuidField {}
    }
    pub fn name() -> ClientNameField {
        ClientNameField {}
    }
    pub fn platform() -> ClientPlatformField {
        ClientPlatformField {}
    }
    pub fn version() -> ClientVersionField {
        ClientVersionField {}
    }
    pub fn online() -> ClientOnlineField {
        ClientOnlineField {}
    }
    pub fn last_seen() -> ClientLastSeenField {
        ClientLastSeenField {}
    }
    pub fn timezone() -> ClientTimezoneField {
        ClientTimezoneField {}
    }
    pub fn date_created() -> ClientDateCreatedField {
        ClientDateCreatedField {}
    }
    pub fn jobs() -> ClientJobsField {
        ClientJobsField {}
    }
    pub fn not(params: Vec<ClientWhereParam>) -> ClientWhereParam {
        ClientWhereParam::Not(params)
    }
    pub fn or(params: Vec<ClientWhereParam>) -> ClientWhereParam {
        ClientWhereParam::Or(params)
    }
    pub fn and(params: Vec<ClientWhereParam>) -> ClientWhereParam {
        ClientWhereParam::And(params)
    }
}
pub struct ClientIdField {}
pub struct ClientSetId(i64);
impl From<ClientSetId> for ClientSetParam {
    fn from(value: ClientSetId) -> Self {
        Self::Id(value.0)
    }
}
impl ClientIdField {
    pub fn lt(&self, value: i64) -> ClientWhereParam {
        ClientWhereParam::IdLT(value)
    }
    pub fn gt(&self, value: i64) -> ClientWhereParam {
        ClientWhereParam::IdGT(value)
    }
    pub fn lte(&self, value: i64) -> ClientWhereParam {
        ClientWhereParam::IdLTE(value)
    }
    pub fn gte(&self, value: i64) -> ClientWhereParam {
        ClientWhereParam::IdGTE(value)
    }
    pub fn equals(&self, value: i64) -> ClientWhereParam {
        ClientWhereParam::IdEquals(value)
    }
    pub fn set<T: From<ClientSetId>>(&self, value: i64) -> T {
        ClientSetId(value).into()
    }
}
pub struct ClientUuidField {}
pub struct ClientSetUuid(String);
impl From<ClientSetUuid> for ClientSetParam {
    fn from(value: ClientSetUuid) -> Self {
        Self::Uuid(value.0)
    }
}
impl ClientUuidField {
    pub fn contains(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::UuidContains(value)
    }
    pub fn has_prefix(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::UuidHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::UuidHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::UuidEquals(value)
    }
    pub fn set<T: From<ClientSetUuid>>(&self, value: String) -> T {
        ClientSetUuid(value).into()
    }
}
pub struct ClientNameField {}
pub struct ClientSetName(String);
impl From<ClientSetName> for ClientSetParam {
    fn from(value: ClientSetName) -> Self {
        Self::Name(value.0)
    }
}
impl ClientNameField {
    pub fn contains(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::NameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::NameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::NameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::NameEquals(value)
    }
    pub fn set<T: From<ClientSetName>>(&self, value: String) -> T {
        ClientSetName(value).into()
    }
}
pub struct ClientPlatformField {}
pub struct ClientSetPlatform(i64);
impl From<ClientSetPlatform> for ClientSetParam {
    fn from(value: ClientSetPlatform) -> Self {
        Self::Platform(value.0)
    }
}
impl ClientPlatformField {
    pub fn lt(&self, value: i64) -> ClientWhereParam {
        ClientWhereParam::PlatformLT(value)
    }
    pub fn gt(&self, value: i64) -> ClientWhereParam {
        ClientWhereParam::PlatformGT(value)
    }
    pub fn lte(&self, value: i64) -> ClientWhereParam {
        ClientWhereParam::PlatformLTE(value)
    }
    pub fn gte(&self, value: i64) -> ClientWhereParam {
        ClientWhereParam::PlatformGTE(value)
    }
    pub fn equals(&self, value: i64) -> ClientWhereParam {
        ClientWhereParam::PlatformEquals(value)
    }
    pub fn set<T: From<ClientSetPlatform>>(&self, value: i64) -> T {
        ClientSetPlatform(value).into()
    }
}
pub struct ClientVersionField {}
pub struct ClientSetVersion(String);
impl From<ClientSetVersion> for ClientSetParam {
    fn from(value: ClientSetVersion) -> Self {
        Self::Version(value.0)
    }
}
impl ClientVersionField {
    pub fn contains(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::VersionContains(value)
    }
    pub fn has_prefix(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::VersionHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::VersionHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::VersionEquals(value)
    }
    pub fn set<T: From<ClientSetVersion>>(&self, value: String) -> T {
        ClientSetVersion(value).into()
    }
}
pub struct ClientOnlineField {}
pub struct ClientSetOnline(bool);
impl From<ClientSetOnline> for ClientSetParam {
    fn from(value: ClientSetOnline) -> Self {
        Self::Online(value.0)
    }
}
impl ClientOnlineField {
    pub fn equals(&self, value: bool) -> ClientWhereParam {
        ClientWhereParam::OnlineEquals(value)
    }
    pub fn set<T: From<ClientSetOnline>>(&self, value: bool) -> T {
        ClientSetOnline(value).into()
    }
}
pub struct ClientLastSeenField {}
pub struct ClientSetLastSeen(chrono::DateTime<chrono::Utc>);
impl From<ClientSetLastSeen> for ClientSetParam {
    fn from(value: ClientSetLastSeen) -> Self {
        Self::LastSeen(value.0)
    }
}
impl ClientLastSeenField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
        ClientWhereParam::LastSeenBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
        ClientWhereParam::LastSeenAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
        ClientWhereParam::LastSeenBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
        ClientWhereParam::LastSeenAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
        ClientWhereParam::LastSeenEquals(value)
    }
    pub fn set<T: From<ClientSetLastSeen>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        ClientSetLastSeen(value).into()
    }
}
pub struct ClientTimezoneField {}
pub struct ClientSetTimezone(String);
impl From<ClientSetTimezone> for ClientSetParam {
    fn from(value: ClientSetTimezone) -> Self {
        Self::Timezone(value.0)
    }
}
impl ClientTimezoneField {
    pub fn contains(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::TimezoneContains(value)
    }
    pub fn has_prefix(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::TimezoneHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::TimezoneHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> ClientWhereParam {
        ClientWhereParam::TimezoneEquals(value)
    }
    pub fn set<T: From<ClientSetTimezone>>(&self, value: String) -> T {
        ClientSetTimezone(value).into()
    }
}
pub struct ClientDateCreatedField {}
pub struct ClientSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<ClientSetDateCreated> for ClientSetParam {
    fn from(value: ClientSetDateCreated) -> Self {
        Self::DateCreated(value.0)
    }
}
impl ClientDateCreatedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
        ClientWhereParam::DateCreatedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
        ClientWhereParam::DateCreatedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
        ClientWhereParam::DateCreatedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
        ClientWhereParam::DateCreatedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
        ClientWhereParam::DateCreatedEquals(value)
    }
    pub fn set<T: From<ClientSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        ClientSetDateCreated(value).into()
    }
}
pub struct ClientJobsField {}
pub struct ClientLinkJobs(Vec<JobWhereParam>);
impl From<ClientLinkJobs> for ClientSetParam {
    fn from(value: ClientLinkJobs) -> Self {
        Self::LinkJobs(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl ClientJobsField {
    pub fn some(&self, value: Vec<JobWhereParam>) -> ClientWhereParam {
        ClientWhereParam::JobsSome(value)
    }
    pub fn every(&self, value: Vec<JobWhereParam>) -> ClientWhereParam {
        ClientWhereParam::JobsEvery(value)
    }
    pub fn link<T: From<ClientLinkJobs>>(&self, value: Vec<JobWhereParam>) -> T {
        ClientLinkJobs(value).into()
    }
    pub fn unlink(&self, params: Vec<JobWhereParam>) -> ClientSetParam {
        ClientSetParam::UnlinkJobs(params)
    }
    pub fn fetch(&self, params: Vec<JobWhereParam>) -> ClientWith {
        ClientWithParam::Jobs(params).into()
    }
}
pub enum ClientWhereParam {
    IdLT(i64),
    IdGT(i64),
    IdLTE(i64),
    IdGTE(i64),
    IdEquals(i64),
    UuidContains(String),
    UuidHasPrefix(String),
    UuidHasSuffix(String),
    UuidEquals(String),
    NameContains(String),
    NameHasPrefix(String),
    NameHasSuffix(String),
    NameEquals(String),
    PlatformLT(i64),
    PlatformGT(i64),
    PlatformLTE(i64),
    PlatformGTE(i64),
    PlatformEquals(i64),
    VersionContains(String),
    VersionHasPrefix(String),
    VersionHasSuffix(String),
    VersionEquals(String),
    OnlineEquals(bool),
    LastSeenBefore(chrono::DateTime<chrono::Utc>),
    LastSeenAfter(chrono::DateTime<chrono::Utc>),
    LastSeenBeforeEquals(chrono::DateTime<chrono::Utc>),
    LastSeenAfterEquals(chrono::DateTime<chrono::Utc>),
    LastSeenEquals(chrono::DateTime<chrono::Utc>),
    TimezoneContains(String),
    TimezoneHasPrefix(String),
    TimezoneHasSuffix(String),
    TimezoneEquals(String),
    DateCreatedBefore(chrono::DateTime<chrono::Utc>),
    DateCreatedAfter(chrono::DateTime<chrono::Utc>),
    DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedEquals(chrono::DateTime<chrono::Utc>),
    JobsSome(Vec<JobWhereParam>),
    JobsEvery(Vec<JobWhereParam>),
    Not(Vec<ClientWhereParam>),
    Or(Vec<ClientWhereParam>),
    And(Vec<ClientWhereParam>),
}
impl ClientWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdLT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdLTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UuidContains(value) => Field {
                name: "uuid".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UuidHasPrefix(value) => Field {
                name: "uuid".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UuidHasSuffix(value) => Field {
                name: "uuid".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UuidEquals(value) => Field {
                name: "uuid".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameContains(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasPrefix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasSuffix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameEquals(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PlatformLT(value) => Field {
                name: "platform".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PlatformGT(value) => Field {
                name: "platform".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PlatformLTE(value) => Field {
                name: "platform".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PlatformGTE(value) => Field {
                name: "platform".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PlatformEquals(value) => Field {
                name: "platform".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::VersionContains(value) => Field {
                name: "version".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::VersionHasPrefix(value) => Field {
                name: "version".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::VersionHasSuffix(value) => Field {
                name: "version".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::VersionEquals(value) => Field {
                name: "version".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::OnlineEquals(value) => Field {
                name: "online".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LastSeenBefore(value) => Field {
                name: "last_seen".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LastSeenAfter(value) => Field {
                name: "last_seen".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LastSeenBeforeEquals(value) => Field {
                name: "last_seen".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LastSeenAfterEquals(value) => Field {
                name: "last_seen".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LastSeenEquals(value) => Field {
                name: "last_seen".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TimezoneContains(value) => Field {
                name: "timezone".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TimezoneHasPrefix(value) => Field {
                name: "timezone".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TimezoneHasSuffix(value) => Field {
                name: "timezone".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TimezoneEquals(value) => Field {
                name: "timezone".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBefore(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfter(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBeforeEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfterEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::JobsSome(value) => Field {
                name: "jobs".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::JobsEvery(value) => Field {
                name: "jobs".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct ClientWith {
    pub param: ClientWithParam,
}
pub enum ClientWithParam {
    Jobs(Vec<JobWhereParam>),
}
impl From<ClientWithParam> for ClientWith {
    fn from(param: ClientWithParam) -> Self {
        Self { param }
    }
}
impl ClientWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Jobs(where_params) => Output {
                name: "jobs".into(),
                outputs: job_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
        }
    }
}
pub enum ClientSetParam {
    Id(i64),
    Uuid(String),
    Name(String),
    Platform(i64),
    Version(String),
    Online(bool),
    LastSeen(chrono::DateTime<chrono::Utc>),
    Timezone(String),
    DateCreated(chrono::DateTime<chrono::Utc>),
    LinkJobs(Vec<JobWhereParam>),
    UnlinkJobs(Vec<JobWhereParam>),
}
impl ClientSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Uuid(value) => Field {
                name: "uuid".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Name(value) => Field {
                name: "name".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Platform(value) => Field {
                name: "platform".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Version(value) => Field {
                name: "version".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Online(value) => Field {
                name: "online".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LastSeen(value) => Field {
                name: "last_seen".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Timezone(value) => Field {
                name: "timezone".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateCreated(value) => Field {
                name: "date_created".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkJobs(where_params) => Field {
                name: "jobs".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UnlinkJobs(where_params) => Field {
                name: "jobs".into(),
                fields: Some(vec![Field {
                    name: "disconnect".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub struct ClientFindMany<'a> {
    query: Query<'a>,
}
impl<'a> ClientFindMany<'a> {
    pub async fn exec(self) -> Vec<ClientData> {
        self.query.perform::<Vec<ClientData>>().await.unwrap()
    }
    pub fn delete(self) -> ClientDelete<'a> {
        ClientDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "Client".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<ClientSetParam>) -> ClientUpdateMany<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        ClientUpdateMany {
            query: Query {
                operation: "mutation".into(),
                method: "updateMany".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<ClientWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct ClientFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> ClientFindFirst<'a> {
    pub async fn exec(self) -> Option<ClientData> {
        self.query.perform::<Option<ClientData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<ClientWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct ClientFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> ClientFindUnique<'a> {
    pub async fn exec(self) -> Option<ClientData> {
        self.query.perform::<Option<ClientData>>().await.unwrap()
    }
    pub fn delete(self) -> ClientDelete<'a> {
        ClientDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "Client".into(),
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<ClientSetParam>) -> ClientUpdateUnique<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        ClientUpdateUnique {
            query: Query {
                operation: "mutation".into(),
                method: "updateOne".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<ClientWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct ClientCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> ClientCreateOne<'a> {
    pub async fn exec(self) -> ClientData {
        self.query.perform::<ClientData>().await.unwrap()
    }
}
pub struct ClientUpdateUnique<'a> {
    query: Query<'a>,
}
impl<'a> ClientUpdateUnique<'a> {
    pub async fn exec(self) -> ClientData {
        self.query.perform::<ClientData>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<ClientWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct ClientUpdateMany<'a> {
    query: Query<'a>,
}
impl<'a> ClientUpdateMany<'a> {
    pub async fn exec(self) -> Vec<ClientData> {
        self.query.perform::<Vec<ClientData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<ClientWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct ClientDelete<'a> {
    query: Query<'a>,
}
impl<'a> ClientDelete<'a> {
    pub async fn exec(self) -> isize {
        self.query.perform::<DeleteResult>().await.unwrap().count
    }
}
pub struct ClientActions<'a> {
    client: &'a PrismaClient,
}
impl<'a> ClientActions<'a> {
    pub fn find_unique(&self, param: ClientWhereParam) -> ClientFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "Client".into(),
            outputs: client_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        ClientFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<ClientWhereParam>) -> ClientFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "Client".into(),
            outputs: client_outputs(),
            inputs,
        };
        ClientFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<ClientWhereParam>) -> ClientFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "Client".into(),
            outputs: client_outputs(),
            inputs,
        };
        ClientFindMany { query }
    }
    pub fn create_one(
        &self,
        uuid: ClientSetUuid,
        name: ClientSetName,
        params: Vec<ClientSetParam>,
    ) -> ClientCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(ClientSetParam::from(uuid).field());
        input_fields.push(ClientSetParam::from(name).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "Client".into(),
            outputs: client_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        ClientCreateOne { query }
    }
}
fn location_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("name"),
        Output::new("path"),
        Output::new("total_capacity"),
        Output::new("available_capacity"),
        Output::new("is_removable"),
        Output::new("is_ejectable"),
        Output::new("is_root_filesystem"),
        Output::new("is_online"),
        Output::new("date_created"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocationData {
    #[serde(rename = "id")]
    pub id: i64,
    #[serde(rename = "name")]
    pub name: Option<String>,
    #[serde(rename = "path")]
    pub path: Option<String>,
    #[serde(rename = "total_capacity")]
    pub total_capacity: Option<i64>,
    #[serde(rename = "available_capacity")]
    pub available_capacity: Option<i64>,
    #[serde(rename = "is_removable")]
    pub is_removable: bool,
    #[serde(rename = "is_ejectable")]
    pub is_ejectable: bool,
    #[serde(rename = "is_root_filesystem")]
    pub is_root_filesystem: bool,
    #[serde(rename = "is_online")]
    pub is_online: bool,
    #[serde(rename = "date_created")]
    pub date_created: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "files")]
    files: Option<Vec<FileData>>,
}
impl LocationData {
    pub fn files(&self) -> Result<&Vec<FileData>, String> {
        match self.files.as_ref() {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access files but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct Location;
impl Location {
    pub fn id() -> LocationIdField {
        LocationIdField {}
    }
    pub fn name() -> LocationNameField {
        LocationNameField {}
    }
    pub fn path() -> LocationPathField {
        LocationPathField {}
    }
    pub fn total_capacity() -> LocationTotalCapacityField {
        LocationTotalCapacityField {}
    }
    pub fn available_capacity() -> LocationAvailableCapacityField {
        LocationAvailableCapacityField {}
    }
    pub fn is_removable() -> LocationIsRemovableField {
        LocationIsRemovableField {}
    }
    pub fn is_ejectable() -> LocationIsEjectableField {
        LocationIsEjectableField {}
    }
    pub fn is_root_filesystem() -> LocationIsRootFilesystemField {
        LocationIsRootFilesystemField {}
    }
    pub fn is_online() -> LocationIsOnlineField {
        LocationIsOnlineField {}
    }
    pub fn date_created() -> LocationDateCreatedField {
        LocationDateCreatedField {}
    }
    pub fn files() -> LocationFilesField {
        LocationFilesField {}
    }
    pub fn not(params: Vec<LocationWhereParam>) -> LocationWhereParam {
        LocationWhereParam::Not(params)
    }
    pub fn or(params: Vec<LocationWhereParam>) -> LocationWhereParam {
        LocationWhereParam::Or(params)
    }
    pub fn and(params: Vec<LocationWhereParam>) -> LocationWhereParam {
        LocationWhereParam::And(params)
    }
}
pub struct LocationIdField {}
pub struct LocationSetId(i64);
impl From<LocationSetId> for LocationSetParam {
    fn from(value: LocationSetId) -> Self {
        Self::Id(value.0)
    }
}
impl LocationIdField {
    pub fn lt(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::IdLT(value)
    }
    pub fn gt(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::IdGT(value)
    }
    pub fn lte(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::IdLTE(value)
    }
    pub fn gte(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::IdGTE(value)
    }
    pub fn equals(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::IdEquals(value)
    }
    pub fn set<T: From<LocationSetId>>(&self, value: i64) -> T {
        LocationSetId(value).into()
    }
}
pub struct LocationNameField {}
pub struct LocationSetName(String);
impl From<LocationSetName> for LocationSetParam {
    fn from(value: LocationSetName) -> Self {
        Self::Name(value.0)
    }
}
impl LocationNameField {
    pub fn contains(&self, value: String) -> LocationWhereParam {
        LocationWhereParam::NameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> LocationWhereParam {
        LocationWhereParam::NameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> LocationWhereParam {
        LocationWhereParam::NameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> LocationWhereParam {
        LocationWhereParam::NameEquals(value)
    }
    pub fn set<T: From<LocationSetName>>(&self, value: String) -> T {
        LocationSetName(value).into()
    }
}
pub struct LocationPathField {}
pub struct LocationSetPath(String);
impl From<LocationSetPath> for LocationSetParam {
    fn from(value: LocationSetPath) -> Self {
        Self::Path(value.0)
    }
}
impl LocationPathField {
    pub fn contains(&self, value: String) -> LocationWhereParam {
        LocationWhereParam::PathContains(value)
    }
    pub fn has_prefix(&self, value: String) -> LocationWhereParam {
        LocationWhereParam::PathHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> LocationWhereParam {
        LocationWhereParam::PathHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> LocationWhereParam {
        LocationWhereParam::PathEquals(value)
    }
    pub fn set<T: From<LocationSetPath>>(&self, value: String) -> T {
        LocationSetPath(value).into()
    }
}
pub struct LocationTotalCapacityField {}
pub struct LocationSetTotalCapacity(i64);
impl From<LocationSetTotalCapacity> for LocationSetParam {
    fn from(value: LocationSetTotalCapacity) -> Self {
        Self::TotalCapacity(value.0)
    }
}
impl LocationTotalCapacityField {
    pub fn lt(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::TotalCapacityLT(value)
    }
    pub fn gt(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::TotalCapacityGT(value)
    }
    pub fn lte(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::TotalCapacityLTE(value)
    }
    pub fn gte(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::TotalCapacityGTE(value)
    }
    pub fn equals(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::TotalCapacityEquals(value)
    }
    pub fn set<T: From<LocationSetTotalCapacity>>(&self, value: i64) -> T {
        LocationSetTotalCapacity(value).into()
    }
}
pub struct LocationAvailableCapacityField {}
pub struct LocationSetAvailableCapacity(i64);
impl From<LocationSetAvailableCapacity> for LocationSetParam {
    fn from(value: LocationSetAvailableCapacity) -> Self {
        Self::AvailableCapacity(value.0)
    }
}
impl LocationAvailableCapacityField {
    pub fn lt(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::AvailableCapacityLT(value)
    }
    pub fn gt(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::AvailableCapacityGT(value)
    }
    pub fn lte(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::AvailableCapacityLTE(value)
    }
    pub fn gte(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::AvailableCapacityGTE(value)
    }
    pub fn equals(&self, value: i64) -> LocationWhereParam {
        LocationWhereParam::AvailableCapacityEquals(value)
    }
    pub fn set<T: From<LocationSetAvailableCapacity>>(&self, value: i64) -> T {
        LocationSetAvailableCapacity(value).into()
    }
}
pub struct LocationIsRemovableField {}
pub struct LocationSetIsRemovable(bool);
impl From<LocationSetIsRemovable> for LocationSetParam {
    fn from(value: LocationSetIsRemovable) -> Self {
        Self::IsRemovable(value.0)
    }
}
impl LocationIsRemovableField {
    pub fn equals(&self, value: bool) -> LocationWhereParam {
        LocationWhereParam::IsRemovableEquals(value)
    }
    pub fn set<T: From<LocationSetIsRemovable>>(&self, value: bool) -> T {
        LocationSetIsRemovable(value).into()
    }
}
pub struct LocationIsEjectableField {}
pub struct LocationSetIsEjectable(bool);
impl From<LocationSetIsEjectable> for LocationSetParam {
    fn from(value: LocationSetIsEjectable) -> Self {
        Self::IsEjectable(value.0)
    }
}
impl LocationIsEjectableField {
    pub fn equals(&self, value: bool) -> LocationWhereParam {
        LocationWhereParam::IsEjectableEquals(value)
    }
    pub fn set<T: From<LocationSetIsEjectable>>(&self, value: bool) -> T {
        LocationSetIsEjectable(value).into()
    }
}
pub struct LocationIsRootFilesystemField {}
pub struct LocationSetIsRootFilesystem(bool);
impl From<LocationSetIsRootFilesystem> for LocationSetParam {
    fn from(value: LocationSetIsRootFilesystem) -> Self {
        Self::IsRootFilesystem(value.0)
    }
}
impl LocationIsRootFilesystemField {
    pub fn equals(&self, value: bool) -> LocationWhereParam {
        LocationWhereParam::IsRootFilesystemEquals(value)
    }
    pub fn set<T: From<LocationSetIsRootFilesystem>>(&self, value: bool) -> T {
        LocationSetIsRootFilesystem(value).into()
    }
}
pub struct LocationIsOnlineField {}
pub struct LocationSetIsOnline(bool);
impl From<LocationSetIsOnline> for LocationSetParam {
    fn from(value: LocationSetIsOnline) -> Self {
        Self::IsOnline(value.0)
    }
}
impl LocationIsOnlineField {
    pub fn equals(&self, value: bool) -> LocationWhereParam {
        LocationWhereParam::IsOnlineEquals(value)
    }
    pub fn set<T: From<LocationSetIsOnline>>(&self, value: bool) -> T {
        LocationSetIsOnline(value).into()
    }
}
pub struct LocationDateCreatedField {}
pub struct LocationSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<LocationSetDateCreated> for LocationSetParam {
    fn from(value: LocationSetDateCreated) -> Self {
        Self::DateCreated(value.0)
    }
}
impl LocationDateCreatedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
        LocationWhereParam::DateCreatedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
        LocationWhereParam::DateCreatedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
        LocationWhereParam::DateCreatedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
        LocationWhereParam::DateCreatedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
        LocationWhereParam::DateCreatedEquals(value)
    }
    pub fn set<T: From<LocationSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        LocationSetDateCreated(value).into()
    }
}
pub struct LocationFilesField {}
pub struct LocationLinkFiles(Vec<FileWhereParam>);
impl From<LocationLinkFiles> for LocationSetParam {
    fn from(value: LocationLinkFiles) -> Self {
        Self::LinkFiles(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl LocationFilesField {
    pub fn some(&self, value: Vec<FileWhereParam>) -> LocationWhereParam {
        LocationWhereParam::FilesSome(value)
    }
    pub fn every(&self, value: Vec<FileWhereParam>) -> LocationWhereParam {
        LocationWhereParam::FilesEvery(value)
    }
    pub fn link<T: From<LocationLinkFiles>>(&self, value: Vec<FileWhereParam>) -> T {
        LocationLinkFiles(value).into()
    }
    pub fn unlink(&self, params: Vec<FileWhereParam>) -> LocationSetParam {
        LocationSetParam::UnlinkFiles(params)
    }
    pub fn fetch(&self, params: Vec<FileWhereParam>) -> LocationWith {
        LocationWithParam::Files(params).into()
    }
}
pub enum LocationWhereParam {
    IdLT(i64),
    IdGT(i64),
    IdLTE(i64),
    IdGTE(i64),
    IdEquals(i64),
    NameContains(String),
    NameHasPrefix(String),
    NameHasSuffix(String),
    NameEquals(String),
    PathContains(String),
    PathHasPrefix(String),
    PathHasSuffix(String),
    PathEquals(String),
    TotalCapacityLT(i64),
    TotalCapacityGT(i64),
    TotalCapacityLTE(i64),
    TotalCapacityGTE(i64),
    TotalCapacityEquals(i64),
    AvailableCapacityLT(i64),
    AvailableCapacityGT(i64),
    AvailableCapacityLTE(i64),
    AvailableCapacityGTE(i64),
    AvailableCapacityEquals(i64),
    IsRemovableEquals(bool),
    IsEjectableEquals(bool),
    IsRootFilesystemEquals(bool),
    IsOnlineEquals(bool),
    DateCreatedBefore(chrono::DateTime<chrono::Utc>),
    DateCreatedAfter(chrono::DateTime<chrono::Utc>),
    DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedEquals(chrono::DateTime<chrono::Utc>),
    FilesSome(Vec<FileWhereParam>),
    FilesEvery(Vec<FileWhereParam>),
    Not(Vec<LocationWhereParam>),
    Or(Vec<LocationWhereParam>),
    And(Vec<LocationWhereParam>),
}
impl LocationWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdLT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdLTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameContains(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasPrefix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasSuffix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameEquals(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PathContains(value) => Field {
                name: "path".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PathHasPrefix(value) => Field {
                name: "path".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PathHasSuffix(value) => Field {
                name: "path".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PathEquals(value) => Field {
                name: "path".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalCapacityLT(value) => Field {
                name: "total_capacity".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalCapacityGT(value) => Field {
                name: "total_capacity".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalCapacityLTE(value) => Field {
                name: "total_capacity".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalCapacityGTE(value) => Field {
                name: "total_capacity".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalCapacityEquals(value) => Field {
                name: "total_capacity".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AvailableCapacityLT(value) => Field {
                name: "available_capacity".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AvailableCapacityGT(value) => Field {
                name: "available_capacity".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AvailableCapacityLTE(value) => Field {
                name: "available_capacity".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AvailableCapacityGTE(value) => Field {
                name: "available_capacity".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AvailableCapacityEquals(value) => Field {
                name: "available_capacity".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IsRemovableEquals(value) => Field {
                name: "is_removable".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IsEjectableEquals(value) => Field {
                name: "is_ejectable".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IsRootFilesystemEquals(value) => Field {
                name: "is_root_filesystem".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IsOnlineEquals(value) => Field {
                name: "is_online".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBefore(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfter(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBeforeEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfterEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FilesSome(value) => Field {
                name: "files".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FilesEvery(value) => Field {
                name: "files".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct LocationWith {
    pub param: LocationWithParam,
}
pub enum LocationWithParam {
    Files(Vec<FileWhereParam>),
}
impl From<LocationWithParam> for LocationWith {
    fn from(param: LocationWithParam) -> Self {
        Self { param }
    }
}
impl LocationWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Files(where_params) => Output {
                name: "files".into(),
                outputs: file_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
        }
    }
}
pub enum LocationSetParam {
    Id(i64),
    Name(String),
    Path(String),
    TotalCapacity(i64),
    AvailableCapacity(i64),
    IsRemovable(bool),
    IsEjectable(bool),
    IsRootFilesystem(bool),
    IsOnline(bool),
    DateCreated(chrono::DateTime<chrono::Utc>),
    LinkFiles(Vec<FileWhereParam>),
    UnlinkFiles(Vec<FileWhereParam>),
}
impl LocationSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Name(value) => Field {
                name: "name".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Path(value) => Field {
                name: "path".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::TotalCapacity(value) => Field {
                name: "total_capacity".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::AvailableCapacity(value) => Field {
                name: "available_capacity".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::IsRemovable(value) => Field {
                name: "is_removable".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::IsEjectable(value) => Field {
                name: "is_ejectable".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::IsRootFilesystem(value) => Field {
                name: "is_root_filesystem".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::IsOnline(value) => Field {
                name: "is_online".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateCreated(value) => Field {
                name: "date_created".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkFiles(where_params) => Field {
                name: "files".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UnlinkFiles(where_params) => Field {
                name: "files".into(),
                fields: Some(vec![Field {
                    name: "disconnect".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub struct LocationFindMany<'a> {
    query: Query<'a>,
}
impl<'a> LocationFindMany<'a> {
    pub async fn exec(self) -> Vec<LocationData> {
        self.query.perform::<Vec<LocationData>>().await.unwrap()
    }
    pub fn delete(self) -> LocationDelete<'a> {
        LocationDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "Location".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<LocationSetParam>) -> LocationUpdateMany<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        LocationUpdateMany {
            query: Query {
                operation: "mutation".into(),
                method: "updateMany".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<LocationWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct LocationFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> LocationFindFirst<'a> {
    pub async fn exec(self) -> Option<LocationData> {
        self.query.perform::<Option<LocationData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<LocationWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct LocationFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> LocationFindUnique<'a> {
    pub async fn exec(self) -> Option<LocationData> {
        self.query.perform::<Option<LocationData>>().await.unwrap()
    }
    pub fn delete(self) -> LocationDelete<'a> {
        LocationDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "Location".into(),
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<LocationSetParam>) -> LocationUpdateUnique<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        LocationUpdateUnique {
            query: Query {
                operation: "mutation".into(),
                method: "updateOne".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<LocationWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct LocationCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> LocationCreateOne<'a> {
    pub async fn exec(self) -> LocationData {
        self.query.perform::<LocationData>().await.unwrap()
    }
}
pub struct LocationUpdateUnique<'a> {
    query: Query<'a>,
}
impl<'a> LocationUpdateUnique<'a> {
    pub async fn exec(self) -> LocationData {
        self.query.perform::<LocationData>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<LocationWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct LocationUpdateMany<'a> {
    query: Query<'a>,
}
impl<'a> LocationUpdateMany<'a> {
    pub async fn exec(self) -> Vec<LocationData> {
        self.query.perform::<Vec<LocationData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<LocationWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct LocationDelete<'a> {
    query: Query<'a>,
}
impl<'a> LocationDelete<'a> {
    pub async fn exec(self) -> isize {
        self.query.perform::<DeleteResult>().await.unwrap().count
    }
}
pub struct LocationActions<'a> {
    client: &'a PrismaClient,
}
impl<'a> LocationActions<'a> {
    pub fn find_unique(&self, param: LocationWhereParam) -> LocationFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "Location".into(),
            outputs: location_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        LocationFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<LocationWhereParam>) -> LocationFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "Location".into(),
            outputs: location_outputs(),
            inputs,
        };
        LocationFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<LocationWhereParam>) -> LocationFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "Location".into(),
            outputs: location_outputs(),
            inputs,
        };
        LocationFindMany { query }
    }
    pub fn create_one(&self, params: Vec<LocationSetParam>) -> LocationCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "Location".into(),
            outputs: location_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        LocationCreateOne { query }
    }
}
fn file_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("is_dir"),
        Output::new("location_id"),
        Output::new("stem"),
        Output::new("name"),
        Output::new("extension"),
        Output::new("path_checksum"),
        Output::new("quick_checksum"),
        Output::new("full_checksum"),
        Output::new("size_in_bytes"),
        Output::new("encryption"),
        Output::new("date_created"),
        Output::new("date_modified"),
        Output::new("date_indexed"),
        Output::new("ipfs_id"),
        Output::new("parent_id"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileData {
    #[serde(rename = "id")]
    pub id: i64,
    #[serde(rename = "is_dir")]
    pub is_dir: bool,
    #[serde(rename = "location_id")]
    pub location_id: i64,
    #[serde(rename = "stem")]
    pub stem: String,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "extension")]
    pub extension: Option<String>,
    #[serde(rename = "path_checksum")]
    pub path_checksum: String,
    #[serde(rename = "quick_checksum")]
    pub quick_checksum: Option<String>,
    #[serde(rename = "full_checksum")]
    pub full_checksum: Option<String>,
    #[serde(rename = "size_in_bytes")]
    pub size_in_bytes: String,
    #[serde(rename = "encryption")]
    pub encryption: i64,
    #[serde(rename = "date_created")]
    pub date_created: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "date_modified")]
    pub date_modified: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "date_indexed")]
    pub date_indexed: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "ipfs_id")]
    pub ipfs_id: Option<String>,
    #[serde(rename = "location")]
    pub location: Box<Option<LocationData>>,
    #[serde(rename = "parent")]
    pub parent: Box<Option<FileData>>,
    #[serde(rename = "parent_id")]
    pub parent_id: Option<i64>,
    #[serde(rename = "children")]
    children: Option<Vec<FileData>>,
    #[serde(rename = "file_tags")]
    file_tags: Option<Vec<TagOnFileData>>,
}
impl FileData {
    pub fn location(&self) -> Option<&LocationData> {
        self.location.as_ref().as_ref()
    }
    pub fn parent(&self) -> Option<&FileData> {
        self.parent.as_ref().as_ref()
    }
    pub fn children(&self) -> Result<&Vec<FileData>, String> {
        match self.children.as_ref() {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access children but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
    pub fn file_tags(&self) -> Result<&Vec<TagOnFileData>, String> {
        match self.file_tags.as_ref() {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access file_tags but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct File;
impl File {
    pub fn id() -> FileIdField {
        FileIdField {}
    }
    pub fn is_dir() -> FileIsDirField {
        FileIsDirField {}
    }
    pub fn location_id() -> FileLocationIdField {
        FileLocationIdField {}
    }
    pub fn stem() -> FileStemField {
        FileStemField {}
    }
    pub fn name() -> FileNameField {
        FileNameField {}
    }
    pub fn extension() -> FileExtensionField {
        FileExtensionField {}
    }
    pub fn path_checksum() -> FilePathChecksumField {
        FilePathChecksumField {}
    }
    pub fn quick_checksum() -> FileQuickChecksumField {
        FileQuickChecksumField {}
    }
    pub fn full_checksum() -> FileFullChecksumField {
        FileFullChecksumField {}
    }
    pub fn size_in_bytes() -> FileSizeInBytesField {
        FileSizeInBytesField {}
    }
    pub fn encryption() -> FileEncryptionField {
        FileEncryptionField {}
    }
    pub fn date_created() -> FileDateCreatedField {
        FileDateCreatedField {}
    }
    pub fn date_modified() -> FileDateModifiedField {
        FileDateModifiedField {}
    }
    pub fn date_indexed() -> FileDateIndexedField {
        FileDateIndexedField {}
    }
    pub fn ipfs_id() -> FileIpfsIdField {
        FileIpfsIdField {}
    }
    pub fn location() -> FileLocationField {
        FileLocationField {}
    }
    pub fn parent() -> FileParentField {
        FileParentField {}
    }
    pub fn parent_id() -> FileParentIdField {
        FileParentIdField {}
    }
    pub fn children() -> FileChildrenField {
        FileChildrenField {}
    }
    pub fn file_tags() -> FileFileTagsField {
        FileFileTagsField {}
    }
    pub fn not(params: Vec<FileWhereParam>) -> FileWhereParam {
        FileWhereParam::Not(params)
    }
    pub fn or(params: Vec<FileWhereParam>) -> FileWhereParam {
        FileWhereParam::Or(params)
    }
    pub fn and(params: Vec<FileWhereParam>) -> FileWhereParam {
        FileWhereParam::And(params)
    }
}
pub struct FileIdField {}
pub struct FileSetId(i64);
impl From<FileSetId> for FileSetParam {
    fn from(value: FileSetId) -> Self {
        Self::Id(value.0)
    }
}
impl FileIdField {
    pub fn lt(&self, value: i64) -> FileWhereParam {
        FileWhereParam::IdLT(value)
    }
    pub fn gt(&self, value: i64) -> FileWhereParam {
        FileWhereParam::IdGT(value)
    }
    pub fn lte(&self, value: i64) -> FileWhereParam {
        FileWhereParam::IdLTE(value)
    }
    pub fn gte(&self, value: i64) -> FileWhereParam {
        FileWhereParam::IdGTE(value)
    }
    pub fn equals(&self, value: i64) -> FileWhereParam {
        FileWhereParam::IdEquals(value)
    }
    pub fn set<T: From<FileSetId>>(&self, value: i64) -> T {
        FileSetId(value).into()
    }
}
pub struct FileIsDirField {}
pub struct FileSetIsDir(bool);
impl From<FileSetIsDir> for FileSetParam {
    fn from(value: FileSetIsDir) -> Self {
        Self::IsDir(value.0)
    }
}
impl FileIsDirField {
    pub fn equals(&self, value: bool) -> FileWhereParam {
        FileWhereParam::IsDirEquals(value)
    }
    pub fn set<T: From<FileSetIsDir>>(&self, value: bool) -> T {
        FileSetIsDir(value).into()
    }
}
pub struct FileLocationIdField {}
pub struct FileSetLocationId(i64);
impl From<FileSetLocationId> for FileSetParam {
    fn from(value: FileSetLocationId) -> Self {
        Self::LocationId(value.0)
    }
}
impl FileLocationIdField {
    pub fn lt(&self, value: i64) -> FileWhereParam {
        FileWhereParam::LocationIdLT(value)
    }
    pub fn gt(&self, value: i64) -> FileWhereParam {
        FileWhereParam::LocationIdGT(value)
    }
    pub fn lte(&self, value: i64) -> FileWhereParam {
        FileWhereParam::LocationIdLTE(value)
    }
    pub fn gte(&self, value: i64) -> FileWhereParam {
        FileWhereParam::LocationIdGTE(value)
    }
    pub fn equals(&self, value: i64) -> FileWhereParam {
        FileWhereParam::LocationIdEquals(value)
    }
    pub fn set<T: From<FileSetLocationId>>(&self, value: i64) -> T {
        FileSetLocationId(value).into()
    }
}
pub struct FileStemField {}
pub struct FileSetStem(String);
impl From<FileSetStem> for FileSetParam {
    fn from(value: FileSetStem) -> Self {
        Self::Stem(value.0)
    }
}
impl FileStemField {
    pub fn contains(&self, value: String) -> FileWhereParam {
        FileWhereParam::StemContains(value)
    }
    pub fn has_prefix(&self, value: String) -> FileWhereParam {
        FileWhereParam::StemHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> FileWhereParam {
        FileWhereParam::StemHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> FileWhereParam {
        FileWhereParam::StemEquals(value)
    }
    pub fn set<T: From<FileSetStem>>(&self, value: String) -> T {
        FileSetStem(value).into()
    }
}
pub struct FileNameField {}
pub struct FileSetName(String);
impl From<FileSetName> for FileSetParam {
    fn from(value: FileSetName) -> Self {
        Self::Name(value.0)
    }
}
impl FileNameField {
    pub fn contains(&self, value: String) -> FileWhereParam {
        FileWhereParam::NameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> FileWhereParam {
        FileWhereParam::NameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> FileWhereParam {
        FileWhereParam::NameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> FileWhereParam {
        FileWhereParam::NameEquals(value)
    }
    pub fn set<T: From<FileSetName>>(&self, value: String) -> T {
        FileSetName(value).into()
    }
}
pub struct FileExtensionField {}
pub struct FileSetExtension(String);
impl From<FileSetExtension> for FileSetParam {
    fn from(value: FileSetExtension) -> Self {
        Self::Extension(value.0)
    }
}
impl FileExtensionField {
    pub fn contains(&self, value: String) -> FileWhereParam {
        FileWhereParam::ExtensionContains(value)
    }
    pub fn has_prefix(&self, value: String) -> FileWhereParam {
        FileWhereParam::ExtensionHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> FileWhereParam {
        FileWhereParam::ExtensionHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> FileWhereParam {
        FileWhereParam::ExtensionEquals(value)
    }
    pub fn set<T: From<FileSetExtension>>(&self, value: String) -> T {
        FileSetExtension(value).into()
    }
}
pub struct FilePathChecksumField {}
pub struct FileSetPathChecksum(String);
impl From<FileSetPathChecksum> for FileSetParam {
    fn from(value: FileSetPathChecksum) -> Self {
        Self::PathChecksum(value.0)
    }
}
impl FilePathChecksumField {
    pub fn contains(&self, value: String) -> FileWhereParam {
        FileWhereParam::PathChecksumContains(value)
    }
    pub fn has_prefix(&self, value: String) -> FileWhereParam {
        FileWhereParam::PathChecksumHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> FileWhereParam {
        FileWhereParam::PathChecksumHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> FileWhereParam {
        FileWhereParam::PathChecksumEquals(value)
    }
    pub fn set<T: From<FileSetPathChecksum>>(&self, value: String) -> T {
        FileSetPathChecksum(value).into()
    }
}
pub struct FileQuickChecksumField {}
pub struct FileSetQuickChecksum(String);
impl From<FileSetQuickChecksum> for FileSetParam {
    fn from(value: FileSetQuickChecksum) -> Self {
        Self::QuickChecksum(value.0)
    }
}
impl FileQuickChecksumField {
    pub fn contains(&self, value: String) -> FileWhereParam {
        FileWhereParam::QuickChecksumContains(value)
    }
    pub fn has_prefix(&self, value: String) -> FileWhereParam {
        FileWhereParam::QuickChecksumHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> FileWhereParam {
        FileWhereParam::QuickChecksumHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> FileWhereParam {
        FileWhereParam::QuickChecksumEquals(value)
    }
    pub fn set<T: From<FileSetQuickChecksum>>(&self, value: String) -> T {
        FileSetQuickChecksum(value).into()
    }
}
pub struct FileFullChecksumField {}
pub struct FileSetFullChecksum(String);
impl From<FileSetFullChecksum> for FileSetParam {
    fn from(value: FileSetFullChecksum) -> Self {
        Self::FullChecksum(value.0)
    }
}
impl FileFullChecksumField {
    pub fn contains(&self, value: String) -> FileWhereParam {
        FileWhereParam::FullChecksumContains(value)
    }
    pub fn has_prefix(&self, value: String) -> FileWhereParam {
        FileWhereParam::FullChecksumHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> FileWhereParam {
        FileWhereParam::FullChecksumHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> FileWhereParam {
        FileWhereParam::FullChecksumEquals(value)
    }
    pub fn set<T: From<FileSetFullChecksum>>(&self, value: String) -> T {
        FileSetFullChecksum(value).into()
    }
}
pub struct FileSizeInBytesField {}
pub struct FileSetSizeInBytes(String);
impl From<FileSetSizeInBytes> for FileSetParam {
    fn from(value: FileSetSizeInBytes) -> Self {
        Self::SizeInBytes(value.0)
    }
}
impl FileSizeInBytesField {
    pub fn contains(&self, value: String) -> FileWhereParam {
        FileWhereParam::SizeInBytesContains(value)
    }
    pub fn has_prefix(&self, value: String) -> FileWhereParam {
        FileWhereParam::SizeInBytesHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> FileWhereParam {
        FileWhereParam::SizeInBytesHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> FileWhereParam {
        FileWhereParam::SizeInBytesEquals(value)
    }
    pub fn set<T: From<FileSetSizeInBytes>>(&self, value: String) -> T {
        FileSetSizeInBytes(value).into()
    }
}
pub struct FileEncryptionField {}
pub struct FileSetEncryption(i64);
impl From<FileSetEncryption> for FileSetParam {
    fn from(value: FileSetEncryption) -> Self {
        Self::Encryption(value.0)
    }
}
impl FileEncryptionField {
    pub fn lt(&self, value: i64) -> FileWhereParam {
        FileWhereParam::EncryptionLT(value)
    }
    pub fn gt(&self, value: i64) -> FileWhereParam {
        FileWhereParam::EncryptionGT(value)
    }
    pub fn lte(&self, value: i64) -> FileWhereParam {
        FileWhereParam::EncryptionLTE(value)
    }
    pub fn gte(&self, value: i64) -> FileWhereParam {
        FileWhereParam::EncryptionGTE(value)
    }
    pub fn equals(&self, value: i64) -> FileWhereParam {
        FileWhereParam::EncryptionEquals(value)
    }
    pub fn set<T: From<FileSetEncryption>>(&self, value: i64) -> T {
        FileSetEncryption(value).into()
    }
}
pub struct FileDateCreatedField {}
pub struct FileSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<FileSetDateCreated> for FileSetParam {
    fn from(value: FileSetDateCreated) -> Self {
        Self::DateCreated(value.0)
    }
}
impl FileDateCreatedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateCreatedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateCreatedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateCreatedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateCreatedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateCreatedEquals(value)
    }
    pub fn set<T: From<FileSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        FileSetDateCreated(value).into()
    }
}
pub struct FileDateModifiedField {}
pub struct FileSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<FileSetDateModified> for FileSetParam {
    fn from(value: FileSetDateModified) -> Self {
        Self::DateModified(value.0)
    }
}
impl FileDateModifiedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateModifiedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateModifiedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateModifiedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateModifiedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateModifiedEquals(value)
    }
    pub fn set<T: From<FileSetDateModified>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        FileSetDateModified(value).into()
    }
}
pub struct FileDateIndexedField {}
pub struct FileSetDateIndexed(chrono::DateTime<chrono::Utc>);
impl From<FileSetDateIndexed> for FileSetParam {
    fn from(value: FileSetDateIndexed) -> Self {
        Self::DateIndexed(value.0)
    }
}
impl FileDateIndexedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateIndexedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateIndexedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateIndexedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateIndexedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
        FileWhereParam::DateIndexedEquals(value)
    }
    pub fn set<T: From<FileSetDateIndexed>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        FileSetDateIndexed(value).into()
    }
}
pub struct FileIpfsIdField {}
pub struct FileSetIpfsId(String);
impl From<FileSetIpfsId> for FileSetParam {
    fn from(value: FileSetIpfsId) -> Self {
        Self::IpfsId(value.0)
    }
}
impl FileIpfsIdField {
    pub fn contains(&self, value: String) -> FileWhereParam {
        FileWhereParam::IpfsIdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> FileWhereParam {
        FileWhereParam::IpfsIdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> FileWhereParam {
        FileWhereParam::IpfsIdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> FileWhereParam {
        FileWhereParam::IpfsIdEquals(value)
    }
    pub fn set<T: From<FileSetIpfsId>>(&self, value: String) -> T {
        FileSetIpfsId(value).into()
    }
}
pub struct FileLocationField {}
pub struct FileLinkLocation(LocationWhereParam);
impl From<FileLinkLocation> for FileSetParam {
    fn from(value: FileLinkLocation) -> Self {
        Self::LinkLocation(value.0)
    }
}
impl FileLocationField {
    pub fn is(&self, value: Vec<LocationWhereParam>) -> FileWhereParam {
        FileWhereParam::LocationIs(value)
    }
    pub fn link<T: From<FileLinkLocation>>(&self, value: LocationWhereParam) -> T {
        FileLinkLocation(value).into()
    }
    pub fn fetch(&self) -> FileWith {
        FileWithParam::Location.into()
    }
    pub fn unlink(&self) -> FileSetParam {
        FileSetParam::UnlinkLocation
    }
}
pub struct FileParentField {}
pub struct FileLinkParent(FileWhereParam);
impl From<FileLinkParent> for FileSetParam {
    fn from(value: FileLinkParent) -> Self {
        Self::LinkParent(value.0)
    }
}
impl FileParentField {
    pub fn is(&self, value: Vec<FileWhereParam>) -> FileWhereParam {
        FileWhereParam::ParentIs(value)
    }
    pub fn link<T: From<FileLinkParent>>(&self, value: FileWhereParam) -> T {
        FileLinkParent(value).into()
    }
    pub fn fetch(&self) -> FileWith {
        FileWithParam::Parent.into()
    }
    pub fn unlink(&self) -> FileSetParam {
        FileSetParam::UnlinkParent
    }
}
pub struct FileParentIdField {}
pub struct FileSetParentId(i64);
impl From<FileSetParentId> for FileSetParam {
    fn from(value: FileSetParentId) -> Self {
        Self::ParentId(value.0)
    }
}
impl FileParentIdField {
    pub fn lt(&self, value: i64) -> FileWhereParam {
        FileWhereParam::ParentIdLT(value)
    }
    pub fn gt(&self, value: i64) -> FileWhereParam {
        FileWhereParam::ParentIdGT(value)
    }
    pub fn lte(&self, value: i64) -> FileWhereParam {
        FileWhereParam::ParentIdLTE(value)
    }
    pub fn gte(&self, value: i64) -> FileWhereParam {
        FileWhereParam::ParentIdGTE(value)
    }
    pub fn equals(&self, value: i64) -> FileWhereParam {
        FileWhereParam::ParentIdEquals(value)
    }
    pub fn set<T: From<FileSetParentId>>(&self, value: i64) -> T {
        FileSetParentId(value).into()
    }
}
pub struct FileChildrenField {}
pub struct FileLinkChildren(Vec<FileWhereParam>);
impl From<FileLinkChildren> for FileSetParam {
    fn from(value: FileLinkChildren) -> Self {
        Self::LinkChildren(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl FileChildrenField {
    pub fn some(&self, value: Vec<FileWhereParam>) -> FileWhereParam {
        FileWhereParam::ChildrenSome(value)
    }
    pub fn every(&self, value: Vec<FileWhereParam>) -> FileWhereParam {
        FileWhereParam::ChildrenEvery(value)
    }
    pub fn link<T: From<FileLinkChildren>>(&self, value: Vec<FileWhereParam>) -> T {
        FileLinkChildren(value).into()
    }
    pub fn unlink(&self, params: Vec<FileWhereParam>) -> FileSetParam {
        FileSetParam::UnlinkChildren(params)
    }
    pub fn fetch(&self, params: Vec<FileWhereParam>) -> FileWith {
        FileWithParam::Children(params).into()
    }
}
pub struct FileFileTagsField {}
pub struct FileLinkFileTags(Vec<TagOnFileWhereParam>);
impl From<FileLinkFileTags> for FileSetParam {
    fn from(value: FileLinkFileTags) -> Self {
        Self::LinkFileTags(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl FileFileTagsField {
    pub fn some(&self, value: Vec<TagOnFileWhereParam>) -> FileWhereParam {
        FileWhereParam::FileTagsSome(value)
    }
    pub fn every(&self, value: Vec<TagOnFileWhereParam>) -> FileWhereParam {
        FileWhereParam::FileTagsEvery(value)
    }
    pub fn link<T: From<FileLinkFileTags>>(&self, value: Vec<TagOnFileWhereParam>) -> T {
        FileLinkFileTags(value).into()
    }
    pub fn unlink(&self, params: Vec<TagOnFileWhereParam>) -> FileSetParam {
        FileSetParam::UnlinkFileTags(params)
    }
    pub fn fetch(&self, params: Vec<TagOnFileWhereParam>) -> FileWith {
        FileWithParam::FileTags(params).into()
    }
}
pub enum FileWhereParam {
    IdLT(i64),
    IdGT(i64),
    IdLTE(i64),
    IdGTE(i64),
    IdEquals(i64),
    IsDirEquals(bool),
    LocationIdLT(i64),
    LocationIdGT(i64),
    LocationIdLTE(i64),
    LocationIdGTE(i64),
    LocationIdEquals(i64),
    StemContains(String),
    StemHasPrefix(String),
    StemHasSuffix(String),
    StemEquals(String),
    NameContains(String),
    NameHasPrefix(String),
    NameHasSuffix(String),
    NameEquals(String),
    ExtensionContains(String),
    ExtensionHasPrefix(String),
    ExtensionHasSuffix(String),
    ExtensionEquals(String),
    PathChecksumContains(String),
    PathChecksumHasPrefix(String),
    PathChecksumHasSuffix(String),
    PathChecksumEquals(String),
    QuickChecksumContains(String),
    QuickChecksumHasPrefix(String),
    QuickChecksumHasSuffix(String),
    QuickChecksumEquals(String),
    FullChecksumContains(String),
    FullChecksumHasPrefix(String),
    FullChecksumHasSuffix(String),
    FullChecksumEquals(String),
    SizeInBytesContains(String),
    SizeInBytesHasPrefix(String),
    SizeInBytesHasSuffix(String),
    SizeInBytesEquals(String),
    EncryptionLT(i64),
    EncryptionGT(i64),
    EncryptionLTE(i64),
    EncryptionGTE(i64),
    EncryptionEquals(i64),
    DateCreatedBefore(chrono::DateTime<chrono::Utc>),
    DateCreatedAfter(chrono::DateTime<chrono::Utc>),
    DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedBefore(chrono::DateTime<chrono::Utc>),
    DateModifiedAfter(chrono::DateTime<chrono::Utc>),
    DateModifiedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedEquals(chrono::DateTime<chrono::Utc>),
    DateIndexedBefore(chrono::DateTime<chrono::Utc>),
    DateIndexedAfter(chrono::DateTime<chrono::Utc>),
    DateIndexedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateIndexedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateIndexedEquals(chrono::DateTime<chrono::Utc>),
    IpfsIdContains(String),
    IpfsIdHasPrefix(String),
    IpfsIdHasSuffix(String),
    IpfsIdEquals(String),
    LocationIs(Vec<LocationWhereParam>),
    ParentIs(Vec<FileWhereParam>),
    ParentIdLT(i64),
    ParentIdGT(i64),
    ParentIdLTE(i64),
    ParentIdGTE(i64),
    ParentIdEquals(i64),
    ChildrenSome(Vec<FileWhereParam>),
    ChildrenEvery(Vec<FileWhereParam>),
    FileTagsSome(Vec<TagOnFileWhereParam>),
    FileTagsEvery(Vec<TagOnFileWhereParam>),
    Not(Vec<FileWhereParam>),
    Or(Vec<FileWhereParam>),
    And(Vec<FileWhereParam>),
}
impl FileWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdLT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdLTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IsDirEquals(value) => Field {
                name: "is_dir".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LocationIdLT(value) => Field {
                name: "location_id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LocationIdGT(value) => Field {
                name: "location_id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LocationIdLTE(value) => Field {
                name: "location_id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LocationIdGTE(value) => Field {
                name: "location_id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LocationIdEquals(value) => Field {
                name: "location_id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StemContains(value) => Field {
                name: "stem".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StemHasPrefix(value) => Field {
                name: "stem".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StemHasSuffix(value) => Field {
                name: "stem".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StemEquals(value) => Field {
                name: "stem".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameContains(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasPrefix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasSuffix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameEquals(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ExtensionContains(value) => Field {
                name: "extension".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ExtensionHasPrefix(value) => Field {
                name: "extension".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ExtensionHasSuffix(value) => Field {
                name: "extension".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ExtensionEquals(value) => Field {
                name: "extension".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PathChecksumContains(value) => Field {
                name: "path_checksum".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PathChecksumHasPrefix(value) => Field {
                name: "path_checksum".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PathChecksumHasSuffix(value) => Field {
                name: "path_checksum".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PathChecksumEquals(value) => Field {
                name: "path_checksum".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::QuickChecksumContains(value) => Field {
                name: "quick_checksum".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::QuickChecksumHasPrefix(value) => Field {
                name: "quick_checksum".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::QuickChecksumHasSuffix(value) => Field {
                name: "quick_checksum".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::QuickChecksumEquals(value) => Field {
                name: "quick_checksum".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FullChecksumContains(value) => Field {
                name: "full_checksum".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FullChecksumHasPrefix(value) => Field {
                name: "full_checksum".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FullChecksumHasSuffix(value) => Field {
                name: "full_checksum".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FullChecksumEquals(value) => Field {
                name: "full_checksum".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::SizeInBytesContains(value) => Field {
                name: "size_in_bytes".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::SizeInBytesHasPrefix(value) => Field {
                name: "size_in_bytes".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::SizeInBytesHasSuffix(value) => Field {
                name: "size_in_bytes".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::SizeInBytesEquals(value) => Field {
                name: "size_in_bytes".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionLT(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionGT(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionLTE(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionGTE(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionEquals(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBefore(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfter(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBeforeEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfterEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedBefore(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedAfter(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedBeforeEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedAfterEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateIndexedBefore(value) => Field {
                name: "date_indexed".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateIndexedAfter(value) => Field {
                name: "date_indexed".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateIndexedBeforeEquals(value) => Field {
                name: "date_indexed".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateIndexedAfterEquals(value) => Field {
                name: "date_indexed".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateIndexedEquals(value) => Field {
                name: "date_indexed".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IpfsIdContains(value) => Field {
                name: "ipfs_id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IpfsIdHasPrefix(value) => Field {
                name: "ipfs_id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IpfsIdHasSuffix(value) => Field {
                name: "ipfs_id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IpfsIdEquals(value) => Field {
                name: "ipfs_id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LocationIs(value) => Field {
                name: "location".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ParentIs(value) => Field {
                name: "parent".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ParentIdLT(value) => Field {
                name: "parent_id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ParentIdGT(value) => Field {
                name: "parent_id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ParentIdLTE(value) => Field {
                name: "parent_id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ParentIdGTE(value) => Field {
                name: "parent_id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ParentIdEquals(value) => Field {
                name: "parent_id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ChildrenSome(value) => Field {
                name: "children".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ChildrenEvery(value) => Field {
                name: "children".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FileTagsSome(value) => Field {
                name: "file_tags".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FileTagsEvery(value) => Field {
                name: "file_tags".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct FileWith {
    pub param: FileWithParam,
}
pub enum FileWithParam {
    Location,
    Parent,
    Children(Vec<FileWhereParam>),
    FileTags(Vec<TagOnFileWhereParam>),
}
impl From<FileWithParam> for FileWith {
    fn from(param: FileWithParam) -> Self {
        Self { param }
    }
}
impl FileWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Location => Output {
                name: "location".into(),
                outputs: location_outputs(),
                ..Default::default()
            },
            Self::Parent => Output {
                name: "parent".into(),
                outputs: file_outputs(),
                ..Default::default()
            },
            Self::Children(where_params) => Output {
                name: "children".into(),
                outputs: file_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
            Self::FileTags(where_params) => Output {
                name: "file_tags".into(),
                outputs: tag_on_file_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
        }
    }
}
pub enum FileSetParam {
    Id(i64),
    IsDir(bool),
    LocationId(i64),
    Stem(String),
    Name(String),
    Extension(String),
    PathChecksum(String),
    QuickChecksum(String),
    FullChecksum(String),
    SizeInBytes(String),
    Encryption(i64),
    DateCreated(chrono::DateTime<chrono::Utc>),
    DateModified(chrono::DateTime<chrono::Utc>),
    DateIndexed(chrono::DateTime<chrono::Utc>),
    IpfsId(String),
    LinkLocation(LocationWhereParam),
    UnlinkLocation,
    LinkParent(FileWhereParam),
    UnlinkParent,
    ParentId(i64),
    LinkChildren(Vec<FileWhereParam>),
    UnlinkChildren(Vec<FileWhereParam>),
    LinkFileTags(Vec<TagOnFileWhereParam>),
    UnlinkFileTags(Vec<TagOnFileWhereParam>),
}
impl FileSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::IsDir(value) => Field {
                name: "is_dir".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LocationId(value) => Field {
                name: "location_id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Stem(value) => Field {
                name: "stem".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Name(value) => Field {
                name: "name".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Extension(value) => Field {
                name: "extension".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::PathChecksum(value) => Field {
                name: "path_checksum".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::QuickChecksum(value) => Field {
                name: "quick_checksum".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::FullChecksum(value) => Field {
                name: "full_checksum".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::SizeInBytes(value) => Field {
                name: "size_in_bytes".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Encryption(value) => Field {
                name: "encryption".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateCreated(value) => Field {
                name: "date_created".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateModified(value) => Field {
                name: "date_modified".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateIndexed(value) => Field {
                name: "date_indexed".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::IpfsId(value) => Field {
                name: "ipfs_id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkLocation(where_param) => Field {
                name: "location".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UnlinkLocation => Field {
                name: "location".into(),
                fields: Some(vec![Field {
                    name: "disconnect".into(),
                    value: Some(true.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LinkParent(where_param) => Field {
                name: "parent".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UnlinkParent => Field {
                name: "parent".into(),
                fields: Some(vec![Field {
                    name: "disconnect".into(),
                    value: Some(true.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ParentId(value) => Field {
                name: "parent_id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkChildren(where_params) => Field {
                name: "children".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UnlinkChildren(where_params) => Field {
                name: "children".into(),
                fields: Some(vec![Field {
                    name: "disconnect".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LinkFileTags(where_params) => Field {
                name: "file_tags".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UnlinkFileTags(where_params) => Field {
                name: "file_tags".into(),
                fields: Some(vec![Field {
                    name: "disconnect".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub struct FileFindMany<'a> {
    query: Query<'a>,
}
impl<'a> FileFindMany<'a> {
    pub async fn exec(self) -> Vec<FileData> {
        self.query.perform::<Vec<FileData>>().await.unwrap()
    }
    pub fn delete(self) -> FileDelete<'a> {
        FileDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "File".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<FileSetParam>) -> FileUpdateMany<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        FileUpdateMany {
            query: Query {
                operation: "mutation".into(),
                method: "updateMany".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<FileWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct FileFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> FileFindFirst<'a> {
    pub async fn exec(self) -> Option<FileData> {
        self.query.perform::<Option<FileData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<FileWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct FileFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> FileFindUnique<'a> {
    pub async fn exec(self) -> Option<FileData> {
        self.query.perform::<Option<FileData>>().await.unwrap()
    }
    pub fn delete(self) -> FileDelete<'a> {
        FileDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "File".into(),
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<FileSetParam>) -> FileUpdateUnique<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        FileUpdateUnique {
            query: Query {
                operation: "mutation".into(),
                method: "updateOne".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<FileWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct FileCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> FileCreateOne<'a> {
    pub async fn exec(self) -> FileData {
        self.query.perform::<FileData>().await.unwrap()
    }
}
pub struct FileUpdateUnique<'a> {
    query: Query<'a>,
}
impl<'a> FileUpdateUnique<'a> {
    pub async fn exec(self) -> FileData {
        self.query.perform::<FileData>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<FileWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct FileUpdateMany<'a> {
    query: Query<'a>,
}
impl<'a> FileUpdateMany<'a> {
    pub async fn exec(self) -> Vec<FileData> {
        self.query.perform::<Vec<FileData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<FileWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct FileDelete<'a> {
    query: Query<'a>,
}
impl<'a> FileDelete<'a> {
    pub async fn exec(self) -> isize {
        self.query.perform::<DeleteResult>().await.unwrap().count
    }
}
pub struct FileActions<'a> {
    client: &'a PrismaClient,
}
impl<'a> FileActions<'a> {
    pub fn find_unique(&self, param: FileWhereParam) -> FileFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "File".into(),
            outputs: file_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        FileFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<FileWhereParam>) -> FileFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "File".into(),
            outputs: file_outputs(),
            inputs,
        };
        FileFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<FileWhereParam>) -> FileFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "File".into(),
            outputs: file_outputs(),
            inputs,
        };
        FileFindMany { query }
    }
    pub fn create_one(
        &self,
        stem: FileSetStem,
        name: FileSetName,
        path_checksum: FileSetPathChecksum,
        size_in_bytes: FileSetSizeInBytes,
        params: Vec<FileSetParam>,
    ) -> FileCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(FileSetParam::from(stem).field());
        input_fields.push(FileSetParam::from(name).field());
        input_fields.push(FileSetParam::from(path_checksum).field());
        input_fields.push(FileSetParam::from(size_in_bytes).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "File".into(),
            outputs: file_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        FileCreateOne { query }
    }
}
fn tag_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("name"),
        Output::new("encryption"),
        Output::new("total_files"),
        Output::new("redundancy_goal"),
        Output::new("date_created"),
        Output::new("date_modified"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TagData {
    #[serde(rename = "id")]
    pub id: i64,
    #[serde(rename = "name")]
    pub name: Option<String>,
    #[serde(rename = "encryption")]
    pub encryption: Option<i64>,
    #[serde(rename = "total_files")]
    pub total_files: Option<i64>,
    #[serde(rename = "redundancy_goal")]
    pub redundancy_goal: Option<i64>,
    #[serde(rename = "date_created")]
    pub date_created: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "date_modified")]
    pub date_modified: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "tag_files")]
    tag_files: Option<Vec<TagOnFileData>>,
}
impl TagData {
    pub fn tag_files(&self) -> Result<&Vec<TagOnFileData>, String> {
        match self.tag_files.as_ref() {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access tag_files but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct Tag;
impl Tag {
    pub fn id() -> TagIdField {
        TagIdField {}
    }
    pub fn name() -> TagNameField {
        TagNameField {}
    }
    pub fn encryption() -> TagEncryptionField {
        TagEncryptionField {}
    }
    pub fn total_files() -> TagTotalFilesField {
        TagTotalFilesField {}
    }
    pub fn redundancy_goal() -> TagRedundancyGoalField {
        TagRedundancyGoalField {}
    }
    pub fn date_created() -> TagDateCreatedField {
        TagDateCreatedField {}
    }
    pub fn date_modified() -> TagDateModifiedField {
        TagDateModifiedField {}
    }
    pub fn tag_files() -> TagTagFilesField {
        TagTagFilesField {}
    }
    pub fn not(params: Vec<TagWhereParam>) -> TagWhereParam {
        TagWhereParam::Not(params)
    }
    pub fn or(params: Vec<TagWhereParam>) -> TagWhereParam {
        TagWhereParam::Or(params)
    }
    pub fn and(params: Vec<TagWhereParam>) -> TagWhereParam {
        TagWhereParam::And(params)
    }
}
pub struct TagIdField {}
pub struct TagSetId(i64);
impl From<TagSetId> for TagSetParam {
    fn from(value: TagSetId) -> Self {
        Self::Id(value.0)
    }
}
impl TagIdField {
    pub fn lt(&self, value: i64) -> TagWhereParam {
        TagWhereParam::IdLT(value)
    }
    pub fn gt(&self, value: i64) -> TagWhereParam {
        TagWhereParam::IdGT(value)
    }
    pub fn lte(&self, value: i64) -> TagWhereParam {
        TagWhereParam::IdLTE(value)
    }
    pub fn gte(&self, value: i64) -> TagWhereParam {
        TagWhereParam::IdGTE(value)
    }
    pub fn equals(&self, value: i64) -> TagWhereParam {
        TagWhereParam::IdEquals(value)
    }
    pub fn set<T: From<TagSetId>>(&self, value: i64) -> T {
        TagSetId(value).into()
    }
}
pub struct TagNameField {}
pub struct TagSetName(String);
impl From<TagSetName> for TagSetParam {
    fn from(value: TagSetName) -> Self {
        Self::Name(value.0)
    }
}
impl TagNameField {
    pub fn contains(&self, value: String) -> TagWhereParam {
        TagWhereParam::NameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> TagWhereParam {
        TagWhereParam::NameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> TagWhereParam {
        TagWhereParam::NameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> TagWhereParam {
        TagWhereParam::NameEquals(value)
    }
    pub fn set<T: From<TagSetName>>(&self, value: String) -> T {
        TagSetName(value).into()
    }
}
pub struct TagEncryptionField {}
pub struct TagSetEncryption(i64);
impl From<TagSetEncryption> for TagSetParam {
    fn from(value: TagSetEncryption) -> Self {
        Self::Encryption(value.0)
    }
}
impl TagEncryptionField {
    pub fn lt(&self, value: i64) -> TagWhereParam {
        TagWhereParam::EncryptionLT(value)
    }
    pub fn gt(&self, value: i64) -> TagWhereParam {
        TagWhereParam::EncryptionGT(value)
    }
    pub fn lte(&self, value: i64) -> TagWhereParam {
        TagWhereParam::EncryptionLTE(value)
    }
    pub fn gte(&self, value: i64) -> TagWhereParam {
        TagWhereParam::EncryptionGTE(value)
    }
    pub fn equals(&self, value: i64) -> TagWhereParam {
        TagWhereParam::EncryptionEquals(value)
    }
    pub fn set<T: From<TagSetEncryption>>(&self, value: i64) -> T {
        TagSetEncryption(value).into()
    }
}
pub struct TagTotalFilesField {}
pub struct TagSetTotalFiles(i64);
impl From<TagSetTotalFiles> for TagSetParam {
    fn from(value: TagSetTotalFiles) -> Self {
        Self::TotalFiles(value.0)
    }
}
impl TagTotalFilesField {
    pub fn lt(&self, value: i64) -> TagWhereParam {
        TagWhereParam::TotalFilesLT(value)
    }
    pub fn gt(&self, value: i64) -> TagWhereParam {
        TagWhereParam::TotalFilesGT(value)
    }
    pub fn lte(&self, value: i64) -> TagWhereParam {
        TagWhereParam::TotalFilesLTE(value)
    }
    pub fn gte(&self, value: i64) -> TagWhereParam {
        TagWhereParam::TotalFilesGTE(value)
    }
    pub fn equals(&self, value: i64) -> TagWhereParam {
        TagWhereParam::TotalFilesEquals(value)
    }
    pub fn set<T: From<TagSetTotalFiles>>(&self, value: i64) -> T {
        TagSetTotalFiles(value).into()
    }
}
pub struct TagRedundancyGoalField {}
pub struct TagSetRedundancyGoal(i64);
impl From<TagSetRedundancyGoal> for TagSetParam {
    fn from(value: TagSetRedundancyGoal) -> Self {
        Self::RedundancyGoal(value.0)
    }
}
impl TagRedundancyGoalField {
    pub fn lt(&self, value: i64) -> TagWhereParam {
        TagWhereParam::RedundancyGoalLT(value)
    }
    pub fn gt(&self, value: i64) -> TagWhereParam {
        TagWhereParam::RedundancyGoalGT(value)
    }
    pub fn lte(&self, value: i64) -> TagWhereParam {
        TagWhereParam::RedundancyGoalLTE(value)
    }
    pub fn gte(&self, value: i64) -> TagWhereParam {
        TagWhereParam::RedundancyGoalGTE(value)
    }
    pub fn equals(&self, value: i64) -> TagWhereParam {
        TagWhereParam::RedundancyGoalEquals(value)
    }
    pub fn set<T: From<TagSetRedundancyGoal>>(&self, value: i64) -> T {
        TagSetRedundancyGoal(value).into()
    }
}
pub struct TagDateCreatedField {}
pub struct TagSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<TagSetDateCreated> for TagSetParam {
    fn from(value: TagSetDateCreated) -> Self {
        Self::DateCreated(value.0)
    }
}
impl TagDateCreatedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
        TagWhereParam::DateCreatedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
        TagWhereParam::DateCreatedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
        TagWhereParam::DateCreatedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
        TagWhereParam::DateCreatedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
        TagWhereParam::DateCreatedEquals(value)
    }
    pub fn set<T: From<TagSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        TagSetDateCreated(value).into()
    }
}
pub struct TagDateModifiedField {}
pub struct TagSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<TagSetDateModified> for TagSetParam {
    fn from(value: TagSetDateModified) -> Self {
        Self::DateModified(value.0)
    }
}
impl TagDateModifiedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
        TagWhereParam::DateModifiedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
        TagWhereParam::DateModifiedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
        TagWhereParam::DateModifiedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
        TagWhereParam::DateModifiedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
        TagWhereParam::DateModifiedEquals(value)
    }
    pub fn set<T: From<TagSetDateModified>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        TagSetDateModified(value).into()
    }
}
pub struct TagTagFilesField {}
pub struct TagLinkTagFiles(Vec<TagOnFileWhereParam>);
impl From<TagLinkTagFiles> for TagSetParam {
    fn from(value: TagLinkTagFiles) -> Self {
        Self::LinkTagFiles(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl TagTagFilesField {
    pub fn some(&self, value: Vec<TagOnFileWhereParam>) -> TagWhereParam {
        TagWhereParam::TagFilesSome(value)
    }
    pub fn every(&self, value: Vec<TagOnFileWhereParam>) -> TagWhereParam {
        TagWhereParam::TagFilesEvery(value)
    }
    pub fn link<T: From<TagLinkTagFiles>>(&self, value: Vec<TagOnFileWhereParam>) -> T {
        TagLinkTagFiles(value).into()
    }
    pub fn unlink(&self, params: Vec<TagOnFileWhereParam>) -> TagSetParam {
        TagSetParam::UnlinkTagFiles(params)
    }
    pub fn fetch(&self, params: Vec<TagOnFileWhereParam>) -> TagWith {
        TagWithParam::TagFiles(params).into()
    }
}
pub enum TagWhereParam {
    IdLT(i64),
    IdGT(i64),
    IdLTE(i64),
    IdGTE(i64),
    IdEquals(i64),
    NameContains(String),
    NameHasPrefix(String),
    NameHasSuffix(String),
    NameEquals(String),
    EncryptionLT(i64),
    EncryptionGT(i64),
    EncryptionLTE(i64),
    EncryptionGTE(i64),
    EncryptionEquals(i64),
    TotalFilesLT(i64),
    TotalFilesGT(i64),
    TotalFilesLTE(i64),
    TotalFilesGTE(i64),
    TotalFilesEquals(i64),
    RedundancyGoalLT(i64),
    RedundancyGoalGT(i64),
    RedundancyGoalLTE(i64),
    RedundancyGoalGTE(i64),
    RedundancyGoalEquals(i64),
    DateCreatedBefore(chrono::DateTime<chrono::Utc>),
    DateCreatedAfter(chrono::DateTime<chrono::Utc>),
    DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedBefore(chrono::DateTime<chrono::Utc>),
    DateModifiedAfter(chrono::DateTime<chrono::Utc>),
    DateModifiedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedEquals(chrono::DateTime<chrono::Utc>),
    TagFilesSome(Vec<TagOnFileWhereParam>),
    TagFilesEvery(Vec<TagOnFileWhereParam>),
    Not(Vec<TagWhereParam>),
    Or(Vec<TagWhereParam>),
    And(Vec<TagWhereParam>),
}
impl TagWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdLT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdLTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameContains(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasPrefix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasSuffix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameEquals(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionLT(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionGT(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionLTE(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionGTE(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionEquals(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalFilesLT(value) => Field {
                name: "total_files".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalFilesGT(value) => Field {
                name: "total_files".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalFilesLTE(value) => Field {
                name: "total_files".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalFilesGTE(value) => Field {
                name: "total_files".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TotalFilesEquals(value) => Field {
                name: "total_files".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::RedundancyGoalLT(value) => Field {
                name: "redundancy_goal".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::RedundancyGoalGT(value) => Field {
                name: "redundancy_goal".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::RedundancyGoalLTE(value) => Field {
                name: "redundancy_goal".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::RedundancyGoalGTE(value) => Field {
                name: "redundancy_goal".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::RedundancyGoalEquals(value) => Field {
                name: "redundancy_goal".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBefore(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfter(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBeforeEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfterEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedBefore(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedAfter(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedBeforeEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedAfterEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TagFilesSome(value) => Field {
                name: "tag_files".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TagFilesEvery(value) => Field {
                name: "tag_files".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct TagWith {
    pub param: TagWithParam,
}
pub enum TagWithParam {
    TagFiles(Vec<TagOnFileWhereParam>),
}
impl From<TagWithParam> for TagWith {
    fn from(param: TagWithParam) -> Self {
        Self { param }
    }
}
impl TagWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::TagFiles(where_params) => Output {
                name: "tag_files".into(),
                outputs: tag_on_file_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
        }
    }
}
pub enum TagSetParam {
    Id(i64),
    Name(String),
    Encryption(i64),
    TotalFiles(i64),
    RedundancyGoal(i64),
    DateCreated(chrono::DateTime<chrono::Utc>),
    DateModified(chrono::DateTime<chrono::Utc>),
    LinkTagFiles(Vec<TagOnFileWhereParam>),
    UnlinkTagFiles(Vec<TagOnFileWhereParam>),
}
impl TagSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Name(value) => Field {
                name: "name".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Encryption(value) => Field {
                name: "encryption".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::TotalFiles(value) => Field {
                name: "total_files".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::RedundancyGoal(value) => Field {
                name: "redundancy_goal".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateCreated(value) => Field {
                name: "date_created".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateModified(value) => Field {
                name: "date_modified".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkTagFiles(where_params) => Field {
                name: "tag_files".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UnlinkTagFiles(where_params) => Field {
                name: "tag_files".into(),
                fields: Some(vec![Field {
                    name: "disconnect".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub struct TagFindMany<'a> {
    query: Query<'a>,
}
impl<'a> TagFindMany<'a> {
    pub async fn exec(self) -> Vec<TagData> {
        self.query.perform::<Vec<TagData>>().await.unwrap()
    }
    pub fn delete(self) -> TagDelete<'a> {
        TagDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "Tag".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<TagSetParam>) -> TagUpdateMany<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        TagUpdateMany {
            query: Query {
                operation: "mutation".into(),
                method: "updateMany".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<TagWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TagFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> TagFindFirst<'a> {
    pub async fn exec(self) -> Option<TagData> {
        self.query.perform::<Option<TagData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<TagWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TagFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> TagFindUnique<'a> {
    pub async fn exec(self) -> Option<TagData> {
        self.query.perform::<Option<TagData>>().await.unwrap()
    }
    pub fn delete(self) -> TagDelete<'a> {
        TagDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "Tag".into(),
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<TagSetParam>) -> TagUpdateUnique<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        TagUpdateUnique {
            query: Query {
                operation: "mutation".into(),
                method: "updateOne".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<TagWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TagCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> TagCreateOne<'a> {
    pub async fn exec(self) -> TagData {
        self.query.perform::<TagData>().await.unwrap()
    }
}
pub struct TagUpdateUnique<'a> {
    query: Query<'a>,
}
impl<'a> TagUpdateUnique<'a> {
    pub async fn exec(self) -> TagData {
        self.query.perform::<TagData>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<TagWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TagUpdateMany<'a> {
    query: Query<'a>,
}
impl<'a> TagUpdateMany<'a> {
    pub async fn exec(self) -> Vec<TagData> {
        self.query.perform::<Vec<TagData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<TagWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TagDelete<'a> {
    query: Query<'a>,
}
impl<'a> TagDelete<'a> {
    pub async fn exec(self) -> isize {
        self.query.perform::<DeleteResult>().await.unwrap().count
    }
}
pub struct TagActions<'a> {
    client: &'a PrismaClient,
}
impl<'a> TagActions<'a> {
    pub fn find_unique(&self, param: TagWhereParam) -> TagFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "Tag".into(),
            outputs: tag_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        TagFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<TagWhereParam>) -> TagFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "Tag".into(),
            outputs: tag_outputs(),
            inputs,
        };
        TagFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<TagWhereParam>) -> TagFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "Tag".into(),
            outputs: tag_outputs(),
            inputs,
        };
        TagFindMany { query }
    }
    pub fn create_one(&self, params: Vec<TagSetParam>) -> TagCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "Tag".into(),
            outputs: tag_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        TagCreateOne { query }
    }
}
fn tag_on_file_outputs() -> Vec<Output> {
    vec![
        Output::new("date_created"),
        Output::new("tag_id"),
        Output::new("file_id"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TagOnFileData {
    #[serde(rename = "date_created")]
    pub date_created: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "tag_id")]
    pub tag_id: i64,
    #[serde(rename = "tag")]
    tag: Box<Option<TagData>>,
    #[serde(rename = "file_id")]
    pub file_id: i64,
    #[serde(rename = "file")]
    file: Box<Option<FileData>>,
}
impl TagOnFileData {
    pub fn tag(&self) -> Result<&TagData, String> {
        match self.tag.as_ref() {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access tag but did not fetch it using the .with() syntax".to_string(),
            ),
        }
    }
    pub fn file(&self) -> Result<&FileData, String> {
        match self.file.as_ref() {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access file but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct TagOnFile;
impl TagOnFile {
    pub fn date_created() -> TagOnFileDateCreatedField {
        TagOnFileDateCreatedField {}
    }
    pub fn tag_id() -> TagOnFileTagIdField {
        TagOnFileTagIdField {}
    }
    pub fn tag() -> TagOnFileTagField {
        TagOnFileTagField {}
    }
    pub fn file_id() -> TagOnFileFileIdField {
        TagOnFileFileIdField {}
    }
    pub fn file() -> TagOnFileFileField {
        TagOnFileFileField {}
    }
    pub fn not(params: Vec<TagOnFileWhereParam>) -> TagOnFileWhereParam {
        TagOnFileWhereParam::Not(params)
    }
    pub fn or(params: Vec<TagOnFileWhereParam>) -> TagOnFileWhereParam {
        TagOnFileWhereParam::Or(params)
    }
    pub fn and(params: Vec<TagOnFileWhereParam>) -> TagOnFileWhereParam {
        TagOnFileWhereParam::And(params)
    }
}
pub struct TagOnFileDateCreatedField {}
pub struct TagOnFileSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<TagOnFileSetDateCreated> for TagOnFileSetParam {
    fn from(value: TagOnFileSetDateCreated) -> Self {
        Self::DateCreated(value.0)
    }
}
impl TagOnFileDateCreatedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
        TagOnFileWhereParam::DateCreatedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
        TagOnFileWhereParam::DateCreatedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
        TagOnFileWhereParam::DateCreatedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
        TagOnFileWhereParam::DateCreatedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
        TagOnFileWhereParam::DateCreatedEquals(value)
    }
    pub fn set<T: From<TagOnFileSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        TagOnFileSetDateCreated(value).into()
    }
}
pub struct TagOnFileTagIdField {}
pub struct TagOnFileSetTagId(i64);
impl From<TagOnFileSetTagId> for TagOnFileSetParam {
    fn from(value: TagOnFileSetTagId) -> Self {
        Self::TagId(value.0)
    }
}
impl TagOnFileTagIdField {
    pub fn lt(&self, value: i64) -> TagOnFileWhereParam {
        TagOnFileWhereParam::TagIdLT(value)
    }
    pub fn gt(&self, value: i64) -> TagOnFileWhereParam {
        TagOnFileWhereParam::TagIdGT(value)
    }
    pub fn lte(&self, value: i64) -> TagOnFileWhereParam {
        TagOnFileWhereParam::TagIdLTE(value)
    }
    pub fn gte(&self, value: i64) -> TagOnFileWhereParam {
        TagOnFileWhereParam::TagIdGTE(value)
    }
    pub fn equals(&self, value: i64) -> TagOnFileWhereParam {
        TagOnFileWhereParam::TagIdEquals(value)
    }
    pub fn set<T: From<TagOnFileSetTagId>>(&self, value: i64) -> T {
        TagOnFileSetTagId(value).into()
    }
}
pub struct TagOnFileTagField {}
pub struct TagOnFileLinkTag(TagWhereParam);
impl From<TagOnFileLinkTag> for TagOnFileSetParam {
    fn from(value: TagOnFileLinkTag) -> Self {
        Self::LinkTag(value.0)
    }
}
impl TagOnFileTagField {
    pub fn is(&self, value: Vec<TagWhereParam>) -> TagOnFileWhereParam {
        TagOnFileWhereParam::TagIs(value)
    }
    pub fn link<T: From<TagOnFileLinkTag>>(&self, value: TagWhereParam) -> T {
        TagOnFileLinkTag(value).into()
    }
    pub fn fetch(&self) -> TagOnFileWith {
        TagOnFileWithParam::Tag.into()
    }
}
pub struct TagOnFileFileIdField {}
pub struct TagOnFileSetFileId(i64);
impl From<TagOnFileSetFileId> for TagOnFileSetParam {
    fn from(value: TagOnFileSetFileId) -> Self {
        Self::FileId(value.0)
    }
}
impl TagOnFileFileIdField {
    pub fn lt(&self, value: i64) -> TagOnFileWhereParam {
        TagOnFileWhereParam::FileIdLT(value)
    }
    pub fn gt(&self, value: i64) -> TagOnFileWhereParam {
        TagOnFileWhereParam::FileIdGT(value)
    }
    pub fn lte(&self, value: i64) -> TagOnFileWhereParam {
        TagOnFileWhereParam::FileIdLTE(value)
    }
    pub fn gte(&self, value: i64) -> TagOnFileWhereParam {
        TagOnFileWhereParam::FileIdGTE(value)
    }
    pub fn equals(&self, value: i64) -> TagOnFileWhereParam {
        TagOnFileWhereParam::FileIdEquals(value)
    }
    pub fn set<T: From<TagOnFileSetFileId>>(&self, value: i64) -> T {
        TagOnFileSetFileId(value).into()
    }
}
pub struct TagOnFileFileField {}
pub struct TagOnFileLinkFile(FileWhereParam);
impl From<TagOnFileLinkFile> for TagOnFileSetParam {
    fn from(value: TagOnFileLinkFile) -> Self {
        Self::LinkFile(value.0)
    }
}
impl TagOnFileFileField {
    pub fn is(&self, value: Vec<FileWhereParam>) -> TagOnFileWhereParam {
        TagOnFileWhereParam::FileIs(value)
    }
    pub fn link<T: From<TagOnFileLinkFile>>(&self, value: FileWhereParam) -> T {
        TagOnFileLinkFile(value).into()
    }
    pub fn fetch(&self) -> TagOnFileWith {
        TagOnFileWithParam::File.into()
    }
}
pub enum TagOnFileWhereParam {
    DateCreatedBefore(chrono::DateTime<chrono::Utc>),
    DateCreatedAfter(chrono::DateTime<chrono::Utc>),
    DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedEquals(chrono::DateTime<chrono::Utc>),
    TagIdLT(i64),
    TagIdGT(i64),
    TagIdLTE(i64),
    TagIdGTE(i64),
    TagIdEquals(i64),
    TagIs(Vec<TagWhereParam>),
    FileIdLT(i64),
    FileIdGT(i64),
    FileIdLTE(i64),
    FileIdGTE(i64),
    FileIdEquals(i64),
    FileIs(Vec<FileWhereParam>),
    Not(Vec<TagOnFileWhereParam>),
    Or(Vec<TagOnFileWhereParam>),
    And(Vec<TagOnFileWhereParam>),
}
impl TagOnFileWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::DateCreatedBefore(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfter(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBeforeEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfterEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TagIdLT(value) => Field {
                name: "tag_id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TagIdGT(value) => Field {
                name: "tag_id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TagIdLTE(value) => Field {
                name: "tag_id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TagIdGTE(value) => Field {
                name: "tag_id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TagIdEquals(value) => Field {
                name: "tag_id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TagIs(value) => Field {
                name: "tag".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FileIdLT(value) => Field {
                name: "file_id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FileIdGT(value) => Field {
                name: "file_id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FileIdLTE(value) => Field {
                name: "file_id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FileIdGTE(value) => Field {
                name: "file_id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FileIdEquals(value) => Field {
                name: "file_id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FileIs(value) => Field {
                name: "file".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct TagOnFileWith {
    pub param: TagOnFileWithParam,
}
pub enum TagOnFileWithParam {
    Tag,
    File,
}
impl From<TagOnFileWithParam> for TagOnFileWith {
    fn from(param: TagOnFileWithParam) -> Self {
        Self { param }
    }
}
impl TagOnFileWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Tag => Output {
                name: "tag".into(),
                outputs: tag_outputs(),
                ..Default::default()
            },
            Self::File => Output {
                name: "file".into(),
                outputs: file_outputs(),
                ..Default::default()
            },
        }
    }
}
pub enum TagOnFileSetParam {
    DateCreated(chrono::DateTime<chrono::Utc>),
    TagId(i64),
    LinkTag(TagWhereParam),
    FileId(i64),
    LinkFile(FileWhereParam),
}
impl TagOnFileSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::DateCreated(value) => Field {
                name: "date_created".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::TagId(value) => Field {
                name: "tag_id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkTag(where_param) => Field {
                name: "tag".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::FileId(value) => Field {
                name: "file_id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkFile(where_param) => Field {
                name: "file".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub struct TagOnFileFindMany<'a> {
    query: Query<'a>,
}
impl<'a> TagOnFileFindMany<'a> {
    pub async fn exec(self) -> Vec<TagOnFileData> {
        self.query.perform::<Vec<TagOnFileData>>().await.unwrap()
    }
    pub fn delete(self) -> TagOnFileDelete<'a> {
        TagOnFileDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "TagOnFile".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<TagOnFileSetParam>) -> TagOnFileUpdateMany<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        TagOnFileUpdateMany {
            query: Query {
                operation: "mutation".into(),
                method: "updateMany".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<TagOnFileWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TagOnFileFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> TagOnFileFindFirst<'a> {
    pub async fn exec(self) -> Option<TagOnFileData> {
        self.query.perform::<Option<TagOnFileData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<TagOnFileWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TagOnFileFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> TagOnFileFindUnique<'a> {
    pub async fn exec(self) -> Option<TagOnFileData> {
        self.query.perform::<Option<TagOnFileData>>().await.unwrap()
    }
    pub fn delete(self) -> TagOnFileDelete<'a> {
        TagOnFileDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "TagOnFile".into(),
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<TagOnFileSetParam>) -> TagOnFileUpdateUnique<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        TagOnFileUpdateUnique {
            query: Query {
                operation: "mutation".into(),
                method: "updateOne".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<TagOnFileWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TagOnFileCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> TagOnFileCreateOne<'a> {
    pub async fn exec(self) -> TagOnFileData {
        self.query.perform::<TagOnFileData>().await.unwrap()
    }
}
pub struct TagOnFileUpdateUnique<'a> {
    query: Query<'a>,
}
impl<'a> TagOnFileUpdateUnique<'a> {
    pub async fn exec(self) -> TagOnFileData {
        self.query.perform::<TagOnFileData>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<TagOnFileWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TagOnFileUpdateMany<'a> {
    query: Query<'a>,
}
impl<'a> TagOnFileUpdateMany<'a> {
    pub async fn exec(self) -> Vec<TagOnFileData> {
        self.query.perform::<Vec<TagOnFileData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<TagOnFileWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TagOnFileDelete<'a> {
    query: Query<'a>,
}
impl<'a> TagOnFileDelete<'a> {
    pub async fn exec(self) -> isize {
        self.query.perform::<DeleteResult>().await.unwrap().count
    }
}
pub struct TagOnFileActions<'a> {
    client: &'a PrismaClient,
}
impl<'a> TagOnFileActions<'a> {
    pub fn find_unique(&self, param: TagOnFileWhereParam) -> TagOnFileFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "TagOnFile".into(),
            outputs: tag_on_file_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        TagOnFileFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<TagOnFileWhereParam>) -> TagOnFileFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "TagOnFile".into(),
            outputs: tag_on_file_outputs(),
            inputs,
        };
        TagOnFileFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<TagOnFileWhereParam>) -> TagOnFileFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "TagOnFile".into(),
            outputs: tag_on_file_outputs(),
            inputs,
        };
        TagOnFileFindMany { query }
    }
    pub fn create_one(
        &self,
        tag: TagOnFileLinkTag,
        file: TagOnFileLinkFile,
        params: Vec<TagOnFileSetParam>,
    ) -> TagOnFileCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(TagOnFileSetParam::from(tag).field());
        input_fields.push(TagOnFileSetParam::from(file).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "TagOnFile".into(),
            outputs: tag_on_file_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        TagOnFileCreateOne { query }
    }
}
fn job_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("client_id"),
        Output::new("action"),
        Output::new("status"),
        Output::new("percentage_complete"),
        Output::new("task_count"),
        Output::new("completed_task_count"),
        Output::new("date_created"),
        Output::new("date_modified"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JobData {
    #[serde(rename = "id")]
    pub id: i64,
    #[serde(rename = "client_id")]
    pub client_id: i64,
    #[serde(rename = "action")]
    pub action: i64,
    #[serde(rename = "status")]
    pub status: i64,
    #[serde(rename = "percentage_complete")]
    pub percentage_complete: i64,
    #[serde(rename = "task_count")]
    pub task_count: i64,
    #[serde(rename = "completed_task_count")]
    pub completed_task_count: i64,
    #[serde(rename = "date_created")]
    pub date_created: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "date_modified")]
    pub date_modified: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "clients")]
    clients: Box<Option<ClientData>>,
}
impl JobData {
    pub fn clients(&self) -> Result<&ClientData, String> {
        match self.clients.as_ref() {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access clients but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct Job;
impl Job {
    pub fn id() -> JobIdField {
        JobIdField {}
    }
    pub fn client_id() -> JobClientIdField {
        JobClientIdField {}
    }
    pub fn action() -> JobActionField {
        JobActionField {}
    }
    pub fn status() -> JobStatusField {
        JobStatusField {}
    }
    pub fn percentage_complete() -> JobPercentageCompleteField {
        JobPercentageCompleteField {}
    }
    pub fn task_count() -> JobTaskCountField {
        JobTaskCountField {}
    }
    pub fn completed_task_count() -> JobCompletedTaskCountField {
        JobCompletedTaskCountField {}
    }
    pub fn date_created() -> JobDateCreatedField {
        JobDateCreatedField {}
    }
    pub fn date_modified() -> JobDateModifiedField {
        JobDateModifiedField {}
    }
    pub fn clients() -> JobClientsField {
        JobClientsField {}
    }
    pub fn not(params: Vec<JobWhereParam>) -> JobWhereParam {
        JobWhereParam::Not(params)
    }
    pub fn or(params: Vec<JobWhereParam>) -> JobWhereParam {
        JobWhereParam::Or(params)
    }
    pub fn and(params: Vec<JobWhereParam>) -> JobWhereParam {
        JobWhereParam::And(params)
    }
}
pub struct JobIdField {}
pub struct JobSetId(i64);
impl From<JobSetId> for JobSetParam {
    fn from(value: JobSetId) -> Self {
        Self::Id(value.0)
    }
}
impl JobIdField {
    pub fn lt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::IdLT(value)
    }
    pub fn gt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::IdGT(value)
    }
    pub fn lte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::IdLTE(value)
    }
    pub fn gte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::IdGTE(value)
    }
    pub fn equals(&self, value: i64) -> JobWhereParam {
        JobWhereParam::IdEquals(value)
    }
    pub fn set<T: From<JobSetId>>(&self, value: i64) -> T {
        JobSetId(value).into()
    }
}
pub struct JobClientIdField {}
pub struct JobSetClientId(i64);
impl From<JobSetClientId> for JobSetParam {
    fn from(value: JobSetClientId) -> Self {
        Self::ClientId(value.0)
    }
}
impl JobClientIdField {
    pub fn lt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::ClientIdLT(value)
    }
    pub fn gt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::ClientIdGT(value)
    }
    pub fn lte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::ClientIdLTE(value)
    }
    pub fn gte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::ClientIdGTE(value)
    }
    pub fn equals(&self, value: i64) -> JobWhereParam {
        JobWhereParam::ClientIdEquals(value)
    }
    pub fn set<T: From<JobSetClientId>>(&self, value: i64) -> T {
        JobSetClientId(value).into()
    }
}
pub struct JobActionField {}
pub struct JobSetAction(i64);
impl From<JobSetAction> for JobSetParam {
    fn from(value: JobSetAction) -> Self {
        Self::Action(value.0)
    }
}
impl JobActionField {
    pub fn lt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::ActionLT(value)
    }
    pub fn gt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::ActionGT(value)
    }
    pub fn lte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::ActionLTE(value)
    }
    pub fn gte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::ActionGTE(value)
    }
    pub fn equals(&self, value: i64) -> JobWhereParam {
        JobWhereParam::ActionEquals(value)
    }
    pub fn set<T: From<JobSetAction>>(&self, value: i64) -> T {
        JobSetAction(value).into()
    }
}
pub struct JobStatusField {}
pub struct JobSetStatus(i64);
impl From<JobSetStatus> for JobSetParam {
    fn from(value: JobSetStatus) -> Self {
        Self::Status(value.0)
    }
}
impl JobStatusField {
    pub fn lt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::StatusLT(value)
    }
    pub fn gt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::StatusGT(value)
    }
    pub fn lte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::StatusLTE(value)
    }
    pub fn gte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::StatusGTE(value)
    }
    pub fn equals(&self, value: i64) -> JobWhereParam {
        JobWhereParam::StatusEquals(value)
    }
    pub fn set<T: From<JobSetStatus>>(&self, value: i64) -> T {
        JobSetStatus(value).into()
    }
}
pub struct JobPercentageCompleteField {}
pub struct JobSetPercentageComplete(i64);
impl From<JobSetPercentageComplete> for JobSetParam {
    fn from(value: JobSetPercentageComplete) -> Self {
        Self::PercentageComplete(value.0)
    }
}
impl JobPercentageCompleteField {
    pub fn lt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::PercentageCompleteLT(value)
    }
    pub fn gt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::PercentageCompleteGT(value)
    }
    pub fn lte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::PercentageCompleteLTE(value)
    }
    pub fn gte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::PercentageCompleteGTE(value)
    }
    pub fn equals(&self, value: i64) -> JobWhereParam {
        JobWhereParam::PercentageCompleteEquals(value)
    }
    pub fn set<T: From<JobSetPercentageComplete>>(&self, value: i64) -> T {
        JobSetPercentageComplete(value).into()
    }
}
pub struct JobTaskCountField {}
pub struct JobSetTaskCount(i64);
impl From<JobSetTaskCount> for JobSetParam {
    fn from(value: JobSetTaskCount) -> Self {
        Self::TaskCount(value.0)
    }
}
impl JobTaskCountField {
    pub fn lt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::TaskCountLT(value)
    }
    pub fn gt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::TaskCountGT(value)
    }
    pub fn lte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::TaskCountLTE(value)
    }
    pub fn gte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::TaskCountGTE(value)
    }
    pub fn equals(&self, value: i64) -> JobWhereParam {
        JobWhereParam::TaskCountEquals(value)
    }
    pub fn set<T: From<JobSetTaskCount>>(&self, value: i64) -> T {
        JobSetTaskCount(value).into()
    }
}
pub struct JobCompletedTaskCountField {}
pub struct JobSetCompletedTaskCount(i64);
impl From<JobSetCompletedTaskCount> for JobSetParam {
    fn from(value: JobSetCompletedTaskCount) -> Self {
        Self::CompletedTaskCount(value.0)
    }
}
impl JobCompletedTaskCountField {
    pub fn lt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::CompletedTaskCountLT(value)
    }
    pub fn gt(&self, value: i64) -> JobWhereParam {
        JobWhereParam::CompletedTaskCountGT(value)
    }
    pub fn lte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::CompletedTaskCountLTE(value)
    }
    pub fn gte(&self, value: i64) -> JobWhereParam {
        JobWhereParam::CompletedTaskCountGTE(value)
    }
    pub fn equals(&self, value: i64) -> JobWhereParam {
        JobWhereParam::CompletedTaskCountEquals(value)
    }
    pub fn set<T: From<JobSetCompletedTaskCount>>(&self, value: i64) -> T {
        JobSetCompletedTaskCount(value).into()
    }
}
pub struct JobDateCreatedField {}
pub struct JobSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<JobSetDateCreated> for JobSetParam {
    fn from(value: JobSetDateCreated) -> Self {
        Self::DateCreated(value.0)
    }
}
impl JobDateCreatedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
        JobWhereParam::DateCreatedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
        JobWhereParam::DateCreatedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
        JobWhereParam::DateCreatedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
        JobWhereParam::DateCreatedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
        JobWhereParam::DateCreatedEquals(value)
    }
    pub fn set<T: From<JobSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        JobSetDateCreated(value).into()
    }
}
pub struct JobDateModifiedField {}
pub struct JobSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<JobSetDateModified> for JobSetParam {
    fn from(value: JobSetDateModified) -> Self {
        Self::DateModified(value.0)
    }
}
impl JobDateModifiedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
        JobWhereParam::DateModifiedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
        JobWhereParam::DateModifiedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
        JobWhereParam::DateModifiedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
        JobWhereParam::DateModifiedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
        JobWhereParam::DateModifiedEquals(value)
    }
    pub fn set<T: From<JobSetDateModified>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        JobSetDateModified(value).into()
    }
}
pub struct JobClientsField {}
pub struct JobLinkClients(ClientWhereParam);
impl From<JobLinkClients> for JobSetParam {
    fn from(value: JobLinkClients) -> Self {
        Self::LinkClients(value.0)
    }
}
impl JobClientsField {
    pub fn is(&self, value: Vec<ClientWhereParam>) -> JobWhereParam {
        JobWhereParam::ClientsIs(value)
    }
    pub fn link<T: From<JobLinkClients>>(&self, value: ClientWhereParam) -> T {
        JobLinkClients(value).into()
    }
    pub fn fetch(&self) -> JobWith {
        JobWithParam::Clients.into()
    }
}
pub enum JobWhereParam {
    IdLT(i64),
    IdGT(i64),
    IdLTE(i64),
    IdGTE(i64),
    IdEquals(i64),
    ClientIdLT(i64),
    ClientIdGT(i64),
    ClientIdLTE(i64),
    ClientIdGTE(i64),
    ClientIdEquals(i64),
    ActionLT(i64),
    ActionGT(i64),
    ActionLTE(i64),
    ActionGTE(i64),
    ActionEquals(i64),
    StatusLT(i64),
    StatusGT(i64),
    StatusLTE(i64),
    StatusGTE(i64),
    StatusEquals(i64),
    PercentageCompleteLT(i64),
    PercentageCompleteGT(i64),
    PercentageCompleteLTE(i64),
    PercentageCompleteGTE(i64),
    PercentageCompleteEquals(i64),
    TaskCountLT(i64),
    TaskCountGT(i64),
    TaskCountLTE(i64),
    TaskCountGTE(i64),
    TaskCountEquals(i64),
    CompletedTaskCountLT(i64),
    CompletedTaskCountGT(i64),
    CompletedTaskCountLTE(i64),
    CompletedTaskCountGTE(i64),
    CompletedTaskCountEquals(i64),
    DateCreatedBefore(chrono::DateTime<chrono::Utc>),
    DateCreatedAfter(chrono::DateTime<chrono::Utc>),
    DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedBefore(chrono::DateTime<chrono::Utc>),
    DateModifiedAfter(chrono::DateTime<chrono::Utc>),
    DateModifiedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedEquals(chrono::DateTime<chrono::Utc>),
    ClientsIs(Vec<ClientWhereParam>),
    Not(Vec<JobWhereParam>),
    Or(Vec<JobWhereParam>),
    And(Vec<JobWhereParam>),
}
impl JobWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdLT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdLTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ClientIdLT(value) => Field {
                name: "client_id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ClientIdGT(value) => Field {
                name: "client_id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ClientIdLTE(value) => Field {
                name: "client_id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ClientIdGTE(value) => Field {
                name: "client_id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ClientIdEquals(value) => Field {
                name: "client_id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ActionLT(value) => Field {
                name: "action".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ActionGT(value) => Field {
                name: "action".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ActionLTE(value) => Field {
                name: "action".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ActionGTE(value) => Field {
                name: "action".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ActionEquals(value) => Field {
                name: "action".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusLT(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusGT(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusLTE(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusGTE(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusEquals(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PercentageCompleteLT(value) => Field {
                name: "percentage_complete".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PercentageCompleteGT(value) => Field {
                name: "percentage_complete".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PercentageCompleteLTE(value) => Field {
                name: "percentage_complete".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PercentageCompleteGTE(value) => Field {
                name: "percentage_complete".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PercentageCompleteEquals(value) => Field {
                name: "percentage_complete".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TaskCountLT(value) => Field {
                name: "task_count".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TaskCountGT(value) => Field {
                name: "task_count".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TaskCountLTE(value) => Field {
                name: "task_count".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TaskCountGTE(value) => Field {
                name: "task_count".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TaskCountEquals(value) => Field {
                name: "task_count".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CompletedTaskCountLT(value) => Field {
                name: "completed_task_count".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CompletedTaskCountGT(value) => Field {
                name: "completed_task_count".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CompletedTaskCountLTE(value) => Field {
                name: "completed_task_count".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CompletedTaskCountGTE(value) => Field {
                name: "completed_task_count".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CompletedTaskCountEquals(value) => Field {
                name: "completed_task_count".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBefore(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfter(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBeforeEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfterEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedBefore(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedAfter(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedBeforeEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedAfterEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ClientsIs(value) => Field {
                name: "clients".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct JobWith {
    pub param: JobWithParam,
}
pub enum JobWithParam {
    Clients,
}
impl From<JobWithParam> for JobWith {
    fn from(param: JobWithParam) -> Self {
        Self { param }
    }
}
impl JobWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Clients => Output {
                name: "clients".into(),
                outputs: client_outputs(),
                ..Default::default()
            },
        }
    }
}
pub enum JobSetParam {
    Id(i64),
    ClientId(i64),
    Action(i64),
    Status(i64),
    PercentageComplete(i64),
    TaskCount(i64),
    CompletedTaskCount(i64),
    DateCreated(chrono::DateTime<chrono::Utc>),
    DateModified(chrono::DateTime<chrono::Utc>),
    LinkClients(ClientWhereParam),
}
impl JobSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::ClientId(value) => Field {
                name: "client_id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Action(value) => Field {
                name: "action".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Status(value) => Field {
                name: "status".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::PercentageComplete(value) => Field {
                name: "percentage_complete".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::TaskCount(value) => Field {
                name: "task_count".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::CompletedTaskCount(value) => Field {
                name: "completed_task_count".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateCreated(value) => Field {
                name: "date_created".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateModified(value) => Field {
                name: "date_modified".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkClients(where_param) => Field {
                name: "clients".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub struct JobFindMany<'a> {
    query: Query<'a>,
}
impl<'a> JobFindMany<'a> {
    pub async fn exec(self) -> Vec<JobData> {
        self.query.perform::<Vec<JobData>>().await.unwrap()
    }
    pub fn delete(self) -> JobDelete<'a> {
        JobDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "Job".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<JobSetParam>) -> JobUpdateMany<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        JobUpdateMany {
            query: Query {
                operation: "mutation".into(),
                method: "updateMany".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<JobWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct JobFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> JobFindFirst<'a> {
    pub async fn exec(self) -> Option<JobData> {
        self.query.perform::<Option<JobData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<JobWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct JobFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> JobFindUnique<'a> {
    pub async fn exec(self) -> Option<JobData> {
        self.query.perform::<Option<JobData>>().await.unwrap()
    }
    pub fn delete(self) -> JobDelete<'a> {
        JobDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "Job".into(),
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<JobSetParam>) -> JobUpdateUnique<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        JobUpdateUnique {
            query: Query {
                operation: "mutation".into(),
                method: "updateOne".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<JobWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct JobCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> JobCreateOne<'a> {
    pub async fn exec(self) -> JobData {
        self.query.perform::<JobData>().await.unwrap()
    }
}
pub struct JobUpdateUnique<'a> {
    query: Query<'a>,
}
impl<'a> JobUpdateUnique<'a> {
    pub async fn exec(self) -> JobData {
        self.query.perform::<JobData>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<JobWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct JobUpdateMany<'a> {
    query: Query<'a>,
}
impl<'a> JobUpdateMany<'a> {
    pub async fn exec(self) -> Vec<JobData> {
        self.query.perform::<Vec<JobData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<JobWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct JobDelete<'a> {
    query: Query<'a>,
}
impl<'a> JobDelete<'a> {
    pub async fn exec(self) -> isize {
        self.query.perform::<DeleteResult>().await.unwrap().count
    }
}
pub struct JobActions<'a> {
    client: &'a PrismaClient,
}
impl<'a> JobActions<'a> {
    pub fn find_unique(&self, param: JobWhereParam) -> JobFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "Job".into(),
            outputs: job_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        JobFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<JobWhereParam>) -> JobFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "Job".into(),
            outputs: job_outputs(),
            inputs,
        };
        JobFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<JobWhereParam>) -> JobFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "Job".into(),
            outputs: job_outputs(),
            inputs,
        };
        JobFindMany { query }
    }
    pub fn create_one(
        &self,
        action: JobSetAction,
        clients: JobLinkClients,
        params: Vec<JobSetParam>,
    ) -> JobCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(JobSetParam::from(action).field());
        input_fields.push(JobSetParam::from(clients).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "Job".into(),
            outputs: job_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        JobCreateOne { query }
    }
}
fn space_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("name"),
        Output::new("encryption"),
        Output::new("date_created"),
        Output::new("date_modified"),
        Output::new("libraryId"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpaceData {
    #[serde(rename = "id")]
    pub id: i64,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "encryption")]
    pub encryption: Option<i64>,
    #[serde(rename = "date_created")]
    pub date_created: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "date_modified")]
    pub date_modified: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "Library")]
    pub library: Box<Option<LibraryData>>,
    #[serde(rename = "libraryId")]
    pub library_id: Option<i64>,
}
impl SpaceData {
    pub fn library(&self) -> Option<&LibraryData> {
        self.library.as_ref().as_ref()
    }
}
pub struct Space;
impl Space {
    pub fn id() -> SpaceIdField {
        SpaceIdField {}
    }
    pub fn name() -> SpaceNameField {
        SpaceNameField {}
    }
    pub fn encryption() -> SpaceEncryptionField {
        SpaceEncryptionField {}
    }
    pub fn date_created() -> SpaceDateCreatedField {
        SpaceDateCreatedField {}
    }
    pub fn date_modified() -> SpaceDateModifiedField {
        SpaceDateModifiedField {}
    }
    pub fn library() -> SpaceLibraryField {
        SpaceLibraryField {}
    }
    pub fn library_id() -> SpaceLibraryIdField {
        SpaceLibraryIdField {}
    }
    pub fn not(params: Vec<SpaceWhereParam>) -> SpaceWhereParam {
        SpaceWhereParam::Not(params)
    }
    pub fn or(params: Vec<SpaceWhereParam>) -> SpaceWhereParam {
        SpaceWhereParam::Or(params)
    }
    pub fn and(params: Vec<SpaceWhereParam>) -> SpaceWhereParam {
        SpaceWhereParam::And(params)
    }
}
pub struct SpaceIdField {}
pub struct SpaceSetId(i64);
impl From<SpaceSetId> for SpaceSetParam {
    fn from(value: SpaceSetId) -> Self {
        Self::Id(value.0)
    }
}
impl SpaceIdField {
    pub fn lt(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::IdLT(value)
    }
    pub fn gt(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::IdGT(value)
    }
    pub fn lte(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::IdLTE(value)
    }
    pub fn gte(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::IdGTE(value)
    }
    pub fn equals(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::IdEquals(value)
    }
    pub fn set<T: From<SpaceSetId>>(&self, value: i64) -> T {
        SpaceSetId(value).into()
    }
}
pub struct SpaceNameField {}
pub struct SpaceSetName(String);
impl From<SpaceSetName> for SpaceSetParam {
    fn from(value: SpaceSetName) -> Self {
        Self::Name(value.0)
    }
}
impl SpaceNameField {
    pub fn contains(&self, value: String) -> SpaceWhereParam {
        SpaceWhereParam::NameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> SpaceWhereParam {
        SpaceWhereParam::NameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> SpaceWhereParam {
        SpaceWhereParam::NameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> SpaceWhereParam {
        SpaceWhereParam::NameEquals(value)
    }
    pub fn set<T: From<SpaceSetName>>(&self, value: String) -> T {
        SpaceSetName(value).into()
    }
}
pub struct SpaceEncryptionField {}
pub struct SpaceSetEncryption(i64);
impl From<SpaceSetEncryption> for SpaceSetParam {
    fn from(value: SpaceSetEncryption) -> Self {
        Self::Encryption(value.0)
    }
}
impl SpaceEncryptionField {
    pub fn lt(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::EncryptionLT(value)
    }
    pub fn gt(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::EncryptionGT(value)
    }
    pub fn lte(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::EncryptionLTE(value)
    }
    pub fn gte(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::EncryptionGTE(value)
    }
    pub fn equals(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::EncryptionEquals(value)
    }
    pub fn set<T: From<SpaceSetEncryption>>(&self, value: i64) -> T {
        SpaceSetEncryption(value).into()
    }
}
pub struct SpaceDateCreatedField {}
pub struct SpaceSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<SpaceSetDateCreated> for SpaceSetParam {
    fn from(value: SpaceSetDateCreated) -> Self {
        Self::DateCreated(value.0)
    }
}
impl SpaceDateCreatedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
        SpaceWhereParam::DateCreatedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
        SpaceWhereParam::DateCreatedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
        SpaceWhereParam::DateCreatedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
        SpaceWhereParam::DateCreatedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
        SpaceWhereParam::DateCreatedEquals(value)
    }
    pub fn set<T: From<SpaceSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        SpaceSetDateCreated(value).into()
    }
}
pub struct SpaceDateModifiedField {}
pub struct SpaceSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<SpaceSetDateModified> for SpaceSetParam {
    fn from(value: SpaceSetDateModified) -> Self {
        Self::DateModified(value.0)
    }
}
impl SpaceDateModifiedField {
    pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
        SpaceWhereParam::DateModifiedBefore(value)
    }
    pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
        SpaceWhereParam::DateModifiedAfter(value)
    }
    pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
        SpaceWhereParam::DateModifiedBeforeEquals(value)
    }
    pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
        SpaceWhereParam::DateModifiedAfterEquals(value)
    }
    pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
        SpaceWhereParam::DateModifiedEquals(value)
    }
    pub fn set<T: From<SpaceSetDateModified>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
        SpaceSetDateModified(value).into()
    }
}
pub struct SpaceLibraryField {}
pub struct SpaceLinkLibrary(LibraryWhereParam);
impl From<SpaceLinkLibrary> for SpaceSetParam {
    fn from(value: SpaceLinkLibrary) -> Self {
        Self::LinkLibrary(value.0)
    }
}
impl SpaceLibraryField {
    pub fn is(&self, value: Vec<LibraryWhereParam>) -> SpaceWhereParam {
        SpaceWhereParam::LibraryIs(value)
    }
    pub fn link<T: From<SpaceLinkLibrary>>(&self, value: LibraryWhereParam) -> T {
        SpaceLinkLibrary(value).into()
    }
    pub fn fetch(&self) -> SpaceWith {
        SpaceWithParam::Library.into()
    }
    pub fn unlink(&self) -> SpaceSetParam {
        SpaceSetParam::UnlinkLibrary
    }
}
pub struct SpaceLibraryIdField {}
pub struct SpaceSetLibraryId(i64);
impl From<SpaceSetLibraryId> for SpaceSetParam {
    fn from(value: SpaceSetLibraryId) -> Self {
        Self::LibraryId(value.0)
    }
}
impl SpaceLibraryIdField {
    pub fn lt(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::LibraryIdLT(value)
    }
    pub fn gt(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::LibraryIdGT(value)
    }
    pub fn lte(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::LibraryIdLTE(value)
    }
    pub fn gte(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::LibraryIdGTE(value)
    }
    pub fn equals(&self, value: i64) -> SpaceWhereParam {
        SpaceWhereParam::LibraryIdEquals(value)
    }
    pub fn set<T: From<SpaceSetLibraryId>>(&self, value: i64) -> T {
        SpaceSetLibraryId(value).into()
    }
}
pub enum SpaceWhereParam {
    IdLT(i64),
    IdGT(i64),
    IdLTE(i64),
    IdGTE(i64),
    IdEquals(i64),
    NameContains(String),
    NameHasPrefix(String),
    NameHasSuffix(String),
    NameEquals(String),
    EncryptionLT(i64),
    EncryptionGT(i64),
    EncryptionLTE(i64),
    EncryptionGTE(i64),
    EncryptionEquals(i64),
    DateCreatedBefore(chrono::DateTime<chrono::Utc>),
    DateCreatedAfter(chrono::DateTime<chrono::Utc>),
    DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateCreatedEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedBefore(chrono::DateTime<chrono::Utc>),
    DateModifiedAfter(chrono::DateTime<chrono::Utc>),
    DateModifiedBeforeEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedAfterEquals(chrono::DateTime<chrono::Utc>),
    DateModifiedEquals(chrono::DateTime<chrono::Utc>),
    LibraryIs(Vec<LibraryWhereParam>),
    LibraryIdLT(i64),
    LibraryIdGT(i64),
    LibraryIdLTE(i64),
    LibraryIdGTE(i64),
    LibraryIdEquals(i64),
    Not(Vec<SpaceWhereParam>),
    Or(Vec<SpaceWhereParam>),
    And(Vec<SpaceWhereParam>),
}
impl SpaceWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdLT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGT(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdLTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdGTE(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameContains(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasPrefix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasSuffix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameEquals(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionLT(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionGT(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionLTE(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionGTE(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::EncryptionEquals(value) => Field {
                name: "encryption".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBefore(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfter(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedBeforeEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedAfterEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateCreatedEquals(value) => Field {
                name: "date_created".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedBefore(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedAfter(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedBeforeEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedAfterEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DateModifiedEquals(value) => Field {
                name: "date_modified".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LibraryIs(value) => Field {
                name: "Library".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LibraryIdLT(value) => Field {
                name: "libraryId".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LibraryIdGT(value) => Field {
                name: "libraryId".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LibraryIdLTE(value) => Field {
                name: "libraryId".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LibraryIdGTE(value) => Field {
                name: "libraryId".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LibraryIdEquals(value) => Field {
                name: "libraryId".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct SpaceWith {
    pub param: SpaceWithParam,
}
pub enum SpaceWithParam {
    Library,
}
impl From<SpaceWithParam> for SpaceWith {
    fn from(param: SpaceWithParam) -> Self {
        Self { param }
    }
}
impl SpaceWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Library => Output {
                name: "Library".into(),
                outputs: library_outputs(),
                ..Default::default()
            },
        }
    }
}
pub enum SpaceSetParam {
    Id(i64),
    Name(String),
    Encryption(i64),
    DateCreated(chrono::DateTime<chrono::Utc>),
    DateModified(chrono::DateTime<chrono::Utc>),
    LinkLibrary(LibraryWhereParam),
    UnlinkLibrary,
    LibraryId(i64),
}
impl SpaceSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Name(value) => Field {
                name: "name".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Encryption(value) => Field {
                name: "encryption".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateCreated(value) => Field {
                name: "date_created".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DateModified(value) => Field {
                name: "date_modified".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkLibrary(where_param) => Field {
                name: "Library".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UnlinkLibrary => Field {
                name: "Library".into(),
                fields: Some(vec![Field {
                    name: "disconnect".into(),
                    value: Some(true.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::LibraryId(value) => Field {
                name: "libraryId".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
        }
    }
}
pub struct SpaceFindMany<'a> {
    query: Query<'a>,
}
impl<'a> SpaceFindMany<'a> {
    pub async fn exec(self) -> Vec<SpaceData> {
        self.query.perform::<Vec<SpaceData>>().await.unwrap()
    }
    pub fn delete(self) -> SpaceDelete<'a> {
        SpaceDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "Space".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<SpaceSetParam>) -> SpaceUpdateMany<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        SpaceUpdateMany {
            query: Query {
                operation: "mutation".into(),
                method: "updateMany".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<SpaceWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct SpaceFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> SpaceFindFirst<'a> {
    pub async fn exec(self) -> Option<SpaceData> {
        self.query.perform::<Option<SpaceData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<SpaceWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct SpaceFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> SpaceFindUnique<'a> {
    pub async fn exec(self) -> Option<SpaceData> {
        self.query.perform::<Option<SpaceData>>().await.unwrap()
    }
    pub fn delete(self) -> SpaceDelete<'a> {
        SpaceDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "Space".into(),
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<SpaceSetParam>) -> SpaceUpdateUnique<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        SpaceUpdateUnique {
            query: Query {
                operation: "mutation".into(),
                method: "updateOne".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<SpaceWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct SpaceCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> SpaceCreateOne<'a> {
    pub async fn exec(self) -> SpaceData {
        self.query.perform::<SpaceData>().await.unwrap()
    }
}
pub struct SpaceUpdateUnique<'a> {
    query: Query<'a>,
}
impl<'a> SpaceUpdateUnique<'a> {
    pub async fn exec(self) -> SpaceData {
        self.query.perform::<SpaceData>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<SpaceWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct SpaceUpdateMany<'a> {
    query: Query<'a>,
}
impl<'a> SpaceUpdateMany<'a> {
    pub async fn exec(self) -> Vec<SpaceData> {
        self.query.perform::<Vec<SpaceData>>().await.unwrap()
    }
    pub fn with(mut self, fetches: Vec<SpaceWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct SpaceDelete<'a> {
    query: Query<'a>,
}
impl<'a> SpaceDelete<'a> {
    pub async fn exec(self) -> isize {
        self.query.perform::<DeleteResult>().await.unwrap().count
    }
}
pub struct SpaceActions<'a> {
    client: &'a PrismaClient,
}
impl<'a> SpaceActions<'a> {
    pub fn find_unique(&self, param: SpaceWhereParam) -> SpaceFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "Space".into(),
            outputs: space_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        SpaceFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<SpaceWhereParam>) -> SpaceFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "Space".into(),
            outputs: space_outputs(),
            inputs,
        };
        SpaceFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<SpaceWhereParam>) -> SpaceFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "Space".into(),
            outputs: space_outputs(),
            inputs,
        };
        SpaceFindMany { query }
    }
    pub fn create_one(&self, name: SpaceSetName, params: Vec<SpaceSetParam>) -> SpaceCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(SpaceSetParam::from(name).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "Space".into(),
            outputs: space_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        SpaceCreateOne { query }
    }
}
