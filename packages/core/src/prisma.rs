// Code generated by Prisma Client Rust. DO NOT EDIT.

use prisma_client_rust::datamodel::parse_configuration;
use prisma_client_rust::prisma_models::InternalDataModelBuilder;
use prisma_client_rust::query::*;
use prisma_client_rust::query_core::{executor, schema_builder, BuildMode, CoreError, QueryExecutor, QuerySchema};
use prisma_client_rust::{chrono, operator::Operator, serde_json, DeleteResult};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
pub struct PrismaClient {
	executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
	query_schema: Arc<QuerySchema>,
}
pub async fn new_client() -> PrismaClient {
	let datamodel_str = "datasource db {\n    provider = \"sqlite\"\n    url      = \"file:dev.db\"\n}\n\ngenerator client {\n    provider = \"prisma-client-rust\"\n    output   = \"../src/prisma.rs\"\n}\n\nmodel Migration {\n    id            Int      @id @default(autoincrement())\n    name          String\n    checksum      String   @unique\n    steps_applied Int      @default(0)\n    applied_at    DateTime @default(now())\n\n    @@map(\"_migrations\")\n}\n\nmodel Library {\n    id           Int      @id @default(autoincrement())\n    uuid         String   @unique\n    name         String\n    remote_id    String?\n    is_primary   Boolean  @default(true)\n    encryption   Int      @default(0)\n    date_created DateTime @default(now())\n    timezone     String?\n    spaces       Space[]\n\n    @@map(\"libraries\")\n}\n\nmodel LibraryStatistics {\n    id                  Int      @id @default(autoincrement())\n    date_captured       DateTime @default(now())\n    library_id          Int      @unique\n    total_file_count    Int      @default(0)\n    total_bytes_used    String   @default(\"0\")\n    total_byte_capacity String   @default(\"0\")\n    total_unique_bytes  String   @default(\"0\")\n\n    @@map(\"library_statistics\")\n}\n\nmodel Client {\n    id           Int      @id @default(autoincrement())\n    uuid         String   @unique\n    name         String\n    platform     Int      @default(0)\n    version      String?\n    online       Boolean? @default(true)\n    last_seen    DateTime @default(now())\n    timezone     String?\n    date_created DateTime @default(now())\n    // jobs         Job[]\n\n    @@map(\"clients\")\n}\n\nmodel Location {\n    id                 Int      @id @default(autoincrement())\n    name               String?\n    local_path         String?\n    total_capacity     Int?\n    available_capacity Int?\n    filesystem         String?\n    disk_type          Int?\n    is_removable       Boolean  @default(true)\n    is_ejectable       Boolean  @default(true)\n    is_root_filesystem Boolean  @default(true)\n    is_online          Boolean  @default(true)\n    date_created       DateTime @default(now())\n\n    file_paths FilePath[]\n    @@map(\"locations\")\n}\n\nmodel File {\n    id            Int      @id @default(autoincrement())\n    id_hash       String   @unique\n    name          String\n    extension     String?\n    checksum      String?\n    size_in_bytes String\n    encryption    Int      @default(0)\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    date_indexed  DateTime @default(now())\n    ipfs_id       String?\n\n    file_tags   TagOnFile[]\n    file_labels LabelOnFile[]\n    file_paths  FilePath[]\n    comments    Comment[]\n    @@map(\"files\")\n}\n\nmodel FilePath {\n    id                Int        @id @default(autoincrement())\n    is_dir            Boolean    @default(false)\n    materialized_path String\n    file_id           Int?\n    file              File?      @relation(fields: [file_id], references: [id], onDelete: Cascade, onUpdate: Cascade)\n    parent_id         Int?\n    parent            FilePath?  @relation(\"directory_file_paths\", fields: [parent_id], references: [id])\n    children          FilePath[] @relation(\"directory_file_paths\")\n    location_id       Int\n    location          Location?  @relation(fields: [location_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n    date_indexed      DateTime   @default(now())\n    permissions       String?\n\n    @@unique([location_id, materialized_path, file_id])\n    @@map(\"file_paths\")\n}\n\nmodel Tag {\n    id              Int      @id @default(autoincrement())\n    name            String?\n    encryption      Int?     @default(0)\n    total_files     Int?     @default(0)\n    redundancy_goal Int?     @default(1)\n    date_created    DateTime @default(now())\n    date_modified   DateTime @default(now())\n\n    tag_files TagOnFile[]\n    @@map(\"tags\")\n}\n\nmodel TagOnFile {\n    date_created DateTime @default(now())\n\n    tag_id Int\n    tag    Tag @relation(fields: [tag_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    file_id Int\n    file    File @relation(fields: [file_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@id([tag_id, file_id])\n    @@map(\"tags_on_files\")\n}\n\nmodel Label {\n    id            Int      @id @default(autoincrement())\n    name          String?\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n\n    label_files LabelOnFile[]\n    @@map(\"labels\")\n}\n\nmodel LabelOnFile {\n    date_created DateTime @default(now())\n\n    label_id Int\n    label    Label @relation(fields: [label_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    file_id Int\n    file    File @relation(fields: [file_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@id([label_id, file_id])\n    @@map(\"label_on_files\")\n}\n\nmodel Job {\n    id     String @id\n    // client_id Int\n    action Int\n    status Int    @default(0)\n\n    task_count           Int      @default(1)\n    completed_task_count Int      @default(0)\n    date_created         DateTime @default(now())\n    date_modified        DateTime @default(now())\n    // clients              Client   @relation(fields: [client_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n    seconds_elapsed      Int      @default(0)\n\n    @@map(\"jobs\")\n}\n\nmodel Space {\n    id            Int      @id @default(autoincrement())\n    name          String\n    encryption    Int?     @default(0) // remove\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    Library       Library? @relation(fields: [libraryId], references: [id])\n    libraryId     Int?\n\n    @@map(\"spaces\")\n}\n\nmodel Album {\n    id        Int     @id @default(autoincrement())\n    name      String\n    is_hidden Boolean @default(false)\n\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n\n    @@map(\"albums\")\n}\n\nmodel Comment {\n    id            Int      @id @default(autoincrement())\n    content       String\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    file_id       Int?\n    file          File?    @relation(fields: [file_id], references: [id])\n\n    @@map(\"comments\")\n}\n" ;
	let config = parse_configuration(datamodel_str).unwrap().subject;
	let source = config
		.datasources
		.first()
		.expect("Pleasy supply a datasource in your schema.prisma file");
	let url = if let Some(url) = source.load_shadow_database_url().unwrap() {
		url
	} else {
		source.load_url(|key| std::env::var(key).ok()).unwrap()
	};
	let url = if url.starts_with("file:") {
		let path = url.split(":").nth(1).unwrap();
		if Path::new("./schema.prisma").exists() {
			url
		} else if Path::new("./prisma/schema.prisma").exists() {
			format!("file:./prisma/{}", path)
		} else {
			url
		}
	} else {
		url
	};
	new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> PrismaClient {
	let datamodel_str = "datasource db {\n    provider = \"sqlite\"\n    url      = \"file:dev.db\"\n}\n\ngenerator client {\n    provider = \"prisma-client-rust\"\n    output   = \"../src/prisma.rs\"\n}\n\nmodel Migration {\n    id            Int      @id @default(autoincrement())\n    name          String\n    checksum      String   @unique\n    steps_applied Int      @default(0)\n    applied_at    DateTime @default(now())\n\n    @@map(\"_migrations\")\n}\n\nmodel Library {\n    id           Int      @id @default(autoincrement())\n    uuid         String   @unique\n    name         String\n    remote_id    String?\n    is_primary   Boolean  @default(true)\n    encryption   Int      @default(0)\n    date_created DateTime @default(now())\n    timezone     String?\n    spaces       Space[]\n\n    @@map(\"libraries\")\n}\n\nmodel LibraryStatistics {\n    id                  Int      @id @default(autoincrement())\n    date_captured       DateTime @default(now())\n    library_id          Int      @unique\n    total_file_count    Int      @default(0)\n    total_bytes_used    String   @default(\"0\")\n    total_byte_capacity String   @default(\"0\")\n    total_unique_bytes  String   @default(\"0\")\n\n    @@map(\"library_statistics\")\n}\n\nmodel Client {\n    id           Int      @id @default(autoincrement())\n    uuid         String   @unique\n    name         String\n    platform     Int      @default(0)\n    version      String?\n    online       Boolean? @default(true)\n    last_seen    DateTime @default(now())\n    timezone     String?\n    date_created DateTime @default(now())\n    // jobs         Job[]\n\n    @@map(\"clients\")\n}\n\nmodel Location {\n    id                 Int      @id @default(autoincrement())\n    name               String?\n    local_path         String?\n    total_capacity     Int?\n    available_capacity Int?\n    filesystem         String?\n    disk_type          Int?\n    is_removable       Boolean  @default(true)\n    is_ejectable       Boolean  @default(true)\n    is_root_filesystem Boolean  @default(true)\n    is_online          Boolean  @default(true)\n    date_created       DateTime @default(now())\n\n    file_paths FilePath[]\n    @@map(\"locations\")\n}\n\nmodel File {\n    id            Int      @id @default(autoincrement())\n    id_hash       String   @unique\n    name          String\n    extension     String?\n    checksum      String?\n    size_in_bytes String\n    encryption    Int      @default(0)\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    date_indexed  DateTime @default(now())\n    ipfs_id       String?\n\n    file_tags   TagOnFile[]\n    file_labels LabelOnFile[]\n    file_paths  FilePath[]\n    comments    Comment[]\n    @@map(\"files\")\n}\n\nmodel FilePath {\n    id                Int        @id @default(autoincrement())\n    is_dir            Boolean    @default(false)\n    materialized_path String\n    file_id           Int?\n    file              File?      @relation(fields: [file_id], references: [id], onDelete: Cascade, onUpdate: Cascade)\n    parent_id         Int?\n    parent            FilePath?  @relation(\"directory_file_paths\", fields: [parent_id], references: [id])\n    children          FilePath[] @relation(\"directory_file_paths\")\n    location_id       Int\n    location          Location?  @relation(fields: [location_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n    date_indexed      DateTime   @default(now())\n    permissions       String?\n\n    @@unique([location_id, materialized_path, file_id])\n    @@map(\"file_paths\")\n}\n\nmodel Tag {\n    id              Int      @id @default(autoincrement())\n    name            String?\n    encryption      Int?     @default(0)\n    total_files     Int?     @default(0)\n    redundancy_goal Int?     @default(1)\n    date_created    DateTime @default(now())\n    date_modified   DateTime @default(now())\n\n    tag_files TagOnFile[]\n    @@map(\"tags\")\n}\n\nmodel TagOnFile {\n    date_created DateTime @default(now())\n\n    tag_id Int\n    tag    Tag @relation(fields: [tag_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    file_id Int\n    file    File @relation(fields: [file_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@id([tag_id, file_id])\n    @@map(\"tags_on_files\")\n}\n\nmodel Label {\n    id            Int      @id @default(autoincrement())\n    name          String?\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n\n    label_files LabelOnFile[]\n    @@map(\"labels\")\n}\n\nmodel LabelOnFile {\n    date_created DateTime @default(now())\n\n    label_id Int\n    label    Label @relation(fields: [label_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    file_id Int\n    file    File @relation(fields: [file_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@id([label_id, file_id])\n    @@map(\"label_on_files\")\n}\n\nmodel Job {\n    id     String @id\n    // client_id Int\n    action Int\n    status Int    @default(0)\n\n    task_count           Int      @default(1)\n    completed_task_count Int      @default(0)\n    date_created         DateTime @default(now())\n    date_modified        DateTime @default(now())\n    // clients              Client   @relation(fields: [client_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n    seconds_elapsed      Int      @default(0)\n\n    @@map(\"jobs\")\n}\n\nmodel Space {\n    id            Int      @id @default(autoincrement())\n    name          String\n    encryption    Int?     @default(0) // remove\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    Library       Library? @relation(fields: [libraryId], references: [id])\n    libraryId     Int?\n\n    @@map(\"spaces\")\n}\n\nmodel Album {\n    id        Int     @id @default(autoincrement())\n    name      String\n    is_hidden Boolean @default(false)\n\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n\n    @@map(\"albums\")\n}\n\nmodel Comment {\n    id            Int      @id @default(autoincrement())\n    content       String\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    file_id       Int?\n    file          File?    @relation(fields: [file_id], references: [id])\n\n    @@map(\"comments\")\n}\n" ;
	let config = parse_configuration(datamodel_str).unwrap().subject;
	let source = config
		.datasources
		.first()
		.expect("Pleasy supply a datasource in your schema.prisma file");
	let (db_name, executor) = executor::load(&source, &[], &url).await.unwrap();
	let internal_model = InternalDataModelBuilder::new(&datamodel_str).build(db_name);
	let query_schema = Arc::new(schema_builder::build(
		internal_model,
		BuildMode::Modern,
		true,
		source.capabilities(),
		vec![],
		source.referential_integrity(),
	));
	executor.primary_connector().get_connection().await.unwrap();
	PrismaClient { executor, query_schema }
}
impl PrismaClient {
	pub async fn _query_raw<T: serde::de::DeserializeOwned>(&self, query: &str) -> Result<Vec<T>, CoreError> {
		let query = Query {
			ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
			operation: "mutation".into(),
			method: "queryRaw".into(),
			inputs: vec![
				Input {
					name: "query".into(),
					value: Some(query.into()),
					..Default::default()
				},
				Input {
					name: "parameters".into(),
					value: Some("[]".into()),
					..Default::default()
				},
			],
			name: "".into(),
			model: "".into(),
			outputs: vec![],
		};
		query.perform().await
	}
	pub async fn _execute_raw(&self, query: &str) -> Result<i64, CoreError> {
		let query = Query {
			ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
			operation: "mutation".into(),
			method: "executeRaw".into(),
			inputs: vec![
				Input {
					name: "query".into(),
					value: Some(query.into()),
					..Default::default()
				},
				Input {
					name: "parameters".into(),
					value: Some("[]".into()),
					..Default::default()
				},
			],
			name: "".into(),
			model: "".into(),
			outputs: vec![],
		};
		query.perform().await.map(|result: i64| result)
	}
	pub fn migration(&self) -> MigrationActions {
		MigrationActions { client: &self }
	}
	pub fn library(&self) -> LibraryActions {
		LibraryActions { client: &self }
	}
	pub fn library_statistics(&self) -> LibraryStatisticsActions {
		LibraryStatisticsActions { client: &self }
	}
	pub fn client(&self) -> ClientActions {
		ClientActions { client: &self }
	}
	pub fn location(&self) -> LocationActions {
		LocationActions { client: &self }
	}
	pub fn file(&self) -> FileActions {
		FileActions { client: &self }
	}
	pub fn file_path(&self) -> FilePathActions {
		FilePathActions { client: &self }
	}
	pub fn tag(&self) -> TagActions {
		TagActions { client: &self }
	}
	pub fn tag_on_file(&self) -> TagOnFileActions {
		TagOnFileActions { client: &self }
	}
	pub fn label(&self) -> LabelActions {
		LabelActions { client: &self }
	}
	pub fn label_on_file(&self) -> LabelOnFileActions {
		LabelOnFileActions { client: &self }
	}
	pub fn job(&self) -> JobActions {
		JobActions { client: &self }
	}
	pub fn space(&self) -> SpaceActions {
		SpaceActions { client: &self }
	}
	pub fn album(&self) -> AlbumActions {
		AlbumActions { client: &self }
	}
	pub fn comment(&self) -> CommentActions {
		CommentActions { client: &self }
	}
}
fn migration_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("checksum"),
		Output::new("steps_applied"),
		Output::new("applied_at"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MigrationData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "checksum")]
	pub checksum: String,
	#[serde(rename = "steps_applied")]
	pub steps_applied: i64,
	#[serde(rename = "applied_at")]
	pub applied_at: chrono::DateTime<chrono::Utc>,
}
impl MigrationData {}
pub struct Migration;
impl Migration {
	pub fn id() -> MigrationIdField {
		MigrationIdField {}
	}
	pub fn name() -> MigrationNameField {
		MigrationNameField {}
	}
	pub fn checksum() -> MigrationChecksumField {
		MigrationChecksumField {}
	}
	pub fn steps_applied() -> MigrationStepsAppliedField {
		MigrationStepsAppliedField {}
	}
	pub fn applied_at() -> MigrationAppliedAtField {
		MigrationAppliedAtField {}
	}
}
pub struct MigrationIdField {}
pub struct MigrationSetId(i64);
impl From<MigrationSetId> for MigrationSetParam {
	fn from(value: MigrationSetId) -> Self {
		Self::Id(value.0)
	}
}
impl MigrationIdField {
	pub fn lt(&self, value: i64) -> MigrationWhereParam {
		MigrationWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> MigrationWhereParam {
		MigrationWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> MigrationWhereParam {
		MigrationWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> MigrationWhereParam {
		MigrationWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> MigrationWhereParam {
		MigrationWhereParam::IdEquals(value)
	}
	pub fn set<T: From<MigrationSetId>>(&self, value: i64) -> T {
		MigrationSetId(value).into()
	}
}
pub struct MigrationNameField {}
pub struct MigrationSetName(String);
impl From<MigrationSetName> for MigrationSetParam {
	fn from(value: MigrationSetName) -> Self {
		Self::Name(value.0)
	}
}
impl MigrationNameField {
	pub fn contains(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameContains(value)
	}
	pub fn has_prefix(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameEquals(value)
	}
	pub fn set<T: From<MigrationSetName>>(&self, value: String) -> T {
		MigrationSetName(value).into()
	}
}
pub struct MigrationChecksumField {}
pub struct MigrationSetChecksum(String);
impl From<MigrationSetChecksum> for MigrationSetParam {
	fn from(value: MigrationSetChecksum) -> Self {
		Self::Checksum(value.0)
	}
}
impl MigrationChecksumField {
	pub fn contains(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumContains(value)
	}
	pub fn has_prefix(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumEquals(value)
	}
	pub fn set<T: From<MigrationSetChecksum>>(&self, value: String) -> T {
		MigrationSetChecksum(value).into()
	}
}
pub struct MigrationStepsAppliedField {}
pub struct MigrationSetStepsApplied(i64);
impl From<MigrationSetStepsApplied> for MigrationSetParam {
	fn from(value: MigrationSetStepsApplied) -> Self {
		Self::StepsApplied(value.0)
	}
}
impl MigrationStepsAppliedField {
	pub fn lt(&self, value: i64) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedLT(value)
	}
	pub fn gt(&self, value: i64) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedGT(value)
	}
	pub fn lte(&self, value: i64) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedLTE(value)
	}
	pub fn gte(&self, value: i64) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedGTE(value)
	}
	pub fn equals(&self, value: i64) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedEquals(value)
	}
	pub fn set<T: From<MigrationSetStepsApplied>>(&self, value: i64) -> T {
		MigrationSetStepsApplied(value).into()
	}
}
pub struct MigrationAppliedAtField {}
pub struct MigrationSetAppliedAt(chrono::DateTime<chrono::Utc>);
impl From<MigrationSetAppliedAt> for MigrationSetParam {
	fn from(value: MigrationSetAppliedAt) -> Self {
		Self::AppliedAt(value.0)
	}
}
impl MigrationAppliedAtField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtEquals(value)
	}
	pub fn set<T: From<MigrationSetAppliedAt>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		MigrationSetAppliedAt(value).into()
	}
}
pub enum MigrationWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	NameContains(String),
	NameHasPrefix(String),
	NameHasSuffix(String),
	NameEquals(String),
	ChecksumContains(String),
	ChecksumHasPrefix(String),
	ChecksumHasSuffix(String),
	ChecksumEquals(String),
	StepsAppliedLT(i64),
	StepsAppliedGT(i64),
	StepsAppliedLTE(i64),
	StepsAppliedGTE(i64),
	StepsAppliedEquals(i64),
	AppliedAtBefore(chrono::DateTime<chrono::Utc>),
	AppliedAtAfter(chrono::DateTime<chrono::Utc>),
	AppliedAtBeforeEquals(chrono::DateTime<chrono::Utc>),
	AppliedAtAfterEquals(chrono::DateTime<chrono::Utc>),
	AppliedAtEquals(chrono::DateTime<chrono::Utc>),
	Not(Vec<MigrationWhereParam>),
	Or(Vec<MigrationWhereParam>),
	And(Vec<MigrationWhereParam>),
}
impl MigrationWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasPrefix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasSuffix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumContains(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumHasPrefix(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumHasSuffix(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumEquals(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedLT(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedGT(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedLTE(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedGTE(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedEquals(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtBefore(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtAfter(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtBeforeEquals(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtAfterEquals(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtEquals(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for MigrationWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct MigrationWith {
	pub param: MigrationWithParam,
}
pub enum MigrationWithParam {}
impl From<MigrationWithParam> for MigrationWith {
	fn from(param: MigrationWithParam) -> Self {
		Self { param }
	}
}
impl MigrationWithParam {
	pub fn output(self) -> Output {
		match self {}
	}
}
pub enum MigrationSetParam {
	Id(i64),
	Name(String),
	Checksum(String),
	StepsApplied(i64),
	AppliedAt(chrono::DateTime<chrono::Utc>),
}
impl MigrationSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Checksum(value) => Field {
				name: "checksum".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::StepsApplied(value) => Field {
				name: "steps_applied".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::AppliedAt(value) => Field {
				name: "applied_at".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub struct MigrationFindMany<'a> {
	query: Query<'a>,
}
impl<'a> MigrationFindMany<'a> {
	pub async fn exec(self) -> Vec<MigrationData> {
		self.query.perform::<Vec<MigrationData>>().await.unwrap()
	}
	pub fn delete(self) -> MigrationDelete<'a> {
		MigrationDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Migration".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<MigrationSetParam>) -> MigrationUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		MigrationUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<MigrationWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct MigrationFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> MigrationFindFirst<'a> {
	pub async fn exec(self) -> Option<MigrationData> {
		self.query.perform::<Option<MigrationData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<MigrationWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct MigrationFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> MigrationFindUnique<'a> {
	pub async fn exec(self) -> Option<MigrationData> {
		self.query.perform::<Option<MigrationData>>().await.unwrap()
	}
	pub fn delete(self) -> MigrationDelete<'a> {
		MigrationDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Migration".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<MigrationSetParam>) -> MigrationUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		MigrationUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<MigrationWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct MigrationCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> MigrationCreateOne<'a> {
	pub async fn exec(self) -> MigrationData {
		self.query.perform::<MigrationData>().await.unwrap()
	}
}
pub struct MigrationUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> MigrationUpdateUnique<'a> {
	pub async fn exec(self) -> MigrationData {
		self.query.perform::<MigrationData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<MigrationWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct MigrationUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> MigrationUpdateMany<'a> {
	pub async fn exec(self) -> Vec<MigrationData> {
		self.query.perform::<Vec<MigrationData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<MigrationWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct MigrationDelete<'a> {
	query: Query<'a>,
}
impl<'a> MigrationDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct MigrationActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> MigrationActions<'a> {
	pub fn find_unique(&self, param: MigrationWhereParam) -> MigrationFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Migration".into(),
			outputs: migration_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		MigrationFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<MigrationWhereParam>) -> MigrationFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Migration".into(),
			outputs: migration_outputs(),
			inputs,
		};
		MigrationFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<MigrationWhereParam>) -> MigrationFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Migration".into(),
			outputs: migration_outputs(),
			inputs,
		};
		MigrationFindMany { query }
	}
	pub fn create_one(
		&self,
		name: MigrationSetName,
		checksum: MigrationSetChecksum,
		params: Vec<MigrationSetParam>,
	) -> MigrationCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(MigrationSetParam::from(name).field());
		input_fields.push(MigrationSetParam::from(checksum).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Migration".into(),
			outputs: migration_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		MigrationCreateOne { query }
	}
}
fn library_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("uuid"),
		Output::new("name"),
		Output::new("remote_id"),
		Output::new("is_primary"),
		Output::new("encryption"),
		Output::new("date_created"),
		Output::new("timezone"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LibraryData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "uuid")]
	pub uuid: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "remote_id")]
	pub remote_id: Option<String>,
	#[serde(rename = "is_primary")]
	pub is_primary: bool,
	#[serde(rename = "encryption")]
	pub encryption: i64,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "timezone")]
	pub timezone: Option<String>,
	#[serde(rename = "spaces")]
	spaces: Option<Vec<SpaceData>>,
}
impl LibraryData {
	pub fn spaces(&self) -> Result<&Vec<SpaceData>, String> {
		match self.spaces.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access spaces but did not fetch it using the .with() syntax".to_string()),
		}
	}
}
pub struct Library;
impl Library {
	pub fn id() -> LibraryIdField {
		LibraryIdField {}
	}
	pub fn uuid() -> LibraryUuidField {
		LibraryUuidField {}
	}
	pub fn name() -> LibraryNameField {
		LibraryNameField {}
	}
	pub fn remote_id() -> LibraryRemoteIdField {
		LibraryRemoteIdField {}
	}
	pub fn is_primary() -> LibraryIsPrimaryField {
		LibraryIsPrimaryField {}
	}
	pub fn encryption() -> LibraryEncryptionField {
		LibraryEncryptionField {}
	}
	pub fn date_created() -> LibraryDateCreatedField {
		LibraryDateCreatedField {}
	}
	pub fn timezone() -> LibraryTimezoneField {
		LibraryTimezoneField {}
	}
	pub fn spaces() -> LibrarySpacesField {
		LibrarySpacesField {}
	}
}
pub struct LibraryIdField {}
pub struct LibrarySetId(i64);
impl From<LibrarySetId> for LibrarySetParam {
	fn from(value: LibrarySetId) -> Self {
		Self::Id(value.0)
	}
}
impl LibraryIdField {
	pub fn lt(&self, value: i64) -> LibraryWhereParam {
		LibraryWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> LibraryWhereParam {
		LibraryWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> LibraryWhereParam {
		LibraryWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> LibraryWhereParam {
		LibraryWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> LibraryWhereParam {
		LibraryWhereParam::IdEquals(value)
	}
	pub fn set<T: From<LibrarySetId>>(&self, value: i64) -> T {
		LibrarySetId(value).into()
	}
}
pub struct LibraryUuidField {}
pub struct LibrarySetUuid(String);
impl From<LibrarySetUuid> for LibrarySetParam {
	fn from(value: LibrarySetUuid) -> Self {
		Self::Uuid(value.0)
	}
}
impl LibraryUuidField {
	pub fn contains(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidContains(value)
	}
	pub fn has_prefix(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidEquals(value)
	}
	pub fn set<T: From<LibrarySetUuid>>(&self, value: String) -> T {
		LibrarySetUuid(value).into()
	}
}
pub struct LibraryNameField {}
pub struct LibrarySetName(String);
impl From<LibrarySetName> for LibrarySetParam {
	fn from(value: LibrarySetName) -> Self {
		Self::Name(value.0)
	}
}
impl LibraryNameField {
	pub fn contains(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameContains(value)
	}
	pub fn has_prefix(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameEquals(value)
	}
	pub fn set<T: From<LibrarySetName>>(&self, value: String) -> T {
		LibrarySetName(value).into()
	}
}
pub struct LibraryRemoteIdField {}
pub struct LibrarySetRemoteId(String);
impl From<LibrarySetRemoteId> for LibrarySetParam {
	fn from(value: LibrarySetRemoteId) -> Self {
		Self::RemoteId(value.0)
	}
}
impl LibraryRemoteIdField {
	pub fn contains(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdContains(value)
	}
	pub fn has_prefix(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdEquals(value)
	}
	pub fn set<T: From<LibrarySetRemoteId>>(&self, value: String) -> T {
		LibrarySetRemoteId(value).into()
	}
}
pub struct LibraryIsPrimaryField {}
pub struct LibrarySetIsPrimary(bool);
impl From<LibrarySetIsPrimary> for LibrarySetParam {
	fn from(value: LibrarySetIsPrimary) -> Self {
		Self::IsPrimary(value.0)
	}
}
impl LibraryIsPrimaryField {
	pub fn equals(&self, value: bool) -> LibraryWhereParam {
		LibraryWhereParam::IsPrimaryEquals(value)
	}
	pub fn set<T: From<LibrarySetIsPrimary>>(&self, value: bool) -> T {
		LibrarySetIsPrimary(value).into()
	}
}
pub struct LibraryEncryptionField {}
pub struct LibrarySetEncryption(i64);
impl From<LibrarySetEncryption> for LibrarySetParam {
	fn from(value: LibrarySetEncryption) -> Self {
		Self::Encryption(value.0)
	}
}
impl LibraryEncryptionField {
	pub fn lt(&self, value: i64) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionLT(value)
	}
	pub fn gt(&self, value: i64) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionGT(value)
	}
	pub fn lte(&self, value: i64) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionLTE(value)
	}
	pub fn gte(&self, value: i64) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionGTE(value)
	}
	pub fn equals(&self, value: i64) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionEquals(value)
	}
	pub fn set<T: From<LibrarySetEncryption>>(&self, value: i64) -> T {
		LibrarySetEncryption(value).into()
	}
}
pub struct LibraryDateCreatedField {}
pub struct LibrarySetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<LibrarySetDateCreated> for LibrarySetParam {
	fn from(value: LibrarySetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl LibraryDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<LibrarySetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		LibrarySetDateCreated(value).into()
	}
}
pub struct LibraryTimezoneField {}
pub struct LibrarySetTimezone(String);
impl From<LibrarySetTimezone> for LibrarySetParam {
	fn from(value: LibrarySetTimezone) -> Self {
		Self::Timezone(value.0)
	}
}
impl LibraryTimezoneField {
	pub fn contains(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneContains(value)
	}
	pub fn has_prefix(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneEquals(value)
	}
	pub fn set<T: From<LibrarySetTimezone>>(&self, value: String) -> T {
		LibrarySetTimezone(value).into()
	}
}
pub struct LibrarySpacesField {}
pub struct LibraryLinkSpaces(Vec<SpaceWhereParam>);
impl From<LibraryLinkSpaces> for LibrarySetParam {
	fn from(value: LibraryLinkSpaces) -> Self {
		Self::LinkSpaces(value.0.into_iter().map(|v| v.into()).collect())
	}
}
impl LibrarySpacesField {
	pub fn some(&self, value: Vec<SpaceWhereParam>) -> LibraryWhereParam {
		LibraryWhereParam::SpacesSome(value)
	}
	pub fn every(&self, value: Vec<SpaceWhereParam>) -> LibraryWhereParam {
		LibraryWhereParam::SpacesEvery(value)
	}
	pub fn link<T: From<LibraryLinkSpaces>>(&self, value: Vec<SpaceWhereParam>) -> T {
		LibraryLinkSpaces(value).into()
	}
	pub fn unlink(&self, params: Vec<SpaceWhereParam>) -> LibrarySetParam {
		LibrarySetParam::UnlinkSpaces(params)
	}
	pub fn fetch(&self, params: Vec<SpaceWhereParam>) -> LibraryWith {
		LibraryWithParam::Spaces(params).into()
	}
}
pub enum LibraryWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	UuidContains(String),
	UuidHasPrefix(String),
	UuidHasSuffix(String),
	UuidEquals(String),
	NameContains(String),
	NameHasPrefix(String),
	NameHasSuffix(String),
	NameEquals(String),
	RemoteIdContains(String),
	RemoteIdHasPrefix(String),
	RemoteIdHasSuffix(String),
	RemoteIdEquals(String),
	IsPrimaryEquals(bool),
	EncryptionLT(i64),
	EncryptionGT(i64),
	EncryptionLTE(i64),
	EncryptionGTE(i64),
	EncryptionEquals(i64),
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	TimezoneContains(String),
	TimezoneHasPrefix(String),
	TimezoneHasSuffix(String),
	TimezoneEquals(String),
	SpacesSome(Vec<SpaceWhereParam>),
	SpacesEvery(Vec<SpaceWhereParam>),
	Not(Vec<LibraryWhereParam>),
	Or(Vec<LibraryWhereParam>),
	And(Vec<LibraryWhereParam>),
}
impl LibraryWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidContains(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidHasPrefix(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidHasSuffix(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidEquals(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasPrefix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasSuffix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdContains(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdHasPrefix(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdHasSuffix(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdEquals(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsPrimaryEquals(value) => Field {
				name: "is_primary".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLT(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGT(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLTE(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGTE(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionEquals(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneContains(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneHasPrefix(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneHasSuffix(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneEquals(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SpacesSome(value) => Field {
				name: "spaces".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SpacesEvery(value) => Field {
				name: "spaces".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for LibraryWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct LibraryWith {
	pub param: LibraryWithParam,
}
pub enum LibraryWithParam {
	Spaces(Vec<SpaceWhereParam>),
}
impl From<LibraryWithParam> for LibraryWith {
	fn from(param: LibraryWithParam) -> Self {
		Self { param }
	}
}
impl LibraryWithParam {
	pub fn output(self) -> Output {
		match self {
			Self::Spaces(where_params) => Output {
				name: "spaces".into(),
				outputs: space_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params.into_iter().map(|f| f.field()).collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
		}
	}
}
pub enum LibrarySetParam {
	Id(i64),
	Uuid(String),
	Name(String),
	RemoteId(String),
	IsPrimary(bool),
	Encryption(i64),
	DateCreated(chrono::DateTime<chrono::Utc>),
	Timezone(String),
	LinkSpaces(Vec<SpaceWhereParam>),
	UnlinkSpaces(Vec<SpaceWhereParam>),
}
impl LibrarySetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Uuid(value) => Field {
				name: "uuid".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::RemoteId(value) => Field {
				name: "remote_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsPrimary(value) => Field {
				name: "is_primary".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Encryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Timezone(value) => Field {
				name: "timezone".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkSpaces(where_params) => Field {
				name: "spaces".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkSpaces(where_params) => Field {
				name: "spaces".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub struct LibraryFindMany<'a> {
	query: Query<'a>,
}
impl<'a> LibraryFindMany<'a> {
	pub async fn exec(self) -> Vec<LibraryData> {
		self.query.perform::<Vec<LibraryData>>().await.unwrap()
	}
	pub fn delete(self) -> LibraryDelete<'a> {
		LibraryDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Library".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LibrarySetParam>) -> LibraryUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LibraryUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<LibraryWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LibraryFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> LibraryFindFirst<'a> {
	pub async fn exec(self) -> Option<LibraryData> {
		self.query.perform::<Option<LibraryData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LibraryWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LibraryFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> LibraryFindUnique<'a> {
	pub async fn exec(self) -> Option<LibraryData> {
		self.query.perform::<Option<LibraryData>>().await.unwrap()
	}
	pub fn delete(self) -> LibraryDelete<'a> {
		LibraryDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Library".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LibrarySetParam>) -> LibraryUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LibraryUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<LibraryWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LibraryCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> LibraryCreateOne<'a> {
	pub async fn exec(self) -> LibraryData {
		self.query.perform::<LibraryData>().await.unwrap()
	}
}
pub struct LibraryUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> LibraryUpdateUnique<'a> {
	pub async fn exec(self) -> LibraryData {
		self.query.perform::<LibraryData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LibraryWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LibraryUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> LibraryUpdateMany<'a> {
	pub async fn exec(self) -> Vec<LibraryData> {
		self.query.perform::<Vec<LibraryData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LibraryWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LibraryDelete<'a> {
	query: Query<'a>,
}
impl<'a> LibraryDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct LibraryActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> LibraryActions<'a> {
	pub fn find_unique(&self, param: LibraryWhereParam) -> LibraryFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Library".into(),
			outputs: library_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LibraryFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<LibraryWhereParam>) -> LibraryFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Library".into(),
			outputs: library_outputs(),
			inputs,
		};
		LibraryFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<LibraryWhereParam>) -> LibraryFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Library".into(),
			outputs: library_outputs(),
			inputs,
		};
		LibraryFindMany { query }
	}
	pub fn create_one(
		&self,
		uuid: LibrarySetUuid,
		name: LibrarySetName,
		params: Vec<LibrarySetParam>,
	) -> LibraryCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(LibrarySetParam::from(uuid).field());
		input_fields.push(LibrarySetParam::from(name).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Library".into(),
			outputs: library_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		LibraryCreateOne { query }
	}
}
fn library_statistics_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("date_captured"),
		Output::new("library_id"),
		Output::new("total_file_count"),
		Output::new("total_bytes_used"),
		Output::new("total_byte_capacity"),
		Output::new("total_unique_bytes"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LibraryStatisticsData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "date_captured")]
	pub date_captured: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "library_id")]
	pub library_id: i64,
	#[serde(rename = "total_file_count")]
	pub total_file_count: i64,
	#[serde(rename = "total_bytes_used")]
	pub total_bytes_used: String,
	#[serde(rename = "total_byte_capacity")]
	pub total_byte_capacity: String,
	#[serde(rename = "total_unique_bytes")]
	pub total_unique_bytes: String,
}
impl LibraryStatisticsData {}
pub struct LibraryStatistics;
impl LibraryStatistics {
	pub fn id() -> LibraryStatisticsIdField {
		LibraryStatisticsIdField {}
	}
	pub fn date_captured() -> LibraryStatisticsDateCapturedField {
		LibraryStatisticsDateCapturedField {}
	}
	pub fn library_id() -> LibraryStatisticsLibraryIdField {
		LibraryStatisticsLibraryIdField {}
	}
	pub fn total_file_count() -> LibraryStatisticsTotalFileCountField {
		LibraryStatisticsTotalFileCountField {}
	}
	pub fn total_bytes_used() -> LibraryStatisticsTotalBytesUsedField {
		LibraryStatisticsTotalBytesUsedField {}
	}
	pub fn total_byte_capacity() -> LibraryStatisticsTotalByteCapacityField {
		LibraryStatisticsTotalByteCapacityField {}
	}
	pub fn total_unique_bytes() -> LibraryStatisticsTotalUniqueBytesField {
		LibraryStatisticsTotalUniqueBytesField {}
	}
}
pub struct LibraryStatisticsIdField {}
pub struct LibraryStatisticsSetId(i64);
impl From<LibraryStatisticsSetId> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetId) -> Self {
		Self::Id(value.0)
	}
}
impl LibraryStatisticsIdField {
	pub fn lt(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdEquals(value)
	}
	pub fn set<T: From<LibraryStatisticsSetId>>(&self, value: i64) -> T {
		LibraryStatisticsSetId(value).into()
	}
}
pub struct LibraryStatisticsDateCapturedField {}
pub struct LibraryStatisticsSetDateCaptured(chrono::DateTime<chrono::Utc>);
impl From<LibraryStatisticsSetDateCaptured> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetDateCaptured) -> Self {
		Self::DateCaptured(value.0)
	}
}
impl LibraryStatisticsDateCapturedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedEquals(value)
	}
	pub fn set<T: From<LibraryStatisticsSetDateCaptured>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		LibraryStatisticsSetDateCaptured(value).into()
	}
}
pub struct LibraryStatisticsLibraryIdField {}
pub struct LibraryStatisticsSetLibraryId(i64);
impl From<LibraryStatisticsSetLibraryId> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetLibraryId) -> Self {
		Self::LibraryId(value.0)
	}
}
impl LibraryStatisticsLibraryIdField {
	pub fn lt(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdLT(value)
	}
	pub fn gt(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdGT(value)
	}
	pub fn lte(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdLTE(value)
	}
	pub fn gte(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdGTE(value)
	}
	pub fn equals(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdEquals(value)
	}
	pub fn set<T: From<LibraryStatisticsSetLibraryId>>(&self, value: i64) -> T {
		LibraryStatisticsSetLibraryId(value).into()
	}
}
pub struct LibraryStatisticsTotalFileCountField {}
pub struct LibraryStatisticsSetTotalFileCount(i64);
impl From<LibraryStatisticsSetTotalFileCount> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetTotalFileCount) -> Self {
		Self::TotalFileCount(value.0)
	}
}
impl LibraryStatisticsTotalFileCountField {
	pub fn lt(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountLT(value)
	}
	pub fn gt(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountGT(value)
	}
	pub fn lte(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountLTE(value)
	}
	pub fn gte(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountGTE(value)
	}
	pub fn equals(&self, value: i64) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountEquals(value)
	}
	pub fn set<T: From<LibraryStatisticsSetTotalFileCount>>(&self, value: i64) -> T {
		LibraryStatisticsSetTotalFileCount(value).into()
	}
}
pub struct LibraryStatisticsTotalBytesUsedField {}
pub struct LibraryStatisticsSetTotalBytesUsed(String);
impl From<LibraryStatisticsSetTotalBytesUsed> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetTotalBytesUsed) -> Self {
		Self::TotalBytesUsed(value.0)
	}
}
impl LibraryStatisticsTotalBytesUsedField {
	pub fn contains(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedContains(value)
	}
	pub fn has_prefix(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedEquals(value)
	}
	pub fn set<T: From<LibraryStatisticsSetTotalBytesUsed>>(&self, value: String) -> T {
		LibraryStatisticsSetTotalBytesUsed(value).into()
	}
}
pub struct LibraryStatisticsTotalByteCapacityField {}
pub struct LibraryStatisticsSetTotalByteCapacity(String);
impl From<LibraryStatisticsSetTotalByteCapacity> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetTotalByteCapacity) -> Self {
		Self::TotalByteCapacity(value.0)
	}
}
impl LibraryStatisticsTotalByteCapacityField {
	pub fn contains(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityContains(value)
	}
	pub fn has_prefix(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityEquals(value)
	}
	pub fn set<T: From<LibraryStatisticsSetTotalByteCapacity>>(&self, value: String) -> T {
		LibraryStatisticsSetTotalByteCapacity(value).into()
	}
}
pub struct LibraryStatisticsTotalUniqueBytesField {}
pub struct LibraryStatisticsSetTotalUniqueBytes(String);
impl From<LibraryStatisticsSetTotalUniqueBytes> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetTotalUniqueBytes) -> Self {
		Self::TotalUniqueBytes(value.0)
	}
}
impl LibraryStatisticsTotalUniqueBytesField {
	pub fn contains(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesContains(value)
	}
	pub fn has_prefix(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesEquals(value)
	}
	pub fn set<T: From<LibraryStatisticsSetTotalUniqueBytes>>(&self, value: String) -> T {
		LibraryStatisticsSetTotalUniqueBytes(value).into()
	}
}
pub enum LibraryStatisticsWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	DateCapturedBefore(chrono::DateTime<chrono::Utc>),
	DateCapturedAfter(chrono::DateTime<chrono::Utc>),
	DateCapturedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCapturedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCapturedEquals(chrono::DateTime<chrono::Utc>),
	LibraryIdLT(i64),
	LibraryIdGT(i64),
	LibraryIdLTE(i64),
	LibraryIdGTE(i64),
	LibraryIdEquals(i64),
	TotalFileCountLT(i64),
	TotalFileCountGT(i64),
	TotalFileCountLTE(i64),
	TotalFileCountGTE(i64),
	TotalFileCountEquals(i64),
	TotalBytesUsedContains(String),
	TotalBytesUsedHasPrefix(String),
	TotalBytesUsedHasSuffix(String),
	TotalBytesUsedEquals(String),
	TotalByteCapacityContains(String),
	TotalByteCapacityHasPrefix(String),
	TotalByteCapacityHasSuffix(String),
	TotalByteCapacityEquals(String),
	TotalUniqueBytesContains(String),
	TotalUniqueBytesHasPrefix(String),
	TotalUniqueBytesHasSuffix(String),
	TotalUniqueBytesEquals(String),
	Not(Vec<LibraryStatisticsWhereParam>),
	Or(Vec<LibraryStatisticsWhereParam>),
	And(Vec<LibraryStatisticsWhereParam>),
}
impl LibraryStatisticsWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedBefore(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedAfter(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedBeforeEquals(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedAfterEquals(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedEquals(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdLT(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdGT(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdLTE(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdGTE(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdEquals(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountLT(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountGT(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountLTE(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountGTE(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountEquals(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedContains(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedHasPrefix(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedHasSuffix(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedEquals(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityContains(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityHasPrefix(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityHasSuffix(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityEquals(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesContains(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesHasPrefix(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesHasSuffix(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesEquals(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for LibraryStatisticsWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct LibraryStatisticsWith {
	pub param: LibraryStatisticsWithParam,
}
pub enum LibraryStatisticsWithParam {}
impl From<LibraryStatisticsWithParam> for LibraryStatisticsWith {
	fn from(param: LibraryStatisticsWithParam) -> Self {
		Self { param }
	}
}
impl LibraryStatisticsWithParam {
	pub fn output(self) -> Output {
		match self {}
	}
}
pub enum LibraryStatisticsSetParam {
	Id(i64),
	DateCaptured(chrono::DateTime<chrono::Utc>),
	LibraryId(i64),
	TotalFileCount(i64),
	TotalBytesUsed(String),
	TotalByteCapacity(String),
	TotalUniqueBytes(String),
}
impl LibraryStatisticsSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCaptured(value) => Field {
				name: "date_captured".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LibraryId(value) => Field {
				name: "library_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalFileCount(value) => Field {
				name: "total_file_count".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalBytesUsed(value) => Field {
				name: "total_bytes_used".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalByteCapacity(value) => Field {
				name: "total_byte_capacity".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalUniqueBytes(value) => Field {
				name: "total_unique_bytes".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub struct LibraryStatisticsFindMany<'a> {
	query: Query<'a>,
}
impl<'a> LibraryStatisticsFindMany<'a> {
	pub async fn exec(self) -> Vec<LibraryStatisticsData> {
		self.query.perform::<Vec<LibraryStatisticsData>>().await.unwrap()
	}
	pub fn delete(self) -> LibraryStatisticsDelete<'a> {
		LibraryStatisticsDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "LibraryStatistics".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LibraryStatisticsSetParam>) -> LibraryStatisticsUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LibraryStatisticsUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<LibraryStatisticsWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LibraryStatisticsFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> LibraryStatisticsFindFirst<'a> {
	pub async fn exec(self) -> Option<LibraryStatisticsData> {
		self.query.perform::<Option<LibraryStatisticsData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LibraryStatisticsWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LibraryStatisticsFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> LibraryStatisticsFindUnique<'a> {
	pub async fn exec(self) -> Option<LibraryStatisticsData> {
		self.query.perform::<Option<LibraryStatisticsData>>().await.unwrap()
	}
	pub fn delete(self) -> LibraryStatisticsDelete<'a> {
		LibraryStatisticsDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "LibraryStatistics".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LibraryStatisticsSetParam>) -> LibraryStatisticsUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LibraryStatisticsUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<LibraryStatisticsWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LibraryStatisticsCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> LibraryStatisticsCreateOne<'a> {
	pub async fn exec(self) -> LibraryStatisticsData {
		self.query.perform::<LibraryStatisticsData>().await.unwrap()
	}
}
pub struct LibraryStatisticsUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> LibraryStatisticsUpdateUnique<'a> {
	pub async fn exec(self) -> LibraryStatisticsData {
		self.query.perform::<LibraryStatisticsData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LibraryStatisticsWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LibraryStatisticsUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> LibraryStatisticsUpdateMany<'a> {
	pub async fn exec(self) -> Vec<LibraryStatisticsData> {
		self.query.perform::<Vec<LibraryStatisticsData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LibraryStatisticsWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LibraryStatisticsDelete<'a> {
	query: Query<'a>,
}
impl<'a> LibraryStatisticsDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct LibraryStatisticsActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> LibraryStatisticsActions<'a> {
	pub fn find_unique(&self, param: LibraryStatisticsWhereParam) -> LibraryStatisticsFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "LibraryStatistics".into(),
			outputs: library_statistics_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LibraryStatisticsFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<LibraryStatisticsWhereParam>) -> LibraryStatisticsFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "LibraryStatistics".into(),
			outputs: library_statistics_outputs(),
			inputs,
		};
		LibraryStatisticsFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<LibraryStatisticsWhereParam>) -> LibraryStatisticsFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "LibraryStatistics".into(),
			outputs: library_statistics_outputs(),
			inputs,
		};
		LibraryStatisticsFindMany { query }
	}
	pub fn create_one(
		&self,
		library_id: LibraryStatisticsSetLibraryId,
		params: Vec<LibraryStatisticsSetParam>,
	) -> LibraryStatisticsCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(LibraryStatisticsSetParam::from(library_id).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "LibraryStatistics".into(),
			outputs: library_statistics_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		LibraryStatisticsCreateOne { query }
	}
}
fn client_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("uuid"),
		Output::new("name"),
		Output::new("platform"),
		Output::new("version"),
		Output::new("online"),
		Output::new("last_seen"),
		Output::new("timezone"),
		Output::new("date_created"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "uuid")]
	pub uuid: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "platform")]
	pub platform: i64,
	#[serde(rename = "version")]
	pub version: Option<String>,
	#[serde(rename = "online")]
	pub online: Option<bool>,
	#[serde(rename = "last_seen")]
	pub last_seen: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "timezone")]
	pub timezone: Option<String>,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
}
impl ClientData {}
pub struct Client;
impl Client {
	pub fn id() -> ClientIdField {
		ClientIdField {}
	}
	pub fn uuid() -> ClientUuidField {
		ClientUuidField {}
	}
	pub fn name() -> ClientNameField {
		ClientNameField {}
	}
	pub fn platform() -> ClientPlatformField {
		ClientPlatformField {}
	}
	pub fn version() -> ClientVersionField {
		ClientVersionField {}
	}
	pub fn online() -> ClientOnlineField {
		ClientOnlineField {}
	}
	pub fn last_seen() -> ClientLastSeenField {
		ClientLastSeenField {}
	}
	pub fn timezone() -> ClientTimezoneField {
		ClientTimezoneField {}
	}
	pub fn date_created() -> ClientDateCreatedField {
		ClientDateCreatedField {}
	}
}
pub struct ClientIdField {}
pub struct ClientSetId(i64);
impl From<ClientSetId> for ClientSetParam {
	fn from(value: ClientSetId) -> Self {
		Self::Id(value.0)
	}
}
impl ClientIdField {
	pub fn lt(&self, value: i64) -> ClientWhereParam {
		ClientWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> ClientWhereParam {
		ClientWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> ClientWhereParam {
		ClientWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> ClientWhereParam {
		ClientWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> ClientWhereParam {
		ClientWhereParam::IdEquals(value)
	}
	pub fn set<T: From<ClientSetId>>(&self, value: i64) -> T {
		ClientSetId(value).into()
	}
}
pub struct ClientUuidField {}
pub struct ClientSetUuid(String);
impl From<ClientSetUuid> for ClientSetParam {
	fn from(value: ClientSetUuid) -> Self {
		Self::Uuid(value.0)
	}
}
impl ClientUuidField {
	pub fn contains(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidContains(value)
	}
	pub fn has_prefix(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidEquals(value)
	}
	pub fn set<T: From<ClientSetUuid>>(&self, value: String) -> T {
		ClientSetUuid(value).into()
	}
}
pub struct ClientNameField {}
pub struct ClientSetName(String);
impl From<ClientSetName> for ClientSetParam {
	fn from(value: ClientSetName) -> Self {
		Self::Name(value.0)
	}
}
impl ClientNameField {
	pub fn contains(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameContains(value)
	}
	pub fn has_prefix(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameEquals(value)
	}
	pub fn set<T: From<ClientSetName>>(&self, value: String) -> T {
		ClientSetName(value).into()
	}
}
pub struct ClientPlatformField {}
pub struct ClientSetPlatform(i64);
impl From<ClientSetPlatform> for ClientSetParam {
	fn from(value: ClientSetPlatform) -> Self {
		Self::Platform(value.0)
	}
}
impl ClientPlatformField {
	pub fn lt(&self, value: i64) -> ClientWhereParam {
		ClientWhereParam::PlatformLT(value)
	}
	pub fn gt(&self, value: i64) -> ClientWhereParam {
		ClientWhereParam::PlatformGT(value)
	}
	pub fn lte(&self, value: i64) -> ClientWhereParam {
		ClientWhereParam::PlatformLTE(value)
	}
	pub fn gte(&self, value: i64) -> ClientWhereParam {
		ClientWhereParam::PlatformGTE(value)
	}
	pub fn equals(&self, value: i64) -> ClientWhereParam {
		ClientWhereParam::PlatformEquals(value)
	}
	pub fn set<T: From<ClientSetPlatform>>(&self, value: i64) -> T {
		ClientSetPlatform(value).into()
	}
}
pub struct ClientVersionField {}
pub struct ClientSetVersion(String);
impl From<ClientSetVersion> for ClientSetParam {
	fn from(value: ClientSetVersion) -> Self {
		Self::Version(value.0)
	}
}
impl ClientVersionField {
	pub fn contains(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionContains(value)
	}
	pub fn has_prefix(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionEquals(value)
	}
	pub fn set<T: From<ClientSetVersion>>(&self, value: String) -> T {
		ClientSetVersion(value).into()
	}
}
pub struct ClientOnlineField {}
pub struct ClientSetOnline(bool);
impl From<ClientSetOnline> for ClientSetParam {
	fn from(value: ClientSetOnline) -> Self {
		Self::Online(value.0)
	}
}
impl ClientOnlineField {
	pub fn equals(&self, value: bool) -> ClientWhereParam {
		ClientWhereParam::OnlineEquals(value)
	}
	pub fn set<T: From<ClientSetOnline>>(&self, value: bool) -> T {
		ClientSetOnline(value).into()
	}
}
pub struct ClientLastSeenField {}
pub struct ClientSetLastSeen(chrono::DateTime<chrono::Utc>);
impl From<ClientSetLastSeen> for ClientSetParam {
	fn from(value: ClientSetLastSeen) -> Self {
		Self::LastSeen(value.0)
	}
}
impl ClientLastSeenField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::LastSeenBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::LastSeenAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::LastSeenBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::LastSeenAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::LastSeenEquals(value)
	}
	pub fn set<T: From<ClientSetLastSeen>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		ClientSetLastSeen(value).into()
	}
}
pub struct ClientTimezoneField {}
pub struct ClientSetTimezone(String);
impl From<ClientSetTimezone> for ClientSetParam {
	fn from(value: ClientSetTimezone) -> Self {
		Self::Timezone(value.0)
	}
}
impl ClientTimezoneField {
	pub fn contains(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneContains(value)
	}
	pub fn has_prefix(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneEquals(value)
	}
	pub fn set<T: From<ClientSetTimezone>>(&self, value: String) -> T {
		ClientSetTimezone(value).into()
	}
}
pub struct ClientDateCreatedField {}
pub struct ClientSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<ClientSetDateCreated> for ClientSetParam {
	fn from(value: ClientSetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl ClientDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<ClientSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		ClientSetDateCreated(value).into()
	}
}
pub enum ClientWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	UuidContains(String),
	UuidHasPrefix(String),
	UuidHasSuffix(String),
	UuidEquals(String),
	NameContains(String),
	NameHasPrefix(String),
	NameHasSuffix(String),
	NameEquals(String),
	PlatformLT(i64),
	PlatformGT(i64),
	PlatformLTE(i64),
	PlatformGTE(i64),
	PlatformEquals(i64),
	VersionContains(String),
	VersionHasPrefix(String),
	VersionHasSuffix(String),
	VersionEquals(String),
	OnlineEquals(bool),
	LastSeenBefore(chrono::DateTime<chrono::Utc>),
	LastSeenAfter(chrono::DateTime<chrono::Utc>),
	LastSeenBeforeEquals(chrono::DateTime<chrono::Utc>),
	LastSeenAfterEquals(chrono::DateTime<chrono::Utc>),
	LastSeenEquals(chrono::DateTime<chrono::Utc>),
	TimezoneContains(String),
	TimezoneHasPrefix(String),
	TimezoneHasSuffix(String),
	TimezoneEquals(String),
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	Not(Vec<ClientWhereParam>),
	Or(Vec<ClientWhereParam>),
	And(Vec<ClientWhereParam>),
}
impl ClientWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidContains(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidHasPrefix(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidHasSuffix(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidEquals(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasPrefix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasSuffix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformLT(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformGT(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformLTE(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformGTE(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformEquals(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionContains(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionHasPrefix(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionHasSuffix(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionEquals(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::OnlineEquals(value) => Field {
				name: "online".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenBefore(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenAfter(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenBeforeEquals(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenAfterEquals(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenEquals(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneContains(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneHasPrefix(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneHasSuffix(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneEquals(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for ClientWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct ClientWith {
	pub param: ClientWithParam,
}
pub enum ClientWithParam {}
impl From<ClientWithParam> for ClientWith {
	fn from(param: ClientWithParam) -> Self {
		Self { param }
	}
}
impl ClientWithParam {
	pub fn output(self) -> Output {
		match self {}
	}
}
pub enum ClientSetParam {
	Id(i64),
	Uuid(String),
	Name(String),
	Platform(i64),
	Version(String),
	Online(bool),
	LastSeen(chrono::DateTime<chrono::Utc>),
	Timezone(String),
	DateCreated(chrono::DateTime<chrono::Utc>),
}
impl ClientSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Uuid(value) => Field {
				name: "uuid".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Platform(value) => Field {
				name: "platform".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Version(value) => Field {
				name: "version".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Online(value) => Field {
				name: "online".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LastSeen(value) => Field {
				name: "last_seen".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Timezone(value) => Field {
				name: "timezone".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub struct ClientFindMany<'a> {
	query: Query<'a>,
}
impl<'a> ClientFindMany<'a> {
	pub async fn exec(self) -> Vec<ClientData> {
		self.query.perform::<Vec<ClientData>>().await.unwrap()
	}
	pub fn delete(self) -> ClientDelete<'a> {
		ClientDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Client".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<ClientSetParam>) -> ClientUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		ClientUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<ClientWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct ClientFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> ClientFindFirst<'a> {
	pub async fn exec(self) -> Option<ClientData> {
		self.query.perform::<Option<ClientData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<ClientWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct ClientFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> ClientFindUnique<'a> {
	pub async fn exec(self) -> Option<ClientData> {
		self.query.perform::<Option<ClientData>>().await.unwrap()
	}
	pub fn delete(self) -> ClientDelete<'a> {
		ClientDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Client".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<ClientSetParam>) -> ClientUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		ClientUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<ClientWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct ClientCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> ClientCreateOne<'a> {
	pub async fn exec(self) -> ClientData {
		self.query.perform::<ClientData>().await.unwrap()
	}
}
pub struct ClientUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> ClientUpdateUnique<'a> {
	pub async fn exec(self) -> ClientData {
		self.query.perform::<ClientData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<ClientWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct ClientUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> ClientUpdateMany<'a> {
	pub async fn exec(self) -> Vec<ClientData> {
		self.query.perform::<Vec<ClientData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<ClientWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct ClientDelete<'a> {
	query: Query<'a>,
}
impl<'a> ClientDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct ClientActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> ClientActions<'a> {
	pub fn find_unique(&self, param: ClientWhereParam) -> ClientFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Client".into(),
			outputs: client_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		ClientFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<ClientWhereParam>) -> ClientFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Client".into(),
			outputs: client_outputs(),
			inputs,
		};
		ClientFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<ClientWhereParam>) -> ClientFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Client".into(),
			outputs: client_outputs(),
			inputs,
		};
		ClientFindMany { query }
	}
	pub fn create_one(&self, uuid: ClientSetUuid, name: ClientSetName, params: Vec<ClientSetParam>) -> ClientCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(ClientSetParam::from(uuid).field());
		input_fields.push(ClientSetParam::from(name).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Client".into(),
			outputs: client_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		ClientCreateOne { query }
	}
}
fn location_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("local_path"),
		Output::new("total_capacity"),
		Output::new("available_capacity"),
		Output::new("filesystem"),
		Output::new("disk_type"),
		Output::new("is_removable"),
		Output::new("is_ejectable"),
		Output::new("is_root_filesystem"),
		Output::new("is_online"),
		Output::new("date_created"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocationData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "name")]
	pub name: Option<String>,
	#[serde(rename = "local_path")]
	pub local_path: Option<String>,
	#[serde(rename = "total_capacity")]
	pub total_capacity: Option<i64>,
	#[serde(rename = "available_capacity")]
	pub available_capacity: Option<i64>,
	#[serde(rename = "filesystem")]
	pub filesystem: Option<String>,
	#[serde(rename = "disk_type")]
	pub disk_type: Option<i64>,
	#[serde(rename = "is_removable")]
	pub is_removable: bool,
	#[serde(rename = "is_ejectable")]
	pub is_ejectable: bool,
	#[serde(rename = "is_root_filesystem")]
	pub is_root_filesystem: bool,
	#[serde(rename = "is_online")]
	pub is_online: bool,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "file_paths")]
	file_paths: Option<Vec<FilePathData>>,
}
impl LocationData {
	pub fn file_paths(&self) -> Result<&Vec<FilePathData>, String> {
		match self.file_paths.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access file_paths but did not fetch it using the .with() syntax".to_string()),
		}
	}
}
pub struct Location;
impl Location {
	pub fn id() -> LocationIdField {
		LocationIdField {}
	}
	pub fn name() -> LocationNameField {
		LocationNameField {}
	}
	pub fn local_path() -> LocationLocalPathField {
		LocationLocalPathField {}
	}
	pub fn total_capacity() -> LocationTotalCapacityField {
		LocationTotalCapacityField {}
	}
	pub fn available_capacity() -> LocationAvailableCapacityField {
		LocationAvailableCapacityField {}
	}
	pub fn filesystem() -> LocationFilesystemField {
		LocationFilesystemField {}
	}
	pub fn disk_type() -> LocationDiskTypeField {
		LocationDiskTypeField {}
	}
	pub fn is_removable() -> LocationIsRemovableField {
		LocationIsRemovableField {}
	}
	pub fn is_ejectable() -> LocationIsEjectableField {
		LocationIsEjectableField {}
	}
	pub fn is_root_filesystem() -> LocationIsRootFilesystemField {
		LocationIsRootFilesystemField {}
	}
	pub fn is_online() -> LocationIsOnlineField {
		LocationIsOnlineField {}
	}
	pub fn date_created() -> LocationDateCreatedField {
		LocationDateCreatedField {}
	}
	pub fn file_paths() -> LocationFilePathsField {
		LocationFilePathsField {}
	}
}
pub struct LocationIdField {}
pub struct LocationSetId(i64);
impl From<LocationSetId> for LocationSetParam {
	fn from(value: LocationSetId) -> Self {
		Self::Id(value.0)
	}
}
impl LocationIdField {
	pub fn lt(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::IdEquals(value)
	}
	pub fn set<T: From<LocationSetId>>(&self, value: i64) -> T {
		LocationSetId(value).into()
	}
}
pub struct LocationNameField {}
pub struct LocationSetName(String);
impl From<LocationSetName> for LocationSetParam {
	fn from(value: LocationSetName) -> Self {
		Self::Name(value.0)
	}
}
impl LocationNameField {
	pub fn contains(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameContains(value)
	}
	pub fn has_prefix(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameEquals(value)
	}
	pub fn set<T: From<LocationSetName>>(&self, value: String) -> T {
		LocationSetName(value).into()
	}
}
pub struct LocationLocalPathField {}
pub struct LocationSetLocalPath(String);
impl From<LocationSetLocalPath> for LocationSetParam {
	fn from(value: LocationSetLocalPath) -> Self {
		Self::LocalPath(value.0)
	}
}
impl LocationLocalPathField {
	pub fn contains(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathContains(value)
	}
	pub fn has_prefix(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathEquals(value)
	}
	pub fn set<T: From<LocationSetLocalPath>>(&self, value: String) -> T {
		LocationSetLocalPath(value).into()
	}
}
pub struct LocationTotalCapacityField {}
pub struct LocationSetTotalCapacity(i64);
impl From<LocationSetTotalCapacity> for LocationSetParam {
	fn from(value: LocationSetTotalCapacity) -> Self {
		Self::TotalCapacity(value.0)
	}
}
impl LocationTotalCapacityField {
	pub fn lt(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityLT(value)
	}
	pub fn gt(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityGT(value)
	}
	pub fn lte(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityLTE(value)
	}
	pub fn gte(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityGTE(value)
	}
	pub fn equals(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityEquals(value)
	}
	pub fn set<T: From<LocationSetTotalCapacity>>(&self, value: i64) -> T {
		LocationSetTotalCapacity(value).into()
	}
}
pub struct LocationAvailableCapacityField {}
pub struct LocationSetAvailableCapacity(i64);
impl From<LocationSetAvailableCapacity> for LocationSetParam {
	fn from(value: LocationSetAvailableCapacity) -> Self {
		Self::AvailableCapacity(value.0)
	}
}
impl LocationAvailableCapacityField {
	pub fn lt(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityLT(value)
	}
	pub fn gt(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityGT(value)
	}
	pub fn lte(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityLTE(value)
	}
	pub fn gte(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityGTE(value)
	}
	pub fn equals(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityEquals(value)
	}
	pub fn set<T: From<LocationSetAvailableCapacity>>(&self, value: i64) -> T {
		LocationSetAvailableCapacity(value).into()
	}
}
pub struct LocationFilesystemField {}
pub struct LocationSetFilesystem(String);
impl From<LocationSetFilesystem> for LocationSetParam {
	fn from(value: LocationSetFilesystem) -> Self {
		Self::Filesystem(value.0)
	}
}
impl LocationFilesystemField {
	pub fn contains(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemContains(value)
	}
	pub fn has_prefix(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemEquals(value)
	}
	pub fn set<T: From<LocationSetFilesystem>>(&self, value: String) -> T {
		LocationSetFilesystem(value).into()
	}
}
pub struct LocationDiskTypeField {}
pub struct LocationSetDiskType(i64);
impl From<LocationSetDiskType> for LocationSetParam {
	fn from(value: LocationSetDiskType) -> Self {
		Self::DiskType(value.0)
	}
}
impl LocationDiskTypeField {
	pub fn lt(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::DiskTypeLT(value)
	}
	pub fn gt(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::DiskTypeGT(value)
	}
	pub fn lte(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::DiskTypeLTE(value)
	}
	pub fn gte(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::DiskTypeGTE(value)
	}
	pub fn equals(&self, value: i64) -> LocationWhereParam {
		LocationWhereParam::DiskTypeEquals(value)
	}
	pub fn set<T: From<LocationSetDiskType>>(&self, value: i64) -> T {
		LocationSetDiskType(value).into()
	}
}
pub struct LocationIsRemovableField {}
pub struct LocationSetIsRemovable(bool);
impl From<LocationSetIsRemovable> for LocationSetParam {
	fn from(value: LocationSetIsRemovable) -> Self {
		Self::IsRemovable(value.0)
	}
}
impl LocationIsRemovableField {
	pub fn equals(&self, value: bool) -> LocationWhereParam {
		LocationWhereParam::IsRemovableEquals(value)
	}
	pub fn set<T: From<LocationSetIsRemovable>>(&self, value: bool) -> T {
		LocationSetIsRemovable(value).into()
	}
}
pub struct LocationIsEjectableField {}
pub struct LocationSetIsEjectable(bool);
impl From<LocationSetIsEjectable> for LocationSetParam {
	fn from(value: LocationSetIsEjectable) -> Self {
		Self::IsEjectable(value.0)
	}
}
impl LocationIsEjectableField {
	pub fn equals(&self, value: bool) -> LocationWhereParam {
		LocationWhereParam::IsEjectableEquals(value)
	}
	pub fn set<T: From<LocationSetIsEjectable>>(&self, value: bool) -> T {
		LocationSetIsEjectable(value).into()
	}
}
pub struct LocationIsRootFilesystemField {}
pub struct LocationSetIsRootFilesystem(bool);
impl From<LocationSetIsRootFilesystem> for LocationSetParam {
	fn from(value: LocationSetIsRootFilesystem) -> Self {
		Self::IsRootFilesystem(value.0)
	}
}
impl LocationIsRootFilesystemField {
	pub fn equals(&self, value: bool) -> LocationWhereParam {
		LocationWhereParam::IsRootFilesystemEquals(value)
	}
	pub fn set<T: From<LocationSetIsRootFilesystem>>(&self, value: bool) -> T {
		LocationSetIsRootFilesystem(value).into()
	}
}
pub struct LocationIsOnlineField {}
pub struct LocationSetIsOnline(bool);
impl From<LocationSetIsOnline> for LocationSetParam {
	fn from(value: LocationSetIsOnline) -> Self {
		Self::IsOnline(value.0)
	}
}
impl LocationIsOnlineField {
	pub fn equals(&self, value: bool) -> LocationWhereParam {
		LocationWhereParam::IsOnlineEquals(value)
	}
	pub fn set<T: From<LocationSetIsOnline>>(&self, value: bool) -> T {
		LocationSetIsOnline(value).into()
	}
}
pub struct LocationDateCreatedField {}
pub struct LocationSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<LocationSetDateCreated> for LocationSetParam {
	fn from(value: LocationSetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl LocationDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
		LocationWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
		LocationWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
		LocationWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
		LocationWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
		LocationWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<LocationSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		LocationSetDateCreated(value).into()
	}
}
pub struct LocationFilePathsField {}
pub struct LocationLinkFilePaths(Vec<FilePathWhereParam>);
impl From<LocationLinkFilePaths> for LocationSetParam {
	fn from(value: LocationLinkFilePaths) -> Self {
		Self::LinkFilePaths(value.0.into_iter().map(|v| v.into()).collect())
	}
}
impl LocationFilePathsField {
	pub fn some(&self, value: Vec<FilePathWhereParam>) -> LocationWhereParam {
		LocationWhereParam::FilePathsSome(value)
	}
	pub fn every(&self, value: Vec<FilePathWhereParam>) -> LocationWhereParam {
		LocationWhereParam::FilePathsEvery(value)
	}
	pub fn link<T: From<LocationLinkFilePaths>>(&self, value: Vec<FilePathWhereParam>) -> T {
		LocationLinkFilePaths(value).into()
	}
	pub fn unlink(&self, params: Vec<FilePathWhereParam>) -> LocationSetParam {
		LocationSetParam::UnlinkFilePaths(params)
	}
	pub fn fetch(&self, params: Vec<FilePathWhereParam>) -> LocationWith {
		LocationWithParam::FilePaths(params).into()
	}
}
pub enum LocationWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	NameContains(String),
	NameHasPrefix(String),
	NameHasSuffix(String),
	NameEquals(String),
	LocalPathContains(String),
	LocalPathHasPrefix(String),
	LocalPathHasSuffix(String),
	LocalPathEquals(String),
	TotalCapacityLT(i64),
	TotalCapacityGT(i64),
	TotalCapacityLTE(i64),
	TotalCapacityGTE(i64),
	TotalCapacityEquals(i64),
	AvailableCapacityLT(i64),
	AvailableCapacityGT(i64),
	AvailableCapacityLTE(i64),
	AvailableCapacityGTE(i64),
	AvailableCapacityEquals(i64),
	FilesystemContains(String),
	FilesystemHasPrefix(String),
	FilesystemHasSuffix(String),
	FilesystemEquals(String),
	DiskTypeLT(i64),
	DiskTypeGT(i64),
	DiskTypeLTE(i64),
	DiskTypeGTE(i64),
	DiskTypeEquals(i64),
	IsRemovableEquals(bool),
	IsEjectableEquals(bool),
	IsRootFilesystemEquals(bool),
	IsOnlineEquals(bool),
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	FilePathsSome(Vec<FilePathWhereParam>),
	FilePathsEvery(Vec<FilePathWhereParam>),
	Not(Vec<LocationWhereParam>),
	Or(Vec<LocationWhereParam>),
	And(Vec<LocationWhereParam>),
}
impl LocationWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasPrefix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasSuffix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathContains(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathHasPrefix(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathHasSuffix(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathEquals(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityLT(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityGT(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityLTE(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityGTE(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityEquals(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityLT(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityGT(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityLTE(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityGTE(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityEquals(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemContains(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemHasPrefix(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemHasSuffix(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemEquals(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeLT(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeGT(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeLTE(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeGTE(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeEquals(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsRemovableEquals(value) => Field {
				name: "is_removable".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsEjectableEquals(value) => Field {
				name: "is_ejectable".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsRootFilesystemEquals(value) => Field {
				name: "is_root_filesystem".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsOnlineEquals(value) => Field {
				name: "is_online".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilePathsSome(value) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilePathsEvery(value) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for LocationWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct LocationWith {
	pub param: LocationWithParam,
}
pub enum LocationWithParam {
	FilePaths(Vec<FilePathWhereParam>),
}
impl From<LocationWithParam> for LocationWith {
	fn from(param: LocationWithParam) -> Self {
		Self { param }
	}
}
impl LocationWithParam {
	pub fn output(self) -> Output {
		match self {
			Self::FilePaths(where_params) => Output {
				name: "file_paths".into(),
				outputs: file_path_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params.into_iter().map(|f| f.field()).collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
		}
	}
}
pub enum LocationSetParam {
	Id(i64),
	Name(String),
	LocalPath(String),
	TotalCapacity(i64),
	AvailableCapacity(i64),
	Filesystem(String),
	DiskType(i64),
	IsRemovable(bool),
	IsEjectable(bool),
	IsRootFilesystem(bool),
	IsOnline(bool),
	DateCreated(chrono::DateTime<chrono::Utc>),
	LinkFilePaths(Vec<FilePathWhereParam>),
	UnlinkFilePaths(Vec<FilePathWhereParam>),
}
impl LocationSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LocalPath(value) => Field {
				name: "local_path".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalCapacity(value) => Field {
				name: "total_capacity".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::AvailableCapacity(value) => Field {
				name: "available_capacity".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Filesystem(value) => Field {
				name: "filesystem".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DiskType(value) => Field {
				name: "disk_type".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsRemovable(value) => Field {
				name: "is_removable".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsEjectable(value) => Field {
				name: "is_ejectable".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsRootFilesystem(value) => Field {
				name: "is_root_filesystem".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsOnline(value) => Field {
				name: "is_online".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFilePaths(where_params) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkFilePaths(where_params) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub struct LocationFindMany<'a> {
	query: Query<'a>,
}
impl<'a> LocationFindMany<'a> {
	pub async fn exec(self) -> Vec<LocationData> {
		self.query.perform::<Vec<LocationData>>().await.unwrap()
	}
	pub fn delete(self) -> LocationDelete<'a> {
		LocationDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Location".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LocationSetParam>) -> LocationUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LocationUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<LocationWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LocationFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> LocationFindFirst<'a> {
	pub async fn exec(self) -> Option<LocationData> {
		self.query.perform::<Option<LocationData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LocationWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LocationFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> LocationFindUnique<'a> {
	pub async fn exec(self) -> Option<LocationData> {
		self.query.perform::<Option<LocationData>>().await.unwrap()
	}
	pub fn delete(self) -> LocationDelete<'a> {
		LocationDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Location".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LocationSetParam>) -> LocationUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LocationUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<LocationWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LocationCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> LocationCreateOne<'a> {
	pub async fn exec(self) -> LocationData {
		self.query.perform::<LocationData>().await.unwrap()
	}
}
pub struct LocationUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> LocationUpdateUnique<'a> {
	pub async fn exec(self) -> LocationData {
		self.query.perform::<LocationData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LocationWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LocationUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> LocationUpdateMany<'a> {
	pub async fn exec(self) -> Vec<LocationData> {
		self.query.perform::<Vec<LocationData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LocationWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LocationDelete<'a> {
	query: Query<'a>,
}
impl<'a> LocationDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct LocationActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> LocationActions<'a> {
	pub fn find_unique(&self, param: LocationWhereParam) -> LocationFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Location".into(),
			outputs: location_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LocationFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<LocationWhereParam>) -> LocationFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Location".into(),
			outputs: location_outputs(),
			inputs,
		};
		LocationFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<LocationWhereParam>) -> LocationFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Location".into(),
			outputs: location_outputs(),
			inputs,
		};
		LocationFindMany { query }
	}
	pub fn create_one(&self, params: Vec<LocationSetParam>) -> LocationCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Location".into(),
			outputs: location_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		LocationCreateOne { query }
	}
}
fn file_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("id_hash"),
		Output::new("name"),
		Output::new("extension"),
		Output::new("checksum"),
		Output::new("size_in_bytes"),
		Output::new("encryption"),
		Output::new("date_created"),
		Output::new("date_modified"),
		Output::new("date_indexed"),
		Output::new("ipfs_id"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "id_hash")]
	pub id_hash: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "extension")]
	pub extension: Option<String>,
	#[serde(rename = "checksum")]
	pub checksum: Option<String>,
	#[serde(rename = "size_in_bytes")]
	pub size_in_bytes: String,
	#[serde(rename = "encryption")]
	pub encryption: i64,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_indexed")]
	pub date_indexed: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "ipfs_id")]
	pub ipfs_id: Option<String>,
	#[serde(rename = "file_tags")]
	file_tags: Option<Vec<TagOnFileData>>,
	#[serde(rename = "file_labels")]
	file_labels: Option<Vec<LabelOnFileData>>,
	#[serde(rename = "file_paths")]
	file_paths: Option<Vec<FilePathData>>,
	#[serde(rename = "comments")]
	comments: Option<Vec<CommentData>>,
}
impl FileData {
	pub fn file_tags(&self) -> Result<&Vec<TagOnFileData>, String> {
		match self.file_tags.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access file_tags but did not fetch it using the .with() syntax".to_string()),
		}
	}
	pub fn file_labels(&self) -> Result<&Vec<LabelOnFileData>, String> {
		match self.file_labels.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access file_labels but did not fetch it using the .with() syntax".to_string()),
		}
	}
	pub fn file_paths(&self) -> Result<&Vec<FilePathData>, String> {
		match self.file_paths.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access file_paths but did not fetch it using the .with() syntax".to_string()),
		}
	}
	pub fn comments(&self) -> Result<&Vec<CommentData>, String> {
		match self.comments.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access comments but did not fetch it using the .with() syntax".to_string()),
		}
	}
}
pub struct File;
impl File {
	pub fn id() -> FileIdField {
		FileIdField {}
	}
	pub fn id_hash() -> FileIdHashField {
		FileIdHashField {}
	}
	pub fn name() -> FileNameField {
		FileNameField {}
	}
	pub fn extension() -> FileExtensionField {
		FileExtensionField {}
	}
	pub fn checksum() -> FileChecksumField {
		FileChecksumField {}
	}
	pub fn size_in_bytes() -> FileSizeInBytesField {
		FileSizeInBytesField {}
	}
	pub fn encryption() -> FileEncryptionField {
		FileEncryptionField {}
	}
	pub fn date_created() -> FileDateCreatedField {
		FileDateCreatedField {}
	}
	pub fn date_modified() -> FileDateModifiedField {
		FileDateModifiedField {}
	}
	pub fn date_indexed() -> FileDateIndexedField {
		FileDateIndexedField {}
	}
	pub fn ipfs_id() -> FileIpfsIdField {
		FileIpfsIdField {}
	}
	pub fn file_tags() -> FileFileTagsField {
		FileFileTagsField {}
	}
	pub fn file_labels() -> FileFileLabelsField {
		FileFileLabelsField {}
	}
	pub fn file_paths() -> FileFilePathsField {
		FileFilePathsField {}
	}
	pub fn comments() -> FileCommentsField {
		FileCommentsField {}
	}
}
pub struct FileIdField {}
pub struct FileSetId(i64);
impl From<FileSetId> for FileSetParam {
	fn from(value: FileSetId) -> Self {
		Self::Id(value.0)
	}
}
impl FileIdField {
	pub fn lt(&self, value: i64) -> FileWhereParam {
		FileWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> FileWhereParam {
		FileWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> FileWhereParam {
		FileWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> FileWhereParam {
		FileWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> FileWhereParam {
		FileWhereParam::IdEquals(value)
	}
	pub fn set<T: From<FileSetId>>(&self, value: i64) -> T {
		FileSetId(value).into()
	}
}
pub struct FileIdHashField {}
pub struct FileSetIdHash(String);
impl From<FileSetIdHash> for FileSetParam {
	fn from(value: FileSetIdHash) -> Self {
		Self::IdHash(value.0)
	}
}
impl FileIdHashField {
	pub fn contains(&self, value: String) -> FileWhereParam {
		FileWhereParam::IdHashContains(value)
	}
	pub fn has_prefix(&self, value: String) -> FileWhereParam {
		FileWhereParam::IdHashHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> FileWhereParam {
		FileWhereParam::IdHashHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> FileWhereParam {
		FileWhereParam::IdHashEquals(value)
	}
	pub fn set<T: From<FileSetIdHash>>(&self, value: String) -> T {
		FileSetIdHash(value).into()
	}
}
pub struct FileNameField {}
pub struct FileSetName(String);
impl From<FileSetName> for FileSetParam {
	fn from(value: FileSetName) -> Self {
		Self::Name(value.0)
	}
}
impl FileNameField {
	pub fn contains(&self, value: String) -> FileWhereParam {
		FileWhereParam::NameContains(value)
	}
	pub fn has_prefix(&self, value: String) -> FileWhereParam {
		FileWhereParam::NameHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> FileWhereParam {
		FileWhereParam::NameHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> FileWhereParam {
		FileWhereParam::NameEquals(value)
	}
	pub fn set<T: From<FileSetName>>(&self, value: String) -> T {
		FileSetName(value).into()
	}
}
pub struct FileExtensionField {}
pub struct FileSetExtension(String);
impl From<FileSetExtension> for FileSetParam {
	fn from(value: FileSetExtension) -> Self {
		Self::Extension(value.0)
	}
}
impl FileExtensionField {
	pub fn contains(&self, value: String) -> FileWhereParam {
		FileWhereParam::ExtensionContains(value)
	}
	pub fn has_prefix(&self, value: String) -> FileWhereParam {
		FileWhereParam::ExtensionHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> FileWhereParam {
		FileWhereParam::ExtensionHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> FileWhereParam {
		FileWhereParam::ExtensionEquals(value)
	}
	pub fn set<T: From<FileSetExtension>>(&self, value: String) -> T {
		FileSetExtension(value).into()
	}
}
pub struct FileChecksumField {}
pub struct FileSetChecksum(String);
impl From<FileSetChecksum> for FileSetParam {
	fn from(value: FileSetChecksum) -> Self {
		Self::Checksum(value.0)
	}
}
impl FileChecksumField {
	pub fn contains(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumContains(value)
	}
	pub fn has_prefix(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumEquals(value)
	}
	pub fn set<T: From<FileSetChecksum>>(&self, value: String) -> T {
		FileSetChecksum(value).into()
	}
}
pub struct FileSizeInBytesField {}
pub struct FileSetSizeInBytes(String);
impl From<FileSetSizeInBytes> for FileSetParam {
	fn from(value: FileSetSizeInBytes) -> Self {
		Self::SizeInBytes(value.0)
	}
}
impl FileSizeInBytesField {
	pub fn contains(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesContains(value)
	}
	pub fn has_prefix(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesEquals(value)
	}
	pub fn set<T: From<FileSetSizeInBytes>>(&self, value: String) -> T {
		FileSetSizeInBytes(value).into()
	}
}
pub struct FileEncryptionField {}
pub struct FileSetEncryption(i64);
impl From<FileSetEncryption> for FileSetParam {
	fn from(value: FileSetEncryption) -> Self {
		Self::Encryption(value.0)
	}
}
impl FileEncryptionField {
	pub fn lt(&self, value: i64) -> FileWhereParam {
		FileWhereParam::EncryptionLT(value)
	}
	pub fn gt(&self, value: i64) -> FileWhereParam {
		FileWhereParam::EncryptionGT(value)
	}
	pub fn lte(&self, value: i64) -> FileWhereParam {
		FileWhereParam::EncryptionLTE(value)
	}
	pub fn gte(&self, value: i64) -> FileWhereParam {
		FileWhereParam::EncryptionGTE(value)
	}
	pub fn equals(&self, value: i64) -> FileWhereParam {
		FileWhereParam::EncryptionEquals(value)
	}
	pub fn set<T: From<FileSetEncryption>>(&self, value: i64) -> T {
		FileSetEncryption(value).into()
	}
}
pub struct FileDateCreatedField {}
pub struct FileSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<FileSetDateCreated> for FileSetParam {
	fn from(value: FileSetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl FileDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<FileSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		FileSetDateCreated(value).into()
	}
}
pub struct FileDateModifiedField {}
pub struct FileSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<FileSetDateModified> for FileSetParam {
	fn from(value: FileSetDateModified) -> Self {
		Self::DateModified(value.0)
	}
}
impl FileDateModifiedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateModifiedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateModifiedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateModifiedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateModifiedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateModifiedEquals(value)
	}
	pub fn set<T: From<FileSetDateModified>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		FileSetDateModified(value).into()
	}
}
pub struct FileDateIndexedField {}
pub struct FileSetDateIndexed(chrono::DateTime<chrono::Utc>);
impl From<FileSetDateIndexed> for FileSetParam {
	fn from(value: FileSetDateIndexed) -> Self {
		Self::DateIndexed(value.0)
	}
}
impl FileDateIndexedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateIndexedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateIndexedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateIndexedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateIndexedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateIndexedEquals(value)
	}
	pub fn set<T: From<FileSetDateIndexed>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		FileSetDateIndexed(value).into()
	}
}
pub struct FileIpfsIdField {}
pub struct FileSetIpfsId(String);
impl From<FileSetIpfsId> for FileSetParam {
	fn from(value: FileSetIpfsId) -> Self {
		Self::IpfsId(value.0)
	}
}
impl FileIpfsIdField {
	pub fn contains(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdContains(value)
	}
	pub fn has_prefix(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdEquals(value)
	}
	pub fn set<T: From<FileSetIpfsId>>(&self, value: String) -> T {
		FileSetIpfsId(value).into()
	}
}
pub struct FileFileTagsField {}
pub struct FileLinkFileTags(Vec<TagOnFileWhereParam>);
impl From<FileLinkFileTags> for FileSetParam {
	fn from(value: FileLinkFileTags) -> Self {
		Self::LinkFileTags(value.0.into_iter().map(|v| v.into()).collect())
	}
}
impl FileFileTagsField {
	pub fn some(&self, value: Vec<TagOnFileWhereParam>) -> FileWhereParam {
		FileWhereParam::FileTagsSome(value)
	}
	pub fn every(&self, value: Vec<TagOnFileWhereParam>) -> FileWhereParam {
		FileWhereParam::FileTagsEvery(value)
	}
	pub fn link<T: From<FileLinkFileTags>>(&self, value: Vec<TagOnFileWhereParam>) -> T {
		FileLinkFileTags(value).into()
	}
	pub fn unlink(&self, params: Vec<TagOnFileWhereParam>) -> FileSetParam {
		FileSetParam::UnlinkFileTags(params)
	}
	pub fn fetch(&self, params: Vec<TagOnFileWhereParam>) -> FileWith {
		FileWithParam::FileTags(params).into()
	}
}
pub struct FileFileLabelsField {}
pub struct FileLinkFileLabels(Vec<LabelOnFileWhereParam>);
impl From<FileLinkFileLabels> for FileSetParam {
	fn from(value: FileLinkFileLabels) -> Self {
		Self::LinkFileLabels(value.0.into_iter().map(|v| v.into()).collect())
	}
}
impl FileFileLabelsField {
	pub fn some(&self, value: Vec<LabelOnFileWhereParam>) -> FileWhereParam {
		FileWhereParam::FileLabelsSome(value)
	}
	pub fn every(&self, value: Vec<LabelOnFileWhereParam>) -> FileWhereParam {
		FileWhereParam::FileLabelsEvery(value)
	}
	pub fn link<T: From<FileLinkFileLabels>>(&self, value: Vec<LabelOnFileWhereParam>) -> T {
		FileLinkFileLabels(value).into()
	}
	pub fn unlink(&self, params: Vec<LabelOnFileWhereParam>) -> FileSetParam {
		FileSetParam::UnlinkFileLabels(params)
	}
	pub fn fetch(&self, params: Vec<LabelOnFileWhereParam>) -> FileWith {
		FileWithParam::FileLabels(params).into()
	}
}
pub struct FileFilePathsField {}
pub struct FileLinkFilePaths(Vec<FilePathWhereParam>);
impl From<FileLinkFilePaths> for FileSetParam {
	fn from(value: FileLinkFilePaths) -> Self {
		Self::LinkFilePaths(value.0.into_iter().map(|v| v.into()).collect())
	}
}
impl FileFilePathsField {
	pub fn some(&self, value: Vec<FilePathWhereParam>) -> FileWhereParam {
		FileWhereParam::FilePathsSome(value)
	}
	pub fn every(&self, value: Vec<FilePathWhereParam>) -> FileWhereParam {
		FileWhereParam::FilePathsEvery(value)
	}
	pub fn link<T: From<FileLinkFilePaths>>(&self, value: Vec<FilePathWhereParam>) -> T {
		FileLinkFilePaths(value).into()
	}
	pub fn unlink(&self, params: Vec<FilePathWhereParam>) -> FileSetParam {
		FileSetParam::UnlinkFilePaths(params)
	}
	pub fn fetch(&self, params: Vec<FilePathWhereParam>) -> FileWith {
		FileWithParam::FilePaths(params).into()
	}
}
pub struct FileCommentsField {}
pub struct FileLinkComments(Vec<CommentWhereParam>);
impl From<FileLinkComments> for FileSetParam {
	fn from(value: FileLinkComments) -> Self {
		Self::LinkComments(value.0.into_iter().map(|v| v.into()).collect())
	}
}
impl FileCommentsField {
	pub fn some(&self, value: Vec<CommentWhereParam>) -> FileWhereParam {
		FileWhereParam::CommentsSome(value)
	}
	pub fn every(&self, value: Vec<CommentWhereParam>) -> FileWhereParam {
		FileWhereParam::CommentsEvery(value)
	}
	pub fn link<T: From<FileLinkComments>>(&self, value: Vec<CommentWhereParam>) -> T {
		FileLinkComments(value).into()
	}
	pub fn unlink(&self, params: Vec<CommentWhereParam>) -> FileSetParam {
		FileSetParam::UnlinkComments(params)
	}
	pub fn fetch(&self, params: Vec<CommentWhereParam>) -> FileWith {
		FileWithParam::Comments(params).into()
	}
}
pub enum FileWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	IdHashContains(String),
	IdHashHasPrefix(String),
	IdHashHasSuffix(String),
	IdHashEquals(String),
	NameContains(String),
	NameHasPrefix(String),
	NameHasSuffix(String),
	NameEquals(String),
	ExtensionContains(String),
	ExtensionHasPrefix(String),
	ExtensionHasSuffix(String),
	ExtensionEquals(String),
	ChecksumContains(String),
	ChecksumHasPrefix(String),
	ChecksumHasSuffix(String),
	ChecksumEquals(String),
	SizeInBytesContains(String),
	SizeInBytesHasPrefix(String),
	SizeInBytesHasSuffix(String),
	SizeInBytesEquals(String),
	EncryptionLT(i64),
	EncryptionGT(i64),
	EncryptionLTE(i64),
	EncryptionGTE(i64),
	EncryptionEquals(i64),
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedBefore(chrono::DateTime<chrono::Utc>),
	DateModifiedAfter(chrono::DateTime<chrono::Utc>),
	DateModifiedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	DateIndexedBefore(chrono::DateTime<chrono::Utc>),
	DateIndexedAfter(chrono::DateTime<chrono::Utc>),
	DateIndexedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateIndexedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateIndexedEquals(chrono::DateTime<chrono::Utc>),
	IpfsIdContains(String),
	IpfsIdHasPrefix(String),
	IpfsIdHasSuffix(String),
	IpfsIdEquals(String),
	FileTagsSome(Vec<TagOnFileWhereParam>),
	FileTagsEvery(Vec<TagOnFileWhereParam>),
	FileLabelsSome(Vec<LabelOnFileWhereParam>),
	FileLabelsEvery(Vec<LabelOnFileWhereParam>),
	FilePathsSome(Vec<FilePathWhereParam>),
	FilePathsEvery(Vec<FilePathWhereParam>),
	CommentsSome(Vec<CommentWhereParam>),
	CommentsEvery(Vec<CommentWhereParam>),
	Not(Vec<FileWhereParam>),
	Or(Vec<FileWhereParam>),
	And(Vec<FileWhereParam>),
}
impl FileWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdHashContains(value) => Field {
				name: "id_hash".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdHashHasPrefix(value) => Field {
				name: "id_hash".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdHashHasSuffix(value) => Field {
				name: "id_hash".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdHashEquals(value) => Field {
				name: "id_hash".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasPrefix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasSuffix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionContains(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionHasPrefix(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionHasSuffix(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionEquals(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumContains(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumHasPrefix(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumHasSuffix(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumEquals(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesContains(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesHasPrefix(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesHasSuffix(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesEquals(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLT(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGT(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLTE(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGTE(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionEquals(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBefore(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfter(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBeforeEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfterEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedBefore(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedAfter(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedBeforeEquals(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedAfterEquals(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedEquals(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdContains(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdHasPrefix(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdHasSuffix(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdEquals(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileTagsSome(value) => Field {
				name: "file_tags".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileTagsEvery(value) => Field {
				name: "file_tags".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileLabelsSome(value) => Field {
				name: "file_labels".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileLabelsEvery(value) => Field {
				name: "file_labels".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilePathsSome(value) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilePathsEvery(value) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CommentsSome(value) => Field {
				name: "comments".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CommentsEvery(value) => Field {
				name: "comments".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for FileWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct FileWith {
	pub param: FileWithParam,
}
pub enum FileWithParam {
	FileTags(Vec<TagOnFileWhereParam>),
	FileLabels(Vec<LabelOnFileWhereParam>),
	FilePaths(Vec<FilePathWhereParam>),
	Comments(Vec<CommentWhereParam>),
}
impl From<FileWithParam> for FileWith {
	fn from(param: FileWithParam) -> Self {
		Self { param }
	}
}
impl FileWithParam {
	pub fn output(self) -> Output {
		match self {
			Self::FileTags(where_params) => Output {
				name: "file_tags".into(),
				outputs: tag_on_file_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params.into_iter().map(|f| f.field()).collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
			Self::FileLabels(where_params) => Output {
				name: "file_labels".into(),
				outputs: label_on_file_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params.into_iter().map(|f| f.field()).collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
			Self::FilePaths(where_params) => Output {
				name: "file_paths".into(),
				outputs: file_path_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params.into_iter().map(|f| f.field()).collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
			Self::Comments(where_params) => Output {
				name: "comments".into(),
				outputs: comment_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params.into_iter().map(|f| f.field()).collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
		}
	}
}
pub enum FileSetParam {
	Id(i64),
	IdHash(String),
	Name(String),
	Extension(String),
	Checksum(String),
	SizeInBytes(String),
	Encryption(i64),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
	DateIndexed(chrono::DateTime<chrono::Utc>),
	IpfsId(String),
	LinkFileTags(Vec<TagOnFileWhereParam>),
	UnlinkFileTags(Vec<TagOnFileWhereParam>),
	LinkFileLabels(Vec<LabelOnFileWhereParam>),
	UnlinkFileLabels(Vec<LabelOnFileWhereParam>),
	LinkFilePaths(Vec<FilePathWhereParam>),
	UnlinkFilePaths(Vec<FilePathWhereParam>),
	LinkComments(Vec<CommentWhereParam>),
	UnlinkComments(Vec<CommentWhereParam>),
}
impl FileSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IdHash(value) => Field {
				name: "id_hash".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Extension(value) => Field {
				name: "extension".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Checksum(value) => Field {
				name: "checksum".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SizeInBytes(value) => Field {
				name: "size_in_bytes".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Encryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateIndexed(value) => Field {
				name: "date_indexed".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IpfsId(value) => Field {
				name: "ipfs_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFileTags(where_params) => Field {
				name: "file_tags".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkFileTags(where_params) => Field {
				name: "file_tags".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LinkFileLabels(where_params) => Field {
				name: "file_labels".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkFileLabels(where_params) => Field {
				name: "file_labels".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LinkFilePaths(where_params) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkFilePaths(where_params) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LinkComments(where_params) => Field {
				name: "comments".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkComments(where_params) => Field {
				name: "comments".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub struct FileFindMany<'a> {
	query: Query<'a>,
}
impl<'a> FileFindMany<'a> {
	pub async fn exec(self) -> Vec<FileData> {
		self.query.perform::<Vec<FileData>>().await.unwrap()
	}
	pub fn delete(self) -> FileDelete<'a> {
		FileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "File".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<FileSetParam>) -> FileUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		FileUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<FileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct FileFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> FileFindFirst<'a> {
	pub async fn exec(self) -> Option<FileData> {
		self.query.perform::<Option<FileData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<FileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct FileFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> FileFindUnique<'a> {
	pub async fn exec(self) -> Option<FileData> {
		self.query.perform::<Option<FileData>>().await.unwrap()
	}
	pub fn delete(self) -> FileDelete<'a> {
		FileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "File".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<FileSetParam>) -> FileUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		FileUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<FileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct FileCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> FileCreateOne<'a> {
	pub async fn exec(self) -> FileData {
		self.query.perform::<FileData>().await.unwrap()
	}
}
pub struct FileUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> FileUpdateUnique<'a> {
	pub async fn exec(self) -> FileData {
		self.query.perform::<FileData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<FileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct FileUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> FileUpdateMany<'a> {
	pub async fn exec(self) -> Vec<FileData> {
		self.query.perform::<Vec<FileData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<FileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct FileDelete<'a> {
	query: Query<'a>,
}
impl<'a> FileDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct FileActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> FileActions<'a> {
	pub fn find_unique(&self, param: FileWhereParam) -> FileFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "File".into(),
			outputs: file_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		FileFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<FileWhereParam>) -> FileFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "File".into(),
			outputs: file_outputs(),
			inputs,
		};
		FileFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<FileWhereParam>) -> FileFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "File".into(),
			outputs: file_outputs(),
			inputs,
		};
		FileFindMany { query }
	}
	pub fn create_one(
		&self,
		id_hash: FileSetIdHash,
		name: FileSetName,
		size_in_bytes: FileSetSizeInBytes,
		params: Vec<FileSetParam>,
	) -> FileCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(FileSetParam::from(id_hash).field());
		input_fields.push(FileSetParam::from(name).field());
		input_fields.push(FileSetParam::from(size_in_bytes).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "File".into(),
			outputs: file_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		FileCreateOne { query }
	}
}
fn file_path_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("is_dir"),
		Output::new("materialized_path"),
		Output::new("file_id"),
		Output::new("parent_id"),
		Output::new("location_id"),
		Output::new("date_indexed"),
		Output::new("permissions"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FilePathData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "is_dir")]
	pub is_dir: bool,
	#[serde(rename = "materialized_path")]
	pub materialized_path: String,
	#[serde(rename = "file_id")]
	pub file_id: Option<i64>,
	#[serde(rename = "file")]
	pub file: Box<Option<FileData>>,
	#[serde(rename = "parent_id")]
	pub parent_id: Option<i64>,
	#[serde(rename = "parent")]
	pub parent: Box<Option<FilePathData>>,
	#[serde(rename = "children")]
	children: Option<Vec<FilePathData>>,
	#[serde(rename = "location_id")]
	pub location_id: i64,
	#[serde(rename = "location")]
	pub location: Box<Option<LocationData>>,
	#[serde(rename = "date_indexed")]
	pub date_indexed: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "permissions")]
	pub permissions: Option<String>,
}
impl FilePathData {
	pub fn file(&self) -> Option<&FileData> {
		self.file.as_ref().as_ref()
	}
	pub fn parent(&self) -> Option<&FilePathData> {
		self.parent.as_ref().as_ref()
	}
	pub fn children(&self) -> Result<&Vec<FilePathData>, String> {
		match self.children.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access children but did not fetch it using the .with() syntax".to_string()),
		}
	}
	pub fn location(&self) -> Option<&LocationData> {
		self.location.as_ref().as_ref()
	}
}
pub struct FilePath;
impl FilePath {
	pub fn id() -> FilePathIdField {
		FilePathIdField {}
	}
	pub fn is_dir() -> FilePathIsDirField {
		FilePathIsDirField {}
	}
	pub fn materialized_path() -> FilePathMaterializedPathField {
		FilePathMaterializedPathField {}
	}
	pub fn file_id() -> FilePathFileIdField {
		FilePathFileIdField {}
	}
	pub fn file() -> FilePathFileField {
		FilePathFileField {}
	}
	pub fn parent_id() -> FilePathParentIdField {
		FilePathParentIdField {}
	}
	pub fn parent() -> FilePathParentField {
		FilePathParentField {}
	}
	pub fn children() -> FilePathChildrenField {
		FilePathChildrenField {}
	}
	pub fn location_id() -> FilePathLocationIdField {
		FilePathLocationIdField {}
	}
	pub fn location() -> FilePathLocationField {
		FilePathLocationField {}
	}
	pub fn date_indexed() -> FilePathDateIndexedField {
		FilePathDateIndexedField {}
	}
	pub fn permissions() -> FilePathPermissionsField {
		FilePathPermissionsField {}
	}
}
pub struct FilePathIdField {}
pub struct FilePathSetId(i64);
impl From<FilePathSetId> for FilePathSetParam {
	fn from(value: FilePathSetId) -> Self {
		Self::Id(value.0)
	}
}
impl FilePathIdField {
	pub fn lt(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::IdEquals(value)
	}
	pub fn set<T: From<FilePathSetId>>(&self, value: i64) -> T {
		FilePathSetId(value).into()
	}
}
pub struct FilePathIsDirField {}
pub struct FilePathSetIsDir(bool);
impl From<FilePathSetIsDir> for FilePathSetParam {
	fn from(value: FilePathSetIsDir) -> Self {
		Self::IsDir(value.0)
	}
}
impl FilePathIsDirField {
	pub fn equals(&self, value: bool) -> FilePathWhereParam {
		FilePathWhereParam::IsDirEquals(value)
	}
	pub fn set<T: From<FilePathSetIsDir>>(&self, value: bool) -> T {
		FilePathSetIsDir(value).into()
	}
}
pub struct FilePathMaterializedPathField {}
pub struct FilePathSetMaterializedPath(String);
impl From<FilePathSetMaterializedPath> for FilePathSetParam {
	fn from(value: FilePathSetMaterializedPath) -> Self {
		Self::MaterializedPath(value.0)
	}
}
impl FilePathMaterializedPathField {
	pub fn contains(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathContains(value)
	}
	pub fn has_prefix(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathEquals(value)
	}
	pub fn set<T: From<FilePathSetMaterializedPath>>(&self, value: String) -> T {
		FilePathSetMaterializedPath(value).into()
	}
}
pub struct FilePathFileIdField {}
pub struct FilePathSetFileId(i64);
impl From<FilePathSetFileId> for FilePathSetParam {
	fn from(value: FilePathSetFileId) -> Self {
		Self::FileId(value.0)
	}
}
impl FilePathFileIdField {
	pub fn lt(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::FileIdLT(value)
	}
	pub fn gt(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::FileIdGT(value)
	}
	pub fn lte(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::FileIdLTE(value)
	}
	pub fn gte(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::FileIdGTE(value)
	}
	pub fn equals(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::FileIdEquals(value)
	}
	pub fn set<T: From<FilePathSetFileId>>(&self, value: i64) -> T {
		FilePathSetFileId(value).into()
	}
}
pub struct FilePathFileField {}
pub struct FilePathLinkFile(FileWhereParam);
impl From<FilePathLinkFile> for FilePathSetParam {
	fn from(value: FilePathLinkFile) -> Self {
		Self::LinkFile(value.0)
	}
}
impl FilePathFileField {
	pub fn is(&self, value: Vec<FileWhereParam>) -> FilePathWhereParam {
		FilePathWhereParam::FileIs(value)
	}
	pub fn link<T: From<FilePathLinkFile>>(&self, value: FileWhereParam) -> T {
		FilePathLinkFile(value).into()
	}
	pub fn fetch(&self) -> FilePathWith {
		FilePathWithParam::File.into()
	}
	pub fn unlink(&self) -> FilePathSetParam {
		FilePathSetParam::UnlinkFile
	}
}
pub struct FilePathParentIdField {}
pub struct FilePathSetParentId(i64);
impl From<FilePathSetParentId> for FilePathSetParam {
	fn from(value: FilePathSetParentId) -> Self {
		Self::ParentId(value.0)
	}
}
impl FilePathParentIdField {
	pub fn lt(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdLT(value)
	}
	pub fn gt(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdGT(value)
	}
	pub fn lte(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdLTE(value)
	}
	pub fn gte(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdGTE(value)
	}
	pub fn equals(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdEquals(value)
	}
	pub fn set<T: From<FilePathSetParentId>>(&self, value: i64) -> T {
		FilePathSetParentId(value).into()
	}
}
pub struct FilePathParentField {}
pub struct FilePathLinkParent(FilePathWhereParam);
impl From<FilePathLinkParent> for FilePathSetParam {
	fn from(value: FilePathLinkParent) -> Self {
		Self::LinkParent(value.0)
	}
}
impl FilePathParentField {
	pub fn is(&self, value: Vec<FilePathWhereParam>) -> FilePathWhereParam {
		FilePathWhereParam::ParentIs(value)
	}
	pub fn link<T: From<FilePathLinkParent>>(&self, value: FilePathWhereParam) -> T {
		FilePathLinkParent(value).into()
	}
	pub fn fetch(&self) -> FilePathWith {
		FilePathWithParam::Parent.into()
	}
	pub fn unlink(&self) -> FilePathSetParam {
		FilePathSetParam::UnlinkParent
	}
}
pub struct FilePathChildrenField {}
pub struct FilePathLinkChildren(Vec<FilePathWhereParam>);
impl From<FilePathLinkChildren> for FilePathSetParam {
	fn from(value: FilePathLinkChildren) -> Self {
		Self::LinkChildren(value.0.into_iter().map(|v| v.into()).collect())
	}
}
impl FilePathChildrenField {
	pub fn some(&self, value: Vec<FilePathWhereParam>) -> FilePathWhereParam {
		FilePathWhereParam::ChildrenSome(value)
	}
	pub fn every(&self, value: Vec<FilePathWhereParam>) -> FilePathWhereParam {
		FilePathWhereParam::ChildrenEvery(value)
	}
	pub fn link<T: From<FilePathLinkChildren>>(&self, value: Vec<FilePathWhereParam>) -> T {
		FilePathLinkChildren(value).into()
	}
	pub fn unlink(&self, params: Vec<FilePathWhereParam>) -> FilePathSetParam {
		FilePathSetParam::UnlinkChildren(params)
	}
	pub fn fetch(&self, params: Vec<FilePathWhereParam>) -> FilePathWith {
		FilePathWithParam::Children(params).into()
	}
}
pub struct FilePathLocationIdField {}
pub struct FilePathSetLocationId(i64);
impl From<FilePathSetLocationId> for FilePathSetParam {
	fn from(value: FilePathSetLocationId) -> Self {
		Self::LocationId(value.0)
	}
}
impl FilePathLocationIdField {
	pub fn lt(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdLT(value)
	}
	pub fn gt(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdGT(value)
	}
	pub fn lte(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdLTE(value)
	}
	pub fn gte(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdGTE(value)
	}
	pub fn equals(&self, value: i64) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdEquals(value)
	}
	pub fn set<T: From<FilePathSetLocationId>>(&self, value: i64) -> T {
		FilePathSetLocationId(value).into()
	}
}
pub struct FilePathLocationField {}
pub struct FilePathLinkLocation(LocationWhereParam);
impl From<FilePathLinkLocation> for FilePathSetParam {
	fn from(value: FilePathLinkLocation) -> Self {
		Self::LinkLocation(value.0)
	}
}
impl FilePathLocationField {
	pub fn is(&self, value: Vec<LocationWhereParam>) -> FilePathWhereParam {
		FilePathWhereParam::LocationIs(value)
	}
	pub fn link<T: From<FilePathLinkLocation>>(&self, value: LocationWhereParam) -> T {
		FilePathLinkLocation(value).into()
	}
	pub fn fetch(&self) -> FilePathWith {
		FilePathWithParam::Location.into()
	}
	pub fn unlink(&self) -> FilePathSetParam {
		FilePathSetParam::UnlinkLocation
	}
}
pub struct FilePathDateIndexedField {}
pub struct FilePathSetDateIndexed(chrono::DateTime<chrono::Utc>);
impl From<FilePathSetDateIndexed> for FilePathSetParam {
	fn from(value: FilePathSetDateIndexed) -> Self {
		Self::DateIndexed(value.0)
	}
}
impl FilePathDateIndexedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedEquals(value)
	}
	pub fn set<T: From<FilePathSetDateIndexed>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		FilePathSetDateIndexed(value).into()
	}
}
pub struct FilePathPermissionsField {}
pub struct FilePathSetPermissions(String);
impl From<FilePathSetPermissions> for FilePathSetParam {
	fn from(value: FilePathSetPermissions) -> Self {
		Self::Permissions(value.0)
	}
}
impl FilePathPermissionsField {
	pub fn contains(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsContains(value)
	}
	pub fn has_prefix(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsEquals(value)
	}
	pub fn set<T: From<FilePathSetPermissions>>(&self, value: String) -> T {
		FilePathSetPermissions(value).into()
	}
}
pub enum FilePathWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	IsDirEquals(bool),
	MaterializedPathContains(String),
	MaterializedPathHasPrefix(String),
	MaterializedPathHasSuffix(String),
	MaterializedPathEquals(String),
	FileIdLT(i64),
	FileIdGT(i64),
	FileIdLTE(i64),
	FileIdGTE(i64),
	FileIdEquals(i64),
	FileIs(Vec<FileWhereParam>),
	ParentIdLT(i64),
	ParentIdGT(i64),
	ParentIdLTE(i64),
	ParentIdGTE(i64),
	ParentIdEquals(i64),
	ParentIs(Vec<FilePathWhereParam>),
	ChildrenSome(Vec<FilePathWhereParam>),
	ChildrenEvery(Vec<FilePathWhereParam>),
	LocationIdLT(i64),
	LocationIdGT(i64),
	LocationIdLTE(i64),
	LocationIdGTE(i64),
	LocationIdEquals(i64),
	LocationIs(Vec<LocationWhereParam>),
	DateIndexedBefore(chrono::DateTime<chrono::Utc>),
	DateIndexedAfter(chrono::DateTime<chrono::Utc>),
	DateIndexedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateIndexedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateIndexedEquals(chrono::DateTime<chrono::Utc>),
	PermissionsContains(String),
	PermissionsHasPrefix(String),
	PermissionsHasSuffix(String),
	PermissionsEquals(String),
	Not(Vec<FilePathWhereParam>),
	Or(Vec<FilePathWhereParam>),
	And(Vec<FilePathWhereParam>),
}
impl FilePathWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsDirEquals(value) => Field {
				name: "is_dir".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathContains(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathHasPrefix(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathHasSuffix(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathEquals(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLT(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGT(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLTE(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGTE(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdEquals(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIs(value) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdLT(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdGT(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdLTE(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdGTE(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdEquals(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIs(value) => Field {
				name: "parent".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChildrenSome(value) => Field {
				name: "children".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChildrenEvery(value) => Field {
				name: "children".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdLT(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdGT(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdLTE(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdGTE(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdEquals(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIs(value) => Field {
				name: "location".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedBefore(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedAfter(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedBeforeEquals(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedAfterEquals(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedEquals(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsContains(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsHasPrefix(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsHasSuffix(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsEquals(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for FilePathWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct FilePathWith {
	pub param: FilePathWithParam,
}
pub enum FilePathWithParam {
	File,
	Parent,
	Children(Vec<FilePathWhereParam>),
	Location,
}
impl From<FilePathWithParam> for FilePathWith {
	fn from(param: FilePathWithParam) -> Self {
		Self { param }
	}
}
impl FilePathWithParam {
	pub fn output(self) -> Output {
		match self {
			Self::File => Output {
				name: "file".into(),
				outputs: file_outputs(),
				..Default::default()
			},
			Self::Parent => Output {
				name: "parent".into(),
				outputs: file_path_outputs(),
				..Default::default()
			},
			Self::Children(where_params) => Output {
				name: "children".into(),
				outputs: file_path_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params.into_iter().map(|f| f.field()).collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
			Self::Location => Output {
				name: "location".into(),
				outputs: location_outputs(),
				..Default::default()
			},
		}
	}
}
pub enum FilePathSetParam {
	Id(i64),
	IsDir(bool),
	MaterializedPath(String),
	FileId(i64),
	LinkFile(FileWhereParam),
	UnlinkFile,
	ParentId(i64),
	LinkParent(FilePathWhereParam),
	UnlinkParent,
	LinkChildren(Vec<FilePathWhereParam>),
	UnlinkChildren(Vec<FilePathWhereParam>),
	LocationId(i64),
	LinkLocation(LocationWhereParam),
	UnlinkLocation,
	DateIndexed(chrono::DateTime<chrono::Utc>),
	Permissions(String),
}
impl FilePathSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsDir(value) => Field {
				name: "is_dir".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::MaterializedPath(value) => Field {
				name: "materialized_path".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::FileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFile(where_param) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![where_param.field()])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkFile => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					value: Some(true.into()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentId(value) => Field {
				name: "parent_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkParent(where_param) => Field {
				name: "parent".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![where_param.field()])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkParent => Field {
				name: "parent".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					value: Some(true.into()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LinkChildren(where_params) => Field {
				name: "children".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkChildren(where_params) => Field {
				name: "children".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationId(value) => Field {
				name: "location_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkLocation(where_param) => Field {
				name: "location".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![where_param.field()])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkLocation => Field {
				name: "location".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					value: Some(true.into()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexed(value) => Field {
				name: "date_indexed".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Permissions(value) => Field {
				name: "permissions".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub struct FilePathFindMany<'a> {
	query: Query<'a>,
}
impl<'a> FilePathFindMany<'a> {
	pub async fn exec(self) -> Vec<FilePathData> {
		self.query.perform::<Vec<FilePathData>>().await.unwrap()
	}
	pub fn delete(self) -> FilePathDelete<'a> {
		FilePathDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "FilePath".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<FilePathSetParam>) -> FilePathUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		FilePathUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<FilePathWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct FilePathFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> FilePathFindFirst<'a> {
	pub async fn exec(self) -> Option<FilePathData> {
		self.query.perform::<Option<FilePathData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<FilePathWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct FilePathFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> FilePathFindUnique<'a> {
	pub async fn exec(self) -> Option<FilePathData> {
		self.query.perform::<Option<FilePathData>>().await.unwrap()
	}
	pub fn delete(self) -> FilePathDelete<'a> {
		FilePathDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "FilePath".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<FilePathSetParam>) -> FilePathUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		FilePathUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<FilePathWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct FilePathCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> FilePathCreateOne<'a> {
	pub async fn exec(self) -> FilePathData {
		self.query.perform::<FilePathData>().await.unwrap()
	}
}
pub struct FilePathUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> FilePathUpdateUnique<'a> {
	pub async fn exec(self) -> FilePathData {
		self.query.perform::<FilePathData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<FilePathWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct FilePathUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> FilePathUpdateMany<'a> {
	pub async fn exec(self) -> Vec<FilePathData> {
		self.query.perform::<Vec<FilePathData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<FilePathWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct FilePathDelete<'a> {
	query: Query<'a>,
}
impl<'a> FilePathDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct FilePathActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> FilePathActions<'a> {
	pub fn find_unique(&self, param: FilePathWhereParam) -> FilePathFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "FilePath".into(),
			outputs: file_path_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		FilePathFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<FilePathWhereParam>) -> FilePathFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "FilePath".into(),
			outputs: file_path_outputs(),
			inputs,
		};
		FilePathFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<FilePathWhereParam>) -> FilePathFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "FilePath".into(),
			outputs: file_path_outputs(),
			inputs,
		};
		FilePathFindMany { query }
	}
	pub fn create_one(
		&self,
		materialized_path: FilePathSetMaterializedPath,
		params: Vec<FilePathSetParam>,
	) -> FilePathCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(FilePathSetParam::from(materialized_path).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "FilePath".into(),
			outputs: file_path_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		FilePathCreateOne { query }
	}
}
fn tag_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("encryption"),
		Output::new("total_files"),
		Output::new("redundancy_goal"),
		Output::new("date_created"),
		Output::new("date_modified"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TagData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "name")]
	pub name: Option<String>,
	#[serde(rename = "encryption")]
	pub encryption: Option<i64>,
	#[serde(rename = "total_files")]
	pub total_files: Option<i64>,
	#[serde(rename = "redundancy_goal")]
	pub redundancy_goal: Option<i64>,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "tag_files")]
	tag_files: Option<Vec<TagOnFileData>>,
}
impl TagData {
	pub fn tag_files(&self) -> Result<&Vec<TagOnFileData>, String> {
		match self.tag_files.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access tag_files but did not fetch it using the .with() syntax".to_string()),
		}
	}
}
pub struct Tag;
impl Tag {
	pub fn id() -> TagIdField {
		TagIdField {}
	}
	pub fn name() -> TagNameField {
		TagNameField {}
	}
	pub fn encryption() -> TagEncryptionField {
		TagEncryptionField {}
	}
	pub fn total_files() -> TagTotalFilesField {
		TagTotalFilesField {}
	}
	pub fn redundancy_goal() -> TagRedundancyGoalField {
		TagRedundancyGoalField {}
	}
	pub fn date_created() -> TagDateCreatedField {
		TagDateCreatedField {}
	}
	pub fn date_modified() -> TagDateModifiedField {
		TagDateModifiedField {}
	}
	pub fn tag_files() -> TagTagFilesField {
		TagTagFilesField {}
	}
}
pub struct TagIdField {}
pub struct TagSetId(i64);
impl From<TagSetId> for TagSetParam {
	fn from(value: TagSetId) -> Self {
		Self::Id(value.0)
	}
}
impl TagIdField {
	pub fn lt(&self, value: i64) -> TagWhereParam {
		TagWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> TagWhereParam {
		TagWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> TagWhereParam {
		TagWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> TagWhereParam {
		TagWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> TagWhereParam {
		TagWhereParam::IdEquals(value)
	}
	pub fn set<T: From<TagSetId>>(&self, value: i64) -> T {
		TagSetId(value).into()
	}
}
pub struct TagNameField {}
pub struct TagSetName(String);
impl From<TagSetName> for TagSetParam {
	fn from(value: TagSetName) -> Self {
		Self::Name(value.0)
	}
}
impl TagNameField {
	pub fn contains(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameContains(value)
	}
	pub fn has_prefix(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameEquals(value)
	}
	pub fn set<T: From<TagSetName>>(&self, value: String) -> T {
		TagSetName(value).into()
	}
}
pub struct TagEncryptionField {}
pub struct TagSetEncryption(i64);
impl From<TagSetEncryption> for TagSetParam {
	fn from(value: TagSetEncryption) -> Self {
		Self::Encryption(value.0)
	}
}
impl TagEncryptionField {
	pub fn lt(&self, value: i64) -> TagWhereParam {
		TagWhereParam::EncryptionLT(value)
	}
	pub fn gt(&self, value: i64) -> TagWhereParam {
		TagWhereParam::EncryptionGT(value)
	}
	pub fn lte(&self, value: i64) -> TagWhereParam {
		TagWhereParam::EncryptionLTE(value)
	}
	pub fn gte(&self, value: i64) -> TagWhereParam {
		TagWhereParam::EncryptionGTE(value)
	}
	pub fn equals(&self, value: i64) -> TagWhereParam {
		TagWhereParam::EncryptionEquals(value)
	}
	pub fn set<T: From<TagSetEncryption>>(&self, value: i64) -> T {
		TagSetEncryption(value).into()
	}
}
pub struct TagTotalFilesField {}
pub struct TagSetTotalFiles(i64);
impl From<TagSetTotalFiles> for TagSetParam {
	fn from(value: TagSetTotalFiles) -> Self {
		Self::TotalFiles(value.0)
	}
}
impl TagTotalFilesField {
	pub fn lt(&self, value: i64) -> TagWhereParam {
		TagWhereParam::TotalFilesLT(value)
	}
	pub fn gt(&self, value: i64) -> TagWhereParam {
		TagWhereParam::TotalFilesGT(value)
	}
	pub fn lte(&self, value: i64) -> TagWhereParam {
		TagWhereParam::TotalFilesLTE(value)
	}
	pub fn gte(&self, value: i64) -> TagWhereParam {
		TagWhereParam::TotalFilesGTE(value)
	}
	pub fn equals(&self, value: i64) -> TagWhereParam {
		TagWhereParam::TotalFilesEquals(value)
	}
	pub fn set<T: From<TagSetTotalFiles>>(&self, value: i64) -> T {
		TagSetTotalFiles(value).into()
	}
}
pub struct TagRedundancyGoalField {}
pub struct TagSetRedundancyGoal(i64);
impl From<TagSetRedundancyGoal> for TagSetParam {
	fn from(value: TagSetRedundancyGoal) -> Self {
		Self::RedundancyGoal(value.0)
	}
}
impl TagRedundancyGoalField {
	pub fn lt(&self, value: i64) -> TagWhereParam {
		TagWhereParam::RedundancyGoalLT(value)
	}
	pub fn gt(&self, value: i64) -> TagWhereParam {
		TagWhereParam::RedundancyGoalGT(value)
	}
	pub fn lte(&self, value: i64) -> TagWhereParam {
		TagWhereParam::RedundancyGoalLTE(value)
	}
	pub fn gte(&self, value: i64) -> TagWhereParam {
		TagWhereParam::RedundancyGoalGTE(value)
	}
	pub fn equals(&self, value: i64) -> TagWhereParam {
		TagWhereParam::RedundancyGoalEquals(value)
	}
	pub fn set<T: From<TagSetRedundancyGoal>>(&self, value: i64) -> T {
		TagSetRedundancyGoal(value).into()
	}
}
pub struct TagDateCreatedField {}
pub struct TagSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<TagSetDateCreated> for TagSetParam {
	fn from(value: TagSetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl TagDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<TagSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		TagSetDateCreated(value).into()
	}
}
pub struct TagDateModifiedField {}
pub struct TagSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<TagSetDateModified> for TagSetParam {
	fn from(value: TagSetDateModified) -> Self {
		Self::DateModified(value.0)
	}
}
impl TagDateModifiedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateModifiedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateModifiedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateModifiedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateModifiedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateModifiedEquals(value)
	}
	pub fn set<T: From<TagSetDateModified>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		TagSetDateModified(value).into()
	}
}
pub struct TagTagFilesField {}
pub struct TagLinkTagFiles(Vec<TagOnFileWhereParam>);
impl From<TagLinkTagFiles> for TagSetParam {
	fn from(value: TagLinkTagFiles) -> Self {
		Self::LinkTagFiles(value.0.into_iter().map(|v| v.into()).collect())
	}
}
impl TagTagFilesField {
	pub fn some(&self, value: Vec<TagOnFileWhereParam>) -> TagWhereParam {
		TagWhereParam::TagFilesSome(value)
	}
	pub fn every(&self, value: Vec<TagOnFileWhereParam>) -> TagWhereParam {
		TagWhereParam::TagFilesEvery(value)
	}
	pub fn link<T: From<TagLinkTagFiles>>(&self, value: Vec<TagOnFileWhereParam>) -> T {
		TagLinkTagFiles(value).into()
	}
	pub fn unlink(&self, params: Vec<TagOnFileWhereParam>) -> TagSetParam {
		TagSetParam::UnlinkTagFiles(params)
	}
	pub fn fetch(&self, params: Vec<TagOnFileWhereParam>) -> TagWith {
		TagWithParam::TagFiles(params).into()
	}
}
pub enum TagWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	NameContains(String),
	NameHasPrefix(String),
	NameHasSuffix(String),
	NameEquals(String),
	EncryptionLT(i64),
	EncryptionGT(i64),
	EncryptionLTE(i64),
	EncryptionGTE(i64),
	EncryptionEquals(i64),
	TotalFilesLT(i64),
	TotalFilesGT(i64),
	TotalFilesLTE(i64),
	TotalFilesGTE(i64),
	TotalFilesEquals(i64),
	RedundancyGoalLT(i64),
	RedundancyGoalGT(i64),
	RedundancyGoalLTE(i64),
	RedundancyGoalGTE(i64),
	RedundancyGoalEquals(i64),
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedBefore(chrono::DateTime<chrono::Utc>),
	DateModifiedAfter(chrono::DateTime<chrono::Utc>),
	DateModifiedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	TagFilesSome(Vec<TagOnFileWhereParam>),
	TagFilesEvery(Vec<TagOnFileWhereParam>),
	Not(Vec<TagWhereParam>),
	Or(Vec<TagWhereParam>),
	And(Vec<TagWhereParam>),
}
impl TagWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasPrefix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasSuffix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLT(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGT(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLTE(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGTE(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionEquals(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesLT(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesGT(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesLTE(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesGTE(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesEquals(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalLT(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalGT(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalLTE(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalGTE(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalEquals(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBefore(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfter(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBeforeEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfterEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagFilesSome(value) => Field {
				name: "tag_files".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagFilesEvery(value) => Field {
				name: "tag_files".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for TagWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct TagWith {
	pub param: TagWithParam,
}
pub enum TagWithParam {
	TagFiles(Vec<TagOnFileWhereParam>),
}
impl From<TagWithParam> for TagWith {
	fn from(param: TagWithParam) -> Self {
		Self { param }
	}
}
impl TagWithParam {
	pub fn output(self) -> Output {
		match self {
			Self::TagFiles(where_params) => Output {
				name: "tag_files".into(),
				outputs: tag_on_file_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params.into_iter().map(|f| f.field()).collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
		}
	}
}
pub enum TagSetParam {
	Id(i64),
	Name(String),
	Encryption(i64),
	TotalFiles(i64),
	RedundancyGoal(i64),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
	LinkTagFiles(Vec<TagOnFileWhereParam>),
	UnlinkTagFiles(Vec<TagOnFileWhereParam>),
}
impl TagSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Encryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalFiles(value) => Field {
				name: "total_files".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::RedundancyGoal(value) => Field {
				name: "redundancy_goal".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkTagFiles(where_params) => Field {
				name: "tag_files".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkTagFiles(where_params) => Field {
				name: "tag_files".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub struct TagFindMany<'a> {
	query: Query<'a>,
}
impl<'a> TagFindMany<'a> {
	pub async fn exec(self) -> Vec<TagData> {
		self.query.perform::<Vec<TagData>>().await.unwrap()
	}
	pub fn delete(self) -> TagDelete<'a> {
		TagDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Tag".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<TagSetParam>) -> TagUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		TagUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<TagWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct TagFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> TagFindFirst<'a> {
	pub async fn exec(self) -> Option<TagData> {
		self.query.perform::<Option<TagData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<TagWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct TagFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> TagFindUnique<'a> {
	pub async fn exec(self) -> Option<TagData> {
		self.query.perform::<Option<TagData>>().await.unwrap()
	}
	pub fn delete(self) -> TagDelete<'a> {
		TagDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Tag".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<TagSetParam>) -> TagUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		TagUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<TagWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct TagCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> TagCreateOne<'a> {
	pub async fn exec(self) -> TagData {
		self.query.perform::<TagData>().await.unwrap()
	}
}
pub struct TagUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> TagUpdateUnique<'a> {
	pub async fn exec(self) -> TagData {
		self.query.perform::<TagData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<TagWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct TagUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> TagUpdateMany<'a> {
	pub async fn exec(self) -> Vec<TagData> {
		self.query.perform::<Vec<TagData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<TagWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct TagDelete<'a> {
	query: Query<'a>,
}
impl<'a> TagDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct TagActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> TagActions<'a> {
	pub fn find_unique(&self, param: TagWhereParam) -> TagFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Tag".into(),
			outputs: tag_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		TagFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<TagWhereParam>) -> TagFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Tag".into(),
			outputs: tag_outputs(),
			inputs,
		};
		TagFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<TagWhereParam>) -> TagFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Tag".into(),
			outputs: tag_outputs(),
			inputs,
		};
		TagFindMany { query }
	}
	pub fn create_one(&self, params: Vec<TagSetParam>) -> TagCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Tag".into(),
			outputs: tag_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		TagCreateOne { query }
	}
}
fn tag_on_file_outputs() -> Vec<Output> {
	vec![
		Output::new("date_created"),
		Output::new("tag_id"),
		Output::new("file_id"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TagOnFileData {
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "tag_id")]
	pub tag_id: i64,
	#[serde(rename = "tag")]
	tag: Box<Option<TagData>>,
	#[serde(rename = "file_id")]
	pub file_id: i64,
	#[serde(rename = "file")]
	file: Box<Option<FileData>>,
}
impl TagOnFileData {
	pub fn tag(&self) -> Result<&TagData, String> {
		match self.tag.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access tag but did not fetch it using the .with() syntax".to_string()),
		}
	}
	pub fn file(&self) -> Result<&FileData, String> {
		match self.file.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access file but did not fetch it using the .with() syntax".to_string()),
		}
	}
}
pub struct TagOnFile;
impl TagOnFile {
	pub fn date_created() -> TagOnFileDateCreatedField {
		TagOnFileDateCreatedField {}
	}
	pub fn tag_id() -> TagOnFileTagIdField {
		TagOnFileTagIdField {}
	}
	pub fn tag() -> TagOnFileTagField {
		TagOnFileTagField {}
	}
	pub fn file_id() -> TagOnFileFileIdField {
		TagOnFileFileIdField {}
	}
	pub fn file() -> TagOnFileFileField {
		TagOnFileFileField {}
	}
}
pub struct TagOnFileDateCreatedField {}
pub struct TagOnFileSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<TagOnFileSetDateCreated> for TagOnFileSetParam {
	fn from(value: TagOnFileSetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl TagOnFileDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<TagOnFileSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		TagOnFileSetDateCreated(value).into()
	}
}
pub struct TagOnFileTagIdField {}
pub struct TagOnFileSetTagId(i64);
impl From<TagOnFileSetTagId> for TagOnFileSetParam {
	fn from(value: TagOnFileSetTagId) -> Self {
		Self::TagId(value.0)
	}
}
impl TagOnFileTagIdField {
	pub fn lt(&self, value: i64) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdLT(value)
	}
	pub fn gt(&self, value: i64) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdGT(value)
	}
	pub fn lte(&self, value: i64) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdLTE(value)
	}
	pub fn gte(&self, value: i64) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdGTE(value)
	}
	pub fn equals(&self, value: i64) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdEquals(value)
	}
	pub fn set<T: From<TagOnFileSetTagId>>(&self, value: i64) -> T {
		TagOnFileSetTagId(value).into()
	}
}
pub struct TagOnFileTagField {}
pub struct TagOnFileLinkTag(TagWhereParam);
impl From<TagOnFileLinkTag> for TagOnFileSetParam {
	fn from(value: TagOnFileLinkTag) -> Self {
		Self::LinkTag(value.0)
	}
}
impl TagOnFileTagField {
	pub fn is(&self, value: Vec<TagWhereParam>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIs(value)
	}
	pub fn link<T: From<TagOnFileLinkTag>>(&self, value: TagWhereParam) -> T {
		TagOnFileLinkTag(value).into()
	}
	pub fn fetch(&self) -> TagOnFileWith {
		TagOnFileWithParam::Tag.into()
	}
}
pub struct TagOnFileFileIdField {}
pub struct TagOnFileSetFileId(i64);
impl From<TagOnFileSetFileId> for TagOnFileSetParam {
	fn from(value: TagOnFileSetFileId) -> Self {
		Self::FileId(value.0)
	}
}
impl TagOnFileFileIdField {
	pub fn lt(&self, value: i64) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdLT(value)
	}
	pub fn gt(&self, value: i64) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdGT(value)
	}
	pub fn lte(&self, value: i64) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdLTE(value)
	}
	pub fn gte(&self, value: i64) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdGTE(value)
	}
	pub fn equals(&self, value: i64) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdEquals(value)
	}
	pub fn set<T: From<TagOnFileSetFileId>>(&self, value: i64) -> T {
		TagOnFileSetFileId(value).into()
	}
}
pub struct TagOnFileFileField {}
pub struct TagOnFileLinkFile(FileWhereParam);
impl From<TagOnFileLinkFile> for TagOnFileSetParam {
	fn from(value: TagOnFileLinkFile) -> Self {
		Self::LinkFile(value.0)
	}
}
impl TagOnFileFileField {
	pub fn is(&self, value: Vec<FileWhereParam>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIs(value)
	}
	pub fn link<T: From<TagOnFileLinkFile>>(&self, value: FileWhereParam) -> T {
		TagOnFileLinkFile(value).into()
	}
	pub fn fetch(&self) -> TagOnFileWith {
		TagOnFileWithParam::File.into()
	}
}
pub enum TagOnFileWhereParam {
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	TagIdLT(i64),
	TagIdGT(i64),
	TagIdLTE(i64),
	TagIdGTE(i64),
	TagIdEquals(i64),
	TagIs(Vec<TagWhereParam>),
	FileIdLT(i64),
	FileIdGT(i64),
	FileIdLTE(i64),
	FileIdGTE(i64),
	FileIdEquals(i64),
	FileIs(Vec<FileWhereParam>),
	Not(Vec<TagOnFileWhereParam>),
	Or(Vec<TagOnFileWhereParam>),
	And(Vec<TagOnFileWhereParam>),
}
impl TagOnFileWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdLT(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdGT(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdLTE(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdGTE(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdEquals(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIs(value) => Field {
				name: "tag".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLT(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGT(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLTE(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGTE(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdEquals(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIs(value) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for TagOnFileWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct TagOnFileWith {
	pub param: TagOnFileWithParam,
}
pub enum TagOnFileWithParam {
	Tag,
	File,
}
impl From<TagOnFileWithParam> for TagOnFileWith {
	fn from(param: TagOnFileWithParam) -> Self {
		Self { param }
	}
}
impl TagOnFileWithParam {
	pub fn output(self) -> Output {
		match self {
			Self::Tag => Output {
				name: "tag".into(),
				outputs: tag_outputs(),
				..Default::default()
			},
			Self::File => Output {
				name: "file".into(),
				outputs: file_outputs(),
				..Default::default()
			},
		}
	}
}
pub enum TagOnFileSetParam {
	DateCreated(chrono::DateTime<chrono::Utc>),
	TagId(i64),
	LinkTag(TagWhereParam),
	FileId(i64),
	LinkFile(FileWhereParam),
}
impl TagOnFileSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TagId(value) => Field {
				name: "tag_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkTag(where_param) => Field {
				name: "tag".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![where_param.field()])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFile(where_param) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![where_param.field()])),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub struct TagOnFileFindMany<'a> {
	query: Query<'a>,
}
impl<'a> TagOnFileFindMany<'a> {
	pub async fn exec(self) -> Vec<TagOnFileData> {
		self.query.perform::<Vec<TagOnFileData>>().await.unwrap()
	}
	pub fn delete(self) -> TagOnFileDelete<'a> {
		TagOnFileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "TagOnFile".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<TagOnFileSetParam>) -> TagOnFileUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		TagOnFileUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<TagOnFileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct TagOnFileFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> TagOnFileFindFirst<'a> {
	pub async fn exec(self) -> Option<TagOnFileData> {
		self.query.perform::<Option<TagOnFileData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<TagOnFileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct TagOnFileFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> TagOnFileFindUnique<'a> {
	pub async fn exec(self) -> Option<TagOnFileData> {
		self.query.perform::<Option<TagOnFileData>>().await.unwrap()
	}
	pub fn delete(self) -> TagOnFileDelete<'a> {
		TagOnFileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "TagOnFile".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<TagOnFileSetParam>) -> TagOnFileUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		TagOnFileUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<TagOnFileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct TagOnFileCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> TagOnFileCreateOne<'a> {
	pub async fn exec(self) -> TagOnFileData {
		self.query.perform::<TagOnFileData>().await.unwrap()
	}
}
pub struct TagOnFileUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> TagOnFileUpdateUnique<'a> {
	pub async fn exec(self) -> TagOnFileData {
		self.query.perform::<TagOnFileData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<TagOnFileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct TagOnFileUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> TagOnFileUpdateMany<'a> {
	pub async fn exec(self) -> Vec<TagOnFileData> {
		self.query.perform::<Vec<TagOnFileData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<TagOnFileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct TagOnFileDelete<'a> {
	query: Query<'a>,
}
impl<'a> TagOnFileDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct TagOnFileActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> TagOnFileActions<'a> {
	pub fn find_unique(&self, param: TagOnFileWhereParam) -> TagOnFileFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "TagOnFile".into(),
			outputs: tag_on_file_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		TagOnFileFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<TagOnFileWhereParam>) -> TagOnFileFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "TagOnFile".into(),
			outputs: tag_on_file_outputs(),
			inputs,
		};
		TagOnFileFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<TagOnFileWhereParam>) -> TagOnFileFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "TagOnFile".into(),
			outputs: tag_on_file_outputs(),
			inputs,
		};
		TagOnFileFindMany { query }
	}
	pub fn create_one(
		&self,
		tag: TagOnFileLinkTag,
		file: TagOnFileLinkFile,
		params: Vec<TagOnFileSetParam>,
	) -> TagOnFileCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(TagOnFileSetParam::from(tag).field());
		input_fields.push(TagOnFileSetParam::from(file).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "TagOnFile".into(),
			outputs: tag_on_file_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		TagOnFileCreateOne { query }
	}
}
fn label_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("date_created"),
		Output::new("date_modified"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LabelData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "name")]
	pub name: Option<String>,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "label_files")]
	label_files: Option<Vec<LabelOnFileData>>,
}
impl LabelData {
	pub fn label_files(&self) -> Result<&Vec<LabelOnFileData>, String> {
		match self.label_files.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access label_files but did not fetch it using the .with() syntax".to_string()),
		}
	}
}
pub struct Label;
impl Label {
	pub fn id() -> LabelIdField {
		LabelIdField {}
	}
	pub fn name() -> LabelNameField {
		LabelNameField {}
	}
	pub fn date_created() -> LabelDateCreatedField {
		LabelDateCreatedField {}
	}
	pub fn date_modified() -> LabelDateModifiedField {
		LabelDateModifiedField {}
	}
	pub fn label_files() -> LabelLabelFilesField {
		LabelLabelFilesField {}
	}
}
pub struct LabelIdField {}
pub struct LabelSetId(i64);
impl From<LabelSetId> for LabelSetParam {
	fn from(value: LabelSetId) -> Self {
		Self::Id(value.0)
	}
}
impl LabelIdField {
	pub fn lt(&self, value: i64) -> LabelWhereParam {
		LabelWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> LabelWhereParam {
		LabelWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> LabelWhereParam {
		LabelWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> LabelWhereParam {
		LabelWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> LabelWhereParam {
		LabelWhereParam::IdEquals(value)
	}
	pub fn set<T: From<LabelSetId>>(&self, value: i64) -> T {
		LabelSetId(value).into()
	}
}
pub struct LabelNameField {}
pub struct LabelSetName(String);
impl From<LabelSetName> for LabelSetParam {
	fn from(value: LabelSetName) -> Self {
		Self::Name(value.0)
	}
}
impl LabelNameField {
	pub fn contains(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameContains(value)
	}
	pub fn has_prefix(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameEquals(value)
	}
	pub fn set<T: From<LabelSetName>>(&self, value: String) -> T {
		LabelSetName(value).into()
	}
}
pub struct LabelDateCreatedField {}
pub struct LabelSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<LabelSetDateCreated> for LabelSetParam {
	fn from(value: LabelSetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl LabelDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<LabelSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		LabelSetDateCreated(value).into()
	}
}
pub struct LabelDateModifiedField {}
pub struct LabelSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<LabelSetDateModified> for LabelSetParam {
	fn from(value: LabelSetDateModified) -> Self {
		Self::DateModified(value.0)
	}
}
impl LabelDateModifiedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedEquals(value)
	}
	pub fn set<T: From<LabelSetDateModified>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		LabelSetDateModified(value).into()
	}
}
pub struct LabelLabelFilesField {}
pub struct LabelLinkLabelFiles(Vec<LabelOnFileWhereParam>);
impl From<LabelLinkLabelFiles> for LabelSetParam {
	fn from(value: LabelLinkLabelFiles) -> Self {
		Self::LinkLabelFiles(value.0.into_iter().map(|v| v.into()).collect())
	}
}
impl LabelLabelFilesField {
	pub fn some(&self, value: Vec<LabelOnFileWhereParam>) -> LabelWhereParam {
		LabelWhereParam::LabelFilesSome(value)
	}
	pub fn every(&self, value: Vec<LabelOnFileWhereParam>) -> LabelWhereParam {
		LabelWhereParam::LabelFilesEvery(value)
	}
	pub fn link<T: From<LabelLinkLabelFiles>>(&self, value: Vec<LabelOnFileWhereParam>) -> T {
		LabelLinkLabelFiles(value).into()
	}
	pub fn unlink(&self, params: Vec<LabelOnFileWhereParam>) -> LabelSetParam {
		LabelSetParam::UnlinkLabelFiles(params)
	}
	pub fn fetch(&self, params: Vec<LabelOnFileWhereParam>) -> LabelWith {
		LabelWithParam::LabelFiles(params).into()
	}
}
pub enum LabelWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	NameContains(String),
	NameHasPrefix(String),
	NameHasSuffix(String),
	NameEquals(String),
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedBefore(chrono::DateTime<chrono::Utc>),
	DateModifiedAfter(chrono::DateTime<chrono::Utc>),
	DateModifiedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	LabelFilesSome(Vec<LabelOnFileWhereParam>),
	LabelFilesEvery(Vec<LabelOnFileWhereParam>),
	Not(Vec<LabelWhereParam>),
	Or(Vec<LabelWhereParam>),
	And(Vec<LabelWhereParam>),
}
impl LabelWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasPrefix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasSuffix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBefore(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfter(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBeforeEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfterEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelFilesSome(value) => Field {
				name: "label_files".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelFilesEvery(value) => Field {
				name: "label_files".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for LabelWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct LabelWith {
	pub param: LabelWithParam,
}
pub enum LabelWithParam {
	LabelFiles(Vec<LabelOnFileWhereParam>),
}
impl From<LabelWithParam> for LabelWith {
	fn from(param: LabelWithParam) -> Self {
		Self { param }
	}
}
impl LabelWithParam {
	pub fn output(self) -> Output {
		match self {
			Self::LabelFiles(where_params) => Output {
				name: "label_files".into(),
				outputs: label_on_file_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params.into_iter().map(|f| f.field()).collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
		}
	}
}
pub enum LabelSetParam {
	Id(i64),
	Name(String),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
	LinkLabelFiles(Vec<LabelOnFileWhereParam>),
	UnlinkLabelFiles(Vec<LabelOnFileWhereParam>),
}
impl LabelSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkLabelFiles(where_params) => Field {
				name: "label_files".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkLabelFiles(where_params) => Field {
				name: "label_files".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params.into_iter().map(|item| item.field()).collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub struct LabelFindMany<'a> {
	query: Query<'a>,
}
impl<'a> LabelFindMany<'a> {
	pub async fn exec(self) -> Vec<LabelData> {
		self.query.perform::<Vec<LabelData>>().await.unwrap()
	}
	pub fn delete(self) -> LabelDelete<'a> {
		LabelDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Label".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LabelSetParam>) -> LabelUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LabelUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<LabelWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LabelFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> LabelFindFirst<'a> {
	pub async fn exec(self) -> Option<LabelData> {
		self.query.perform::<Option<LabelData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LabelWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LabelFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> LabelFindUnique<'a> {
	pub async fn exec(self) -> Option<LabelData> {
		self.query.perform::<Option<LabelData>>().await.unwrap()
	}
	pub fn delete(self) -> LabelDelete<'a> {
		LabelDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Label".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LabelSetParam>) -> LabelUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LabelUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<LabelWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LabelCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> LabelCreateOne<'a> {
	pub async fn exec(self) -> LabelData {
		self.query.perform::<LabelData>().await.unwrap()
	}
}
pub struct LabelUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> LabelUpdateUnique<'a> {
	pub async fn exec(self) -> LabelData {
		self.query.perform::<LabelData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LabelWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LabelUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> LabelUpdateMany<'a> {
	pub async fn exec(self) -> Vec<LabelData> {
		self.query.perform::<Vec<LabelData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LabelWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LabelDelete<'a> {
	query: Query<'a>,
}
impl<'a> LabelDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct LabelActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> LabelActions<'a> {
	pub fn find_unique(&self, param: LabelWhereParam) -> LabelFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Label".into(),
			outputs: label_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LabelFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<LabelWhereParam>) -> LabelFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Label".into(),
			outputs: label_outputs(),
			inputs,
		};
		LabelFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<LabelWhereParam>) -> LabelFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Label".into(),
			outputs: label_outputs(),
			inputs,
		};
		LabelFindMany { query }
	}
	pub fn create_one(&self, params: Vec<LabelSetParam>) -> LabelCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Label".into(),
			outputs: label_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		LabelCreateOne { query }
	}
}
fn label_on_file_outputs() -> Vec<Output> {
	vec![
		Output::new("date_created"),
		Output::new("label_id"),
		Output::new("file_id"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LabelOnFileData {
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "label_id")]
	pub label_id: i64,
	#[serde(rename = "label")]
	label: Box<Option<LabelData>>,
	#[serde(rename = "file_id")]
	pub file_id: i64,
	#[serde(rename = "file")]
	file: Box<Option<FileData>>,
}
impl LabelOnFileData {
	pub fn label(&self) -> Result<&LabelData, String> {
		match self.label.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access label but did not fetch it using the .with() syntax".to_string()),
		}
	}
	pub fn file(&self) -> Result<&FileData, String> {
		match self.file.as_ref() {
			Some(v) => Ok(v),
			None => Err("attempted to access file but did not fetch it using the .with() syntax".to_string()),
		}
	}
}
pub struct LabelOnFile;
impl LabelOnFile {
	pub fn date_created() -> LabelOnFileDateCreatedField {
		LabelOnFileDateCreatedField {}
	}
	pub fn label_id() -> LabelOnFileLabelIdField {
		LabelOnFileLabelIdField {}
	}
	pub fn label() -> LabelOnFileLabelField {
		LabelOnFileLabelField {}
	}
	pub fn file_id() -> LabelOnFileFileIdField {
		LabelOnFileFileIdField {}
	}
	pub fn file() -> LabelOnFileFileField {
		LabelOnFileFileField {}
	}
}
pub struct LabelOnFileDateCreatedField {}
pub struct LabelOnFileSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<LabelOnFileSetDateCreated> for LabelOnFileSetParam {
	fn from(value: LabelOnFileSetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl LabelOnFileDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<LabelOnFileSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		LabelOnFileSetDateCreated(value).into()
	}
}
pub struct LabelOnFileLabelIdField {}
pub struct LabelOnFileSetLabelId(i64);
impl From<LabelOnFileSetLabelId> for LabelOnFileSetParam {
	fn from(value: LabelOnFileSetLabelId) -> Self {
		Self::LabelId(value.0)
	}
}
impl LabelOnFileLabelIdField {
	pub fn lt(&self, value: i64) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdLT(value)
	}
	pub fn gt(&self, value: i64) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdGT(value)
	}
	pub fn lte(&self, value: i64) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdLTE(value)
	}
	pub fn gte(&self, value: i64) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdGTE(value)
	}
	pub fn equals(&self, value: i64) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdEquals(value)
	}
	pub fn set<T: From<LabelOnFileSetLabelId>>(&self, value: i64) -> T {
		LabelOnFileSetLabelId(value).into()
	}
}
pub struct LabelOnFileLabelField {}
pub struct LabelOnFileLinkLabel(LabelWhereParam);
impl From<LabelOnFileLinkLabel> for LabelOnFileSetParam {
	fn from(value: LabelOnFileLinkLabel) -> Self {
		Self::LinkLabel(value.0)
	}
}
impl LabelOnFileLabelField {
	pub fn is(&self, value: Vec<LabelWhereParam>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIs(value)
	}
	pub fn link<T: From<LabelOnFileLinkLabel>>(&self, value: LabelWhereParam) -> T {
		LabelOnFileLinkLabel(value).into()
	}
	pub fn fetch(&self) -> LabelOnFileWith {
		LabelOnFileWithParam::Label.into()
	}
}
pub struct LabelOnFileFileIdField {}
pub struct LabelOnFileSetFileId(i64);
impl From<LabelOnFileSetFileId> for LabelOnFileSetParam {
	fn from(value: LabelOnFileSetFileId) -> Self {
		Self::FileId(value.0)
	}
}
impl LabelOnFileFileIdField {
	pub fn lt(&self, value: i64) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdLT(value)
	}
	pub fn gt(&self, value: i64) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdGT(value)
	}
	pub fn lte(&self, value: i64) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdLTE(value)
	}
	pub fn gte(&self, value: i64) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdGTE(value)
	}
	pub fn equals(&self, value: i64) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdEquals(value)
	}
	pub fn set<T: From<LabelOnFileSetFileId>>(&self, value: i64) -> T {
		LabelOnFileSetFileId(value).into()
	}
}
pub struct LabelOnFileFileField {}
pub struct LabelOnFileLinkFile(FileWhereParam);
impl From<LabelOnFileLinkFile> for LabelOnFileSetParam {
	fn from(value: LabelOnFileLinkFile) -> Self {
		Self::LinkFile(value.0)
	}
}
impl LabelOnFileFileField {
	pub fn is(&self, value: Vec<FileWhereParam>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIs(value)
	}
	pub fn link<T: From<LabelOnFileLinkFile>>(&self, value: FileWhereParam) -> T {
		LabelOnFileLinkFile(value).into()
	}
	pub fn fetch(&self) -> LabelOnFileWith {
		LabelOnFileWithParam::File.into()
	}
}
pub enum LabelOnFileWhereParam {
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	LabelIdLT(i64),
	LabelIdGT(i64),
	LabelIdLTE(i64),
	LabelIdGTE(i64),
	LabelIdEquals(i64),
	LabelIs(Vec<LabelWhereParam>),
	FileIdLT(i64),
	FileIdGT(i64),
	FileIdLTE(i64),
	FileIdGTE(i64),
	FileIdEquals(i64),
	FileIs(Vec<FileWhereParam>),
	Not(Vec<LabelOnFileWhereParam>),
	Or(Vec<LabelOnFileWhereParam>),
	And(Vec<LabelOnFileWhereParam>),
}
impl LabelOnFileWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdLT(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdGT(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdLTE(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdGTE(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdEquals(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIs(value) => Field {
				name: "label".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLT(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGT(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLTE(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGTE(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdEquals(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIs(value) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for LabelOnFileWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct LabelOnFileWith {
	pub param: LabelOnFileWithParam,
}
pub enum LabelOnFileWithParam {
	Label,
	File,
}
impl From<LabelOnFileWithParam> for LabelOnFileWith {
	fn from(param: LabelOnFileWithParam) -> Self {
		Self { param }
	}
}
impl LabelOnFileWithParam {
	pub fn output(self) -> Output {
		match self {
			Self::Label => Output {
				name: "label".into(),
				outputs: label_outputs(),
				..Default::default()
			},
			Self::File => Output {
				name: "file".into(),
				outputs: file_outputs(),
				..Default::default()
			},
		}
	}
}
pub enum LabelOnFileSetParam {
	DateCreated(chrono::DateTime<chrono::Utc>),
	LabelId(i64),
	LinkLabel(LabelWhereParam),
	FileId(i64),
	LinkFile(FileWhereParam),
}
impl LabelOnFileSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LabelId(value) => Field {
				name: "label_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkLabel(where_param) => Field {
				name: "label".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![where_param.field()])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFile(where_param) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![where_param.field()])),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub struct LabelOnFileFindMany<'a> {
	query: Query<'a>,
}
impl<'a> LabelOnFileFindMany<'a> {
	pub async fn exec(self) -> Vec<LabelOnFileData> {
		self.query.perform::<Vec<LabelOnFileData>>().await.unwrap()
	}
	pub fn delete(self) -> LabelOnFileDelete<'a> {
		LabelOnFileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "LabelOnFile".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LabelOnFileSetParam>) -> LabelOnFileUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LabelOnFileUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<LabelOnFileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LabelOnFileFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> LabelOnFileFindFirst<'a> {
	pub async fn exec(self) -> Option<LabelOnFileData> {
		self.query.perform::<Option<LabelOnFileData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LabelOnFileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LabelOnFileFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> LabelOnFileFindUnique<'a> {
	pub async fn exec(self) -> Option<LabelOnFileData> {
		self.query.perform::<Option<LabelOnFileData>>().await.unwrap()
	}
	pub fn delete(self) -> LabelOnFileDelete<'a> {
		LabelOnFileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "LabelOnFile".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LabelOnFileSetParam>) -> LabelOnFileUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LabelOnFileUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<LabelOnFileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LabelOnFileCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> LabelOnFileCreateOne<'a> {
	pub async fn exec(self) -> LabelOnFileData {
		self.query.perform::<LabelOnFileData>().await.unwrap()
	}
}
pub struct LabelOnFileUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> LabelOnFileUpdateUnique<'a> {
	pub async fn exec(self) -> LabelOnFileData {
		self.query.perform::<LabelOnFileData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LabelOnFileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LabelOnFileUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> LabelOnFileUpdateMany<'a> {
	pub async fn exec(self) -> Vec<LabelOnFileData> {
		self.query.perform::<Vec<LabelOnFileData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<LabelOnFileWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct LabelOnFileDelete<'a> {
	query: Query<'a>,
}
impl<'a> LabelOnFileDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct LabelOnFileActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> LabelOnFileActions<'a> {
	pub fn find_unique(&self, param: LabelOnFileWhereParam) -> LabelOnFileFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "LabelOnFile".into(),
			outputs: label_on_file_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LabelOnFileFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<LabelOnFileWhereParam>) -> LabelOnFileFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "LabelOnFile".into(),
			outputs: label_on_file_outputs(),
			inputs,
		};
		LabelOnFileFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<LabelOnFileWhereParam>) -> LabelOnFileFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "LabelOnFile".into(),
			outputs: label_on_file_outputs(),
			inputs,
		};
		LabelOnFileFindMany { query }
	}
	pub fn create_one(
		&self,
		label: LabelOnFileLinkLabel,
		file: LabelOnFileLinkFile,
		params: Vec<LabelOnFileSetParam>,
	) -> LabelOnFileCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(LabelOnFileSetParam::from(label).field());
		input_fields.push(LabelOnFileSetParam::from(file).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "LabelOnFile".into(),
			outputs: label_on_file_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		LabelOnFileCreateOne { query }
	}
}
fn job_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("action"),
		Output::new("status"),
		Output::new("task_count"),
		Output::new("completed_task_count"),
		Output::new("date_created"),
		Output::new("date_modified"),
		Output::new("seconds_elapsed"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JobData {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "action")]
	pub action: i64,
	#[serde(rename = "status")]
	pub status: i64,
	#[serde(rename = "task_count")]
	pub task_count: i64,
	#[serde(rename = "completed_task_count")]
	pub completed_task_count: i64,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "seconds_elapsed")]
	pub seconds_elapsed: i64,
}
impl JobData {}
pub struct Job;
impl Job {
	pub fn id() -> JobIdField {
		JobIdField {}
	}
	pub fn action() -> JobActionField {
		JobActionField {}
	}
	pub fn status() -> JobStatusField {
		JobStatusField {}
	}
	pub fn task_count() -> JobTaskCountField {
		JobTaskCountField {}
	}
	pub fn completed_task_count() -> JobCompletedTaskCountField {
		JobCompletedTaskCountField {}
	}
	pub fn date_created() -> JobDateCreatedField {
		JobDateCreatedField {}
	}
	pub fn date_modified() -> JobDateModifiedField {
		JobDateModifiedField {}
	}
	pub fn seconds_elapsed() -> JobSecondsElapsedField {
		JobSecondsElapsedField {}
	}
}
pub struct JobIdField {}
pub struct JobSetId(String);
impl From<JobSetId> for JobSetParam {
	fn from(value: JobSetId) -> Self {
		Self::Id(value.0)
	}
}
impl JobIdField {
	pub fn contains(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdContains(value)
	}
	pub fn has_prefix(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdEquals(value)
	}
	pub fn set<T: From<JobSetId>>(&self, value: String) -> T {
		JobSetId(value).into()
	}
}
pub struct JobActionField {}
pub struct JobSetAction(i64);
impl From<JobSetAction> for JobSetParam {
	fn from(value: JobSetAction) -> Self {
		Self::Action(value.0)
	}
}
impl JobActionField {
	pub fn lt(&self, value: i64) -> JobWhereParam {
		JobWhereParam::ActionLT(value)
	}
	pub fn gt(&self, value: i64) -> JobWhereParam {
		JobWhereParam::ActionGT(value)
	}
	pub fn lte(&self, value: i64) -> JobWhereParam {
		JobWhereParam::ActionLTE(value)
	}
	pub fn gte(&self, value: i64) -> JobWhereParam {
		JobWhereParam::ActionGTE(value)
	}
	pub fn equals(&self, value: i64) -> JobWhereParam {
		JobWhereParam::ActionEquals(value)
	}
	pub fn set<T: From<JobSetAction>>(&self, value: i64) -> T {
		JobSetAction(value).into()
	}
}
pub struct JobStatusField {}
pub struct JobSetStatus(i64);
impl From<JobSetStatus> for JobSetParam {
	fn from(value: JobSetStatus) -> Self {
		Self::Status(value.0)
	}
}
impl JobStatusField {
	pub fn lt(&self, value: i64) -> JobWhereParam {
		JobWhereParam::StatusLT(value)
	}
	pub fn gt(&self, value: i64) -> JobWhereParam {
		JobWhereParam::StatusGT(value)
	}
	pub fn lte(&self, value: i64) -> JobWhereParam {
		JobWhereParam::StatusLTE(value)
	}
	pub fn gte(&self, value: i64) -> JobWhereParam {
		JobWhereParam::StatusGTE(value)
	}
	pub fn equals(&self, value: i64) -> JobWhereParam {
		JobWhereParam::StatusEquals(value)
	}
	pub fn set<T: From<JobSetStatus>>(&self, value: i64) -> T {
		JobSetStatus(value).into()
	}
}
pub struct JobTaskCountField {}
pub struct JobSetTaskCount(i64);
impl From<JobSetTaskCount> for JobSetParam {
	fn from(value: JobSetTaskCount) -> Self {
		Self::TaskCount(value.0)
	}
}
impl JobTaskCountField {
	pub fn lt(&self, value: i64) -> JobWhereParam {
		JobWhereParam::TaskCountLT(value)
	}
	pub fn gt(&self, value: i64) -> JobWhereParam {
		JobWhereParam::TaskCountGT(value)
	}
	pub fn lte(&self, value: i64) -> JobWhereParam {
		JobWhereParam::TaskCountLTE(value)
	}
	pub fn gte(&self, value: i64) -> JobWhereParam {
		JobWhereParam::TaskCountGTE(value)
	}
	pub fn equals(&self, value: i64) -> JobWhereParam {
		JobWhereParam::TaskCountEquals(value)
	}
	pub fn set<T: From<JobSetTaskCount>>(&self, value: i64) -> T {
		JobSetTaskCount(value).into()
	}
}
pub struct JobCompletedTaskCountField {}
pub struct JobSetCompletedTaskCount(i64);
impl From<JobSetCompletedTaskCount> for JobSetParam {
	fn from(value: JobSetCompletedTaskCount) -> Self {
		Self::CompletedTaskCount(value.0)
	}
}
impl JobCompletedTaskCountField {
	pub fn lt(&self, value: i64) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountLT(value)
	}
	pub fn gt(&self, value: i64) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountGT(value)
	}
	pub fn lte(&self, value: i64) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountLTE(value)
	}
	pub fn gte(&self, value: i64) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountGTE(value)
	}
	pub fn equals(&self, value: i64) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountEquals(value)
	}
	pub fn set<T: From<JobSetCompletedTaskCount>>(&self, value: i64) -> T {
		JobSetCompletedTaskCount(value).into()
	}
}
pub struct JobDateCreatedField {}
pub struct JobSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<JobSetDateCreated> for JobSetParam {
	fn from(value: JobSetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl JobDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<JobSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		JobSetDateCreated(value).into()
	}
}
pub struct JobDateModifiedField {}
pub struct JobSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<JobSetDateModified> for JobSetParam {
	fn from(value: JobSetDateModified) -> Self {
		Self::DateModified(value.0)
	}
}
impl JobDateModifiedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateModifiedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateModifiedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateModifiedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateModifiedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateModifiedEquals(value)
	}
	pub fn set<T: From<JobSetDateModified>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		JobSetDateModified(value).into()
	}
}
pub struct JobSecondsElapsedField {}
pub struct JobSetSecondsElapsed(i64);
impl From<JobSetSecondsElapsed> for JobSetParam {
	fn from(value: JobSetSecondsElapsed) -> Self {
		Self::SecondsElapsed(value.0)
	}
}
impl JobSecondsElapsedField {
	pub fn lt(&self, value: i64) -> JobWhereParam {
		JobWhereParam::SecondsElapsedLT(value)
	}
	pub fn gt(&self, value: i64) -> JobWhereParam {
		JobWhereParam::SecondsElapsedGT(value)
	}
	pub fn lte(&self, value: i64) -> JobWhereParam {
		JobWhereParam::SecondsElapsedLTE(value)
	}
	pub fn gte(&self, value: i64) -> JobWhereParam {
		JobWhereParam::SecondsElapsedGTE(value)
	}
	pub fn equals(&self, value: i64) -> JobWhereParam {
		JobWhereParam::SecondsElapsedEquals(value)
	}
	pub fn set<T: From<JobSetSecondsElapsed>>(&self, value: i64) -> T {
		JobSetSecondsElapsed(value).into()
	}
}
pub enum JobWhereParam {
	IdContains(String),
	IdHasPrefix(String),
	IdHasSuffix(String),
	IdEquals(String),
	ActionLT(i64),
	ActionGT(i64),
	ActionLTE(i64),
	ActionGTE(i64),
	ActionEquals(i64),
	StatusLT(i64),
	StatusGT(i64),
	StatusLTE(i64),
	StatusGTE(i64),
	StatusEquals(i64),
	TaskCountLT(i64),
	TaskCountGT(i64),
	TaskCountLTE(i64),
	TaskCountGTE(i64),
	TaskCountEquals(i64),
	CompletedTaskCountLT(i64),
	CompletedTaskCountGT(i64),
	CompletedTaskCountLTE(i64),
	CompletedTaskCountGTE(i64),
	CompletedTaskCountEquals(i64),
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedBefore(chrono::DateTime<chrono::Utc>),
	DateModifiedAfter(chrono::DateTime<chrono::Utc>),
	DateModifiedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	SecondsElapsedLT(i64),
	SecondsElapsedGT(i64),
	SecondsElapsedLTE(i64),
	SecondsElapsedGTE(i64),
	SecondsElapsedEquals(i64),
	Not(Vec<JobWhereParam>),
	Or(Vec<JobWhereParam>),
	And(Vec<JobWhereParam>),
}
impl JobWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdContains(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdHasPrefix(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdHasSuffix(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionLT(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionGT(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionLTE(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionGTE(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionEquals(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusLT(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusGT(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusLTE(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusGTE(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusEquals(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountLT(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountGT(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountLTE(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountGTE(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountEquals(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountLT(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountGT(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountLTE(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountGTE(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountEquals(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBefore(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfter(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBeforeEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfterEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedLT(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedGT(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedLTE(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedGTE(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedEquals(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for JobWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct JobWith {
	pub param: JobWithParam,
}
pub enum JobWithParam {}
impl From<JobWithParam> for JobWith {
	fn from(param: JobWithParam) -> Self {
		Self { param }
	}
}
impl JobWithParam {
	pub fn output(self) -> Output {
		match self {}
	}
}
pub enum JobSetParam {
	Id(String),
	Action(i64),
	Status(i64),
	TaskCount(i64),
	CompletedTaskCount(i64),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
	SecondsElapsed(i64),
}
impl JobSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Action(value) => Field {
				name: "action".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Status(value) => Field {
				name: "status".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TaskCount(value) => Field {
				name: "task_count".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::CompletedTaskCount(value) => Field {
				name: "completed_task_count".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SecondsElapsed(value) => Field {
				name: "seconds_elapsed".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub struct JobFindMany<'a> {
	query: Query<'a>,
}
impl<'a> JobFindMany<'a> {
	pub async fn exec(self) -> Vec<JobData> {
		self.query.perform::<Vec<JobData>>().await.unwrap()
	}
	pub fn delete(self) -> JobDelete<'a> {
		JobDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Job".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<JobSetParam>) -> JobUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		JobUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<JobWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct JobFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> JobFindFirst<'a> {
	pub async fn exec(self) -> Option<JobData> {
		self.query.perform::<Option<JobData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<JobWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct JobFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> JobFindUnique<'a> {
	pub async fn exec(self) -> Option<JobData> {
		self.query.perform::<Option<JobData>>().await.unwrap()
	}
	pub fn delete(self) -> JobDelete<'a> {
		JobDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Job".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<JobSetParam>) -> JobUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		JobUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<JobWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct JobCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> JobCreateOne<'a> {
	pub async fn exec(self) -> JobData {
		self.query.perform::<JobData>().await.unwrap()
	}
}
pub struct JobUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> JobUpdateUnique<'a> {
	pub async fn exec(self) -> JobData {
		self.query.perform::<JobData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<JobWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct JobUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> JobUpdateMany<'a> {
	pub async fn exec(self) -> Vec<JobData> {
		self.query.perform::<Vec<JobData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<JobWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct JobDelete<'a> {
	query: Query<'a>,
}
impl<'a> JobDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct JobActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> JobActions<'a> {
	pub fn find_unique(&self, param: JobWhereParam) -> JobFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Job".into(),
			outputs: job_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		JobFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<JobWhereParam>) -> JobFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Job".into(),
			outputs: job_outputs(),
			inputs,
		};
		JobFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<JobWhereParam>) -> JobFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Job".into(),
			outputs: job_outputs(),
			inputs,
		};
		JobFindMany { query }
	}
	pub fn create_one(&self, id: JobSetId, action: JobSetAction, params: Vec<JobSetParam>) -> JobCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(JobSetParam::from(id).field());
		input_fields.push(JobSetParam::from(action).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Job".into(),
			outputs: job_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		JobCreateOne { query }
	}
}
fn space_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("encryption"),
		Output::new("date_created"),
		Output::new("date_modified"),
		Output::new("libraryId"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpaceData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "encryption")]
	pub encryption: Option<i64>,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "Library")]
	pub library: Box<Option<LibraryData>>,
	#[serde(rename = "libraryId")]
	pub library_id: Option<i64>,
}
impl SpaceData {
	pub fn library(&self) -> Option<&LibraryData> {
		self.library.as_ref().as_ref()
	}
}
pub struct Space;
impl Space {
	pub fn id() -> SpaceIdField {
		SpaceIdField {}
	}
	pub fn name() -> SpaceNameField {
		SpaceNameField {}
	}
	pub fn encryption() -> SpaceEncryptionField {
		SpaceEncryptionField {}
	}
	pub fn date_created() -> SpaceDateCreatedField {
		SpaceDateCreatedField {}
	}
	pub fn date_modified() -> SpaceDateModifiedField {
		SpaceDateModifiedField {}
	}
	pub fn library() -> SpaceLibraryField {
		SpaceLibraryField {}
	}
	pub fn library_id() -> SpaceLibraryIdField {
		SpaceLibraryIdField {}
	}
}
pub struct SpaceIdField {}
pub struct SpaceSetId(i64);
impl From<SpaceSetId> for SpaceSetParam {
	fn from(value: SpaceSetId) -> Self {
		Self::Id(value.0)
	}
}
impl SpaceIdField {
	pub fn lt(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::IdEquals(value)
	}
	pub fn set<T: From<SpaceSetId>>(&self, value: i64) -> T {
		SpaceSetId(value).into()
	}
}
pub struct SpaceNameField {}
pub struct SpaceSetName(String);
impl From<SpaceSetName> for SpaceSetParam {
	fn from(value: SpaceSetName) -> Self {
		Self::Name(value.0)
	}
}
impl SpaceNameField {
	pub fn contains(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameContains(value)
	}
	pub fn has_prefix(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameEquals(value)
	}
	pub fn set<T: From<SpaceSetName>>(&self, value: String) -> T {
		SpaceSetName(value).into()
	}
}
pub struct SpaceEncryptionField {}
pub struct SpaceSetEncryption(i64);
impl From<SpaceSetEncryption> for SpaceSetParam {
	fn from(value: SpaceSetEncryption) -> Self {
		Self::Encryption(value.0)
	}
}
impl SpaceEncryptionField {
	pub fn lt(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionLT(value)
	}
	pub fn gt(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionGT(value)
	}
	pub fn lte(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionLTE(value)
	}
	pub fn gte(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionGTE(value)
	}
	pub fn equals(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionEquals(value)
	}
	pub fn set<T: From<SpaceSetEncryption>>(&self, value: i64) -> T {
		SpaceSetEncryption(value).into()
	}
}
pub struct SpaceDateCreatedField {}
pub struct SpaceSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<SpaceSetDateCreated> for SpaceSetParam {
	fn from(value: SpaceSetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl SpaceDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<SpaceSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		SpaceSetDateCreated(value).into()
	}
}
pub struct SpaceDateModifiedField {}
pub struct SpaceSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<SpaceSetDateModified> for SpaceSetParam {
	fn from(value: SpaceSetDateModified) -> Self {
		Self::DateModified(value.0)
	}
}
impl SpaceDateModifiedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedEquals(value)
	}
	pub fn set<T: From<SpaceSetDateModified>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		SpaceSetDateModified(value).into()
	}
}
pub struct SpaceLibraryField {}
pub struct SpaceLinkLibrary(LibraryWhereParam);
impl From<SpaceLinkLibrary> for SpaceSetParam {
	fn from(value: SpaceLinkLibrary) -> Self {
		Self::LinkLibrary(value.0)
	}
}
impl SpaceLibraryField {
	pub fn is(&self, value: Vec<LibraryWhereParam>) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIs(value)
	}
	pub fn link<T: From<SpaceLinkLibrary>>(&self, value: LibraryWhereParam) -> T {
		SpaceLinkLibrary(value).into()
	}
	pub fn fetch(&self) -> SpaceWith {
		SpaceWithParam::Library.into()
	}
	pub fn unlink(&self) -> SpaceSetParam {
		SpaceSetParam::UnlinkLibrary
	}
}
pub struct SpaceLibraryIdField {}
pub struct SpaceSetLibraryId(i64);
impl From<SpaceSetLibraryId> for SpaceSetParam {
	fn from(value: SpaceSetLibraryId) -> Self {
		Self::LibraryId(value.0)
	}
}
impl SpaceLibraryIdField {
	pub fn lt(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdLT(value)
	}
	pub fn gt(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdGT(value)
	}
	pub fn lte(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdLTE(value)
	}
	pub fn gte(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdGTE(value)
	}
	pub fn equals(&self, value: i64) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdEquals(value)
	}
	pub fn set<T: From<SpaceSetLibraryId>>(&self, value: i64) -> T {
		SpaceSetLibraryId(value).into()
	}
}
pub enum SpaceWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	NameContains(String),
	NameHasPrefix(String),
	NameHasSuffix(String),
	NameEquals(String),
	EncryptionLT(i64),
	EncryptionGT(i64),
	EncryptionLTE(i64),
	EncryptionGTE(i64),
	EncryptionEquals(i64),
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedBefore(chrono::DateTime<chrono::Utc>),
	DateModifiedAfter(chrono::DateTime<chrono::Utc>),
	DateModifiedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	LibraryIs(Vec<LibraryWhereParam>),
	LibraryIdLT(i64),
	LibraryIdGT(i64),
	LibraryIdLTE(i64),
	LibraryIdGTE(i64),
	LibraryIdEquals(i64),
	Not(Vec<SpaceWhereParam>),
	Or(Vec<SpaceWhereParam>),
	And(Vec<SpaceWhereParam>),
}
impl SpaceWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasPrefix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasSuffix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLT(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGT(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLTE(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGTE(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionEquals(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBefore(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfter(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBeforeEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfterEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIs(value) => Field {
				name: "Library".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdLT(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdGT(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdLTE(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdGTE(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdEquals(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for SpaceWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct SpaceWith {
	pub param: SpaceWithParam,
}
pub enum SpaceWithParam {
	Library,
}
impl From<SpaceWithParam> for SpaceWith {
	fn from(param: SpaceWithParam) -> Self {
		Self { param }
	}
}
impl SpaceWithParam {
	pub fn output(self) -> Output {
		match self {
			Self::Library => Output {
				name: "Library".into(),
				outputs: library_outputs(),
				..Default::default()
			},
		}
	}
}
pub enum SpaceSetParam {
	Id(i64),
	Name(String),
	Encryption(i64),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
	LinkLibrary(LibraryWhereParam),
	UnlinkLibrary,
	LibraryId(i64),
}
impl SpaceSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Encryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkLibrary(where_param) => Field {
				name: "Library".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![where_param.field()])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkLibrary => Field {
				name: "Library".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					value: Some(true.into()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryId(value) => Field {
				name: "libraryId".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub struct SpaceFindMany<'a> {
	query: Query<'a>,
}
impl<'a> SpaceFindMany<'a> {
	pub async fn exec(self) -> Vec<SpaceData> {
		self.query.perform::<Vec<SpaceData>>().await.unwrap()
	}
	pub fn delete(self) -> SpaceDelete<'a> {
		SpaceDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Space".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<SpaceSetParam>) -> SpaceUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		SpaceUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<SpaceWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct SpaceFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> SpaceFindFirst<'a> {
	pub async fn exec(self) -> Option<SpaceData> {
		self.query.perform::<Option<SpaceData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<SpaceWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct SpaceFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> SpaceFindUnique<'a> {
	pub async fn exec(self) -> Option<SpaceData> {
		self.query.perform::<Option<SpaceData>>().await.unwrap()
	}
	pub fn delete(self) -> SpaceDelete<'a> {
		SpaceDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Space".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<SpaceSetParam>) -> SpaceUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		SpaceUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<SpaceWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct SpaceCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> SpaceCreateOne<'a> {
	pub async fn exec(self) -> SpaceData {
		self.query.perform::<SpaceData>().await.unwrap()
	}
}
pub struct SpaceUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> SpaceUpdateUnique<'a> {
	pub async fn exec(self) -> SpaceData {
		self.query.perform::<SpaceData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<SpaceWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct SpaceUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> SpaceUpdateMany<'a> {
	pub async fn exec(self) -> Vec<SpaceData> {
		self.query.perform::<Vec<SpaceData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<SpaceWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct SpaceDelete<'a> {
	query: Query<'a>,
}
impl<'a> SpaceDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct SpaceActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> SpaceActions<'a> {
	pub fn find_unique(&self, param: SpaceWhereParam) -> SpaceFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Space".into(),
			outputs: space_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		SpaceFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<SpaceWhereParam>) -> SpaceFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Space".into(),
			outputs: space_outputs(),
			inputs,
		};
		SpaceFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<SpaceWhereParam>) -> SpaceFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Space".into(),
			outputs: space_outputs(),
			inputs,
		};
		SpaceFindMany { query }
	}
	pub fn create_one(&self, name: SpaceSetName, params: Vec<SpaceSetParam>) -> SpaceCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(SpaceSetParam::from(name).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Space".into(),
			outputs: space_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		SpaceCreateOne { query }
	}
}
fn album_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("is_hidden"),
		Output::new("date_created"),
		Output::new("date_modified"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlbumData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "is_hidden")]
	pub is_hidden: bool,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
}
impl AlbumData {}
pub struct Album;
impl Album {
	pub fn id() -> AlbumIdField {
		AlbumIdField {}
	}
	pub fn name() -> AlbumNameField {
		AlbumNameField {}
	}
	pub fn is_hidden() -> AlbumIsHiddenField {
		AlbumIsHiddenField {}
	}
	pub fn date_created() -> AlbumDateCreatedField {
		AlbumDateCreatedField {}
	}
	pub fn date_modified() -> AlbumDateModifiedField {
		AlbumDateModifiedField {}
	}
}
pub struct AlbumIdField {}
pub struct AlbumSetId(i64);
impl From<AlbumSetId> for AlbumSetParam {
	fn from(value: AlbumSetId) -> Self {
		Self::Id(value.0)
	}
}
impl AlbumIdField {
	pub fn lt(&self, value: i64) -> AlbumWhereParam {
		AlbumWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> AlbumWhereParam {
		AlbumWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> AlbumWhereParam {
		AlbumWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> AlbumWhereParam {
		AlbumWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> AlbumWhereParam {
		AlbumWhereParam::IdEquals(value)
	}
	pub fn set<T: From<AlbumSetId>>(&self, value: i64) -> T {
		AlbumSetId(value).into()
	}
}
pub struct AlbumNameField {}
pub struct AlbumSetName(String);
impl From<AlbumSetName> for AlbumSetParam {
	fn from(value: AlbumSetName) -> Self {
		Self::Name(value.0)
	}
}
impl AlbumNameField {
	pub fn contains(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameContains(value)
	}
	pub fn has_prefix(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameEquals(value)
	}
	pub fn set<T: From<AlbumSetName>>(&self, value: String) -> T {
		AlbumSetName(value).into()
	}
}
pub struct AlbumIsHiddenField {}
pub struct AlbumSetIsHidden(bool);
impl From<AlbumSetIsHidden> for AlbumSetParam {
	fn from(value: AlbumSetIsHidden) -> Self {
		Self::IsHidden(value.0)
	}
}
impl AlbumIsHiddenField {
	pub fn equals(&self, value: bool) -> AlbumWhereParam {
		AlbumWhereParam::IsHiddenEquals(value)
	}
	pub fn set<T: From<AlbumSetIsHidden>>(&self, value: bool) -> T {
		AlbumSetIsHidden(value).into()
	}
}
pub struct AlbumDateCreatedField {}
pub struct AlbumSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<AlbumSetDateCreated> for AlbumSetParam {
	fn from(value: AlbumSetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl AlbumDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<AlbumSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		AlbumSetDateCreated(value).into()
	}
}
pub struct AlbumDateModifiedField {}
pub struct AlbumSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<AlbumSetDateModified> for AlbumSetParam {
	fn from(value: AlbumSetDateModified) -> Self {
		Self::DateModified(value.0)
	}
}
impl AlbumDateModifiedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedEquals(value)
	}
	pub fn set<T: From<AlbumSetDateModified>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		AlbumSetDateModified(value).into()
	}
}
pub enum AlbumWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	NameContains(String),
	NameHasPrefix(String),
	NameHasSuffix(String),
	NameEquals(String),
	IsHiddenEquals(bool),
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedBefore(chrono::DateTime<chrono::Utc>),
	DateModifiedAfter(chrono::DateTime<chrono::Utc>),
	DateModifiedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	Not(Vec<AlbumWhereParam>),
	Or(Vec<AlbumWhereParam>),
	And(Vec<AlbumWhereParam>),
}
impl AlbumWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasPrefix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameHasSuffix(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsHiddenEquals(value) => Field {
				name: "is_hidden".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBefore(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfter(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBeforeEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfterEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for AlbumWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct AlbumWith {
	pub param: AlbumWithParam,
}
pub enum AlbumWithParam {}
impl From<AlbumWithParam> for AlbumWith {
	fn from(param: AlbumWithParam) -> Self {
		Self { param }
	}
}
impl AlbumWithParam {
	pub fn output(self) -> Output {
		match self {}
	}
}
pub enum AlbumSetParam {
	Id(i64),
	Name(String),
	IsHidden(bool),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
}
impl AlbumSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsHidden(value) => Field {
				name: "is_hidden".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub struct AlbumFindMany<'a> {
	query: Query<'a>,
}
impl<'a> AlbumFindMany<'a> {
	pub async fn exec(self) -> Vec<AlbumData> {
		self.query.perform::<Vec<AlbumData>>().await.unwrap()
	}
	pub fn delete(self) -> AlbumDelete<'a> {
		AlbumDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Album".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<AlbumSetParam>) -> AlbumUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		AlbumUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<AlbumWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct AlbumFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> AlbumFindFirst<'a> {
	pub async fn exec(self) -> Option<AlbumData> {
		self.query.perform::<Option<AlbumData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<AlbumWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct AlbumFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> AlbumFindUnique<'a> {
	pub async fn exec(self) -> Option<AlbumData> {
		self.query.perform::<Option<AlbumData>>().await.unwrap()
	}
	pub fn delete(self) -> AlbumDelete<'a> {
		AlbumDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Album".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<AlbumSetParam>) -> AlbumUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		AlbumUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<AlbumWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct AlbumCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> AlbumCreateOne<'a> {
	pub async fn exec(self) -> AlbumData {
		self.query.perform::<AlbumData>().await.unwrap()
	}
}
pub struct AlbumUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> AlbumUpdateUnique<'a> {
	pub async fn exec(self) -> AlbumData {
		self.query.perform::<AlbumData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<AlbumWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct AlbumUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> AlbumUpdateMany<'a> {
	pub async fn exec(self) -> Vec<AlbumData> {
		self.query.perform::<Vec<AlbumData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<AlbumWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct AlbumDelete<'a> {
	query: Query<'a>,
}
impl<'a> AlbumDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct AlbumActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> AlbumActions<'a> {
	pub fn find_unique(&self, param: AlbumWhereParam) -> AlbumFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Album".into(),
			outputs: album_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		AlbumFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<AlbumWhereParam>) -> AlbumFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Album".into(),
			outputs: album_outputs(),
			inputs,
		};
		AlbumFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<AlbumWhereParam>) -> AlbumFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Album".into(),
			outputs: album_outputs(),
			inputs,
		};
		AlbumFindMany { query }
	}
	pub fn create_one(&self, name: AlbumSetName, params: Vec<AlbumSetParam>) -> AlbumCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(AlbumSetParam::from(name).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Album".into(),
			outputs: album_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		AlbumCreateOne { query }
	}
}
fn comment_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("content"),
		Output::new("date_created"),
		Output::new("date_modified"),
		Output::new("file_id"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommentData {
	#[serde(rename = "id")]
	pub id: i64,
	#[serde(rename = "content")]
	pub content: String,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "file_id")]
	pub file_id: Option<i64>,
	#[serde(rename = "file")]
	pub file: Box<Option<FileData>>,
}
impl CommentData {
	pub fn file(&self) -> Option<&FileData> {
		self.file.as_ref().as_ref()
	}
}
pub struct Comment;
impl Comment {
	pub fn id() -> CommentIdField {
		CommentIdField {}
	}
	pub fn content() -> CommentContentField {
		CommentContentField {}
	}
	pub fn date_created() -> CommentDateCreatedField {
		CommentDateCreatedField {}
	}
	pub fn date_modified() -> CommentDateModifiedField {
		CommentDateModifiedField {}
	}
	pub fn file_id() -> CommentFileIdField {
		CommentFileIdField {}
	}
	pub fn file() -> CommentFileField {
		CommentFileField {}
	}
}
pub struct CommentIdField {}
pub struct CommentSetId(i64);
impl From<CommentSetId> for CommentSetParam {
	fn from(value: CommentSetId) -> Self {
		Self::Id(value.0)
	}
}
impl CommentIdField {
	pub fn lt(&self, value: i64) -> CommentWhereParam {
		CommentWhereParam::IdLT(value)
	}
	pub fn gt(&self, value: i64) -> CommentWhereParam {
		CommentWhereParam::IdGT(value)
	}
	pub fn lte(&self, value: i64) -> CommentWhereParam {
		CommentWhereParam::IdLTE(value)
	}
	pub fn gte(&self, value: i64) -> CommentWhereParam {
		CommentWhereParam::IdGTE(value)
	}
	pub fn equals(&self, value: i64) -> CommentWhereParam {
		CommentWhereParam::IdEquals(value)
	}
	pub fn set<T: From<CommentSetId>>(&self, value: i64) -> T {
		CommentSetId(value).into()
	}
}
pub struct CommentContentField {}
pub struct CommentSetContent(String);
impl From<CommentSetContent> for CommentSetParam {
	fn from(value: CommentSetContent) -> Self {
		Self::Content(value.0)
	}
}
impl CommentContentField {
	pub fn contains(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentContains(value)
	}
	pub fn has_prefix(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentHasPrefix(value)
	}
	pub fn has_suffix(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentHasSuffix(value)
	}
	pub fn equals(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentEquals(value)
	}
	pub fn set<T: From<CommentSetContent>>(&self, value: String) -> T {
		CommentSetContent(value).into()
	}
}
pub struct CommentDateCreatedField {}
pub struct CommentSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<CommentSetDateCreated> for CommentSetParam {
	fn from(value: CommentSetDateCreated) -> Self {
		Self::DateCreated(value.0)
	}
}
impl CommentDateCreatedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedEquals(value)
	}
	pub fn set<T: From<CommentSetDateCreated>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		CommentSetDateCreated(value).into()
	}
}
pub struct CommentDateModifiedField {}
pub struct CommentSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<CommentSetDateModified> for CommentSetParam {
	fn from(value: CommentSetDateModified) -> Self {
		Self::DateModified(value.0)
	}
}
impl CommentDateModifiedField {
	pub fn before(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedBefore(value)
	}
	pub fn after(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedAfter(value)
	}
	pub fn before_equals(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedBeforeEquals(value)
	}
	pub fn after_equals(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedAfterEquals(value)
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedEquals(value)
	}
	pub fn set<T: From<CommentSetDateModified>>(&self, value: chrono::DateTime<chrono::Utc>) -> T {
		CommentSetDateModified(value).into()
	}
}
pub struct CommentFileIdField {}
pub struct CommentSetFileId(i64);
impl From<CommentSetFileId> for CommentSetParam {
	fn from(value: CommentSetFileId) -> Self {
		Self::FileId(value.0)
	}
}
impl CommentFileIdField {
	pub fn lt(&self, value: i64) -> CommentWhereParam {
		CommentWhereParam::FileIdLT(value)
	}
	pub fn gt(&self, value: i64) -> CommentWhereParam {
		CommentWhereParam::FileIdGT(value)
	}
	pub fn lte(&self, value: i64) -> CommentWhereParam {
		CommentWhereParam::FileIdLTE(value)
	}
	pub fn gte(&self, value: i64) -> CommentWhereParam {
		CommentWhereParam::FileIdGTE(value)
	}
	pub fn equals(&self, value: i64) -> CommentWhereParam {
		CommentWhereParam::FileIdEquals(value)
	}
	pub fn set<T: From<CommentSetFileId>>(&self, value: i64) -> T {
		CommentSetFileId(value).into()
	}
}
pub struct CommentFileField {}
pub struct CommentLinkFile(FileWhereParam);
impl From<CommentLinkFile> for CommentSetParam {
	fn from(value: CommentLinkFile) -> Self {
		Self::LinkFile(value.0)
	}
}
impl CommentFileField {
	pub fn is(&self, value: Vec<FileWhereParam>) -> CommentWhereParam {
		CommentWhereParam::FileIs(value)
	}
	pub fn link<T: From<CommentLinkFile>>(&self, value: FileWhereParam) -> T {
		CommentLinkFile(value).into()
	}
	pub fn fetch(&self) -> CommentWith {
		CommentWithParam::File.into()
	}
	pub fn unlink(&self) -> CommentSetParam {
		CommentSetParam::UnlinkFile
	}
}
pub enum CommentWhereParam {
	IdLT(i64),
	IdGT(i64),
	IdLTE(i64),
	IdGTE(i64),
	IdEquals(i64),
	ContentContains(String),
	ContentHasPrefix(String),
	ContentHasSuffix(String),
	ContentEquals(String),
	DateCreatedBefore(chrono::DateTime<chrono::Utc>),
	DateCreatedAfter(chrono::DateTime<chrono::Utc>),
	DateCreatedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedBefore(chrono::DateTime<chrono::Utc>),
	DateModifiedAfter(chrono::DateTime<chrono::Utc>),
	DateModifiedBeforeEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedAfterEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	FileIdLT(i64),
	FileIdGT(i64),
	FileIdLTE(i64),
	FileIdGTE(i64),
	FileIdEquals(i64),
	FileIs(Vec<FileWhereParam>),
	Not(Vec<CommentWhereParam>),
	Or(Vec<CommentWhereParam>),
	And(Vec<CommentWhereParam>),
}
impl CommentWhereParam {
	pub fn field(self) -> Field {
		match self {
			Self::IdLT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGT(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGTE(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentContains(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentHasPrefix(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "starts_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentHasSuffix(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "ends_with".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentEquals(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBefore(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfter(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedBeforeEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedAfterEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBefore(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfter(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedBeforeEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedAfterEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLT(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGT(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLTE(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGTE(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdEquals(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIs(value) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "AND".into(),
					fields: Some(value.into_iter().map(|f| f.field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::Not(value) => Field {
				name: "NOT".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "OR".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "AND".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.field()).collect()),
				..Default::default()
			},
		}
	}
}
impl From<Operator<Self>> for CommentWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct CommentWith {
	pub param: CommentWithParam,
}
pub enum CommentWithParam {
	File,
}
impl From<CommentWithParam> for CommentWith {
	fn from(param: CommentWithParam) -> Self {
		Self { param }
	}
}
impl CommentWithParam {
	pub fn output(self) -> Output {
		match self {
			Self::File => Output {
				name: "file".into(),
				outputs: file_outputs(),
				..Default::default()
			},
		}
	}
}
pub enum CommentSetParam {
	Id(i64),
	Content(String),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
	FileId(i64),
	LinkFile(FileWhereParam),
	UnlinkFile,
}
impl CommentSetParam {
	pub fn field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Content(value) => Field {
				name: "content".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::FileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFile(where_param) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![where_param.field()])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnlinkFile => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					value: Some(true.into()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub struct CommentFindMany<'a> {
	query: Query<'a>,
}
impl<'a> CommentFindMany<'a> {
	pub async fn exec(self) -> Vec<CommentData> {
		self.query.perform::<Vec<CommentData>>().await.unwrap()
	}
	pub fn delete(self) -> CommentDelete<'a> {
		CommentDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Comment".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<CommentSetParam>) -> CommentUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		CommentUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<CommentWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct CommentFindFirst<'a> {
	query: Query<'a>,
}
impl<'a> CommentFindFirst<'a> {
	pub async fn exec(self) -> Option<CommentData> {
		self.query.perform::<Option<CommentData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<CommentWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct CommentFindUnique<'a> {
	query: Query<'a>,
}
impl<'a> CommentFindUnique<'a> {
	pub async fn exec(self) -> Option<CommentData> {
		self.query.perform::<Option<CommentData>>().await.unwrap()
	}
	pub fn delete(self) -> CommentDelete<'a> {
		CommentDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Comment".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<CommentSetParam>) -> CommentUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		CommentUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
		}
	}
	pub fn with(mut self, fetches: Vec<CommentWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct CommentCreateOne<'a> {
	query: Query<'a>,
}
impl<'a> CommentCreateOne<'a> {
	pub async fn exec(self) -> CommentData {
		self.query.perform::<CommentData>().await.unwrap()
	}
}
pub struct CommentUpdateUnique<'a> {
	query: Query<'a>,
}
impl<'a> CommentUpdateUnique<'a> {
	pub async fn exec(self) -> CommentData {
		self.query.perform::<CommentData>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<CommentWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct CommentUpdateMany<'a> {
	query: Query<'a>,
}
impl<'a> CommentUpdateMany<'a> {
	pub async fn exec(self) -> Vec<CommentData> {
		self.query.perform::<Vec<CommentData>>().await.unwrap()
	}
	pub fn with(mut self, fetches: Vec<CommentWith>) -> Self {
		let outputs = fetches.into_iter().map(|f| f.param.output()).collect::<Vec<_>>();
		self.query.outputs.extend(outputs);
		self
	}
}
pub struct CommentDelete<'a> {
	query: Query<'a>,
}
impl<'a> CommentDelete<'a> {
	pub async fn exec(self) -> isize {
		self.query.perform::<DeleteResult>().await.unwrap().count
	}
}
pub struct CommentActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> CommentActions<'a> {
	pub fn find_unique(&self, param: CommentWhereParam) -> CommentFindUnique {
		let fields = transform_equals(vec![param.field()]);
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Comment".into(),
			outputs: comment_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		CommentFindUnique { query }
	}
	pub fn find_first(&self, params: Vec<CommentWhereParam>) -> CommentFindFirst {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Comment".into(),
			outputs: comment_outputs(),
			inputs,
		};
		CommentFindFirst { query }
	}
	pub fn find_many(&self, params: Vec<CommentWhereParam>) -> CommentFindMany {
		let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Comment".into(),
			outputs: comment_outputs(),
			inputs,
		};
		CommentFindMany { query }
	}
	pub fn create_one(&self, content: CommentSetContent, params: Vec<CommentSetParam>) -> CommentCreateOne {
		let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
		input_fields.push(CommentSetParam::from(content).field());
		let query = Query {
			ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Comment".into(),
			outputs: comment_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		CommentCreateOne { query }
	}
}
