// Code generated by Prisma Client Rust. DO NOT EDIT.

#![allow(dead_code)]
use prisma_client_rust::datamodel::parse_configuration;
use prisma_client_rust::prisma_models::InternalDataModelBuilder;
use prisma_client_rust::query::{
	transform_equals, Field, Input, Output, Query, QueryContext, Result as QueryResult,
};
use prisma_client_rust::query_core::{
	executor, schema_builder, BuildMode, QueryExecutor, QuerySchema,
};
use prisma_client_rust::{
	chrono, operator::Operator, serde_json, DeleteResult, Direction,
};
pub use prisma_client_rust::{query::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
pub struct PrismaClient {
	executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
	query_schema: Arc<QuerySchema>,
}
pub async fn new_client() -> Result<PrismaClient, NewClientError> {
	let datamodel_str = "datasource db {\n    provider = \"sqlite\"\n    url      = \"file:dev.db\"\n}\n\ngenerator client {\n    provider = \"prisma-client-rust\"\n    output   = \"../src/prisma.rs\"\n}\n\nmodel Migration {\n    id            Int      @id @default(autoincrement())\n    name          String\n    checksum      String   @unique\n    steps_applied Int      @default(0)\n    applied_at    DateTime @default(now())\n\n    @@map(\"_migrations\")\n}\n\nmodel Library {\n    id           Int      @id @default(autoincrement())\n    uuid         String   @unique\n    name         String\n    remote_id    String?\n    is_primary   Boolean  @default(true)\n    encryption   Int      @default(0)\n    date_created DateTime @default(now())\n    timezone     String?\n    spaces       Space[]\n\n    @@map(\"libraries\")\n}\n\nmodel LibraryStatistics {\n    id                  Int      @id @default(autoincrement())\n    date_captured       DateTime @default(now())\n    library_id          Int      @unique\n    total_file_count    Int      @default(0)\n    total_bytes_used    String   @default(\"0\")\n    total_byte_capacity String   @default(\"0\")\n    total_unique_bytes  String   @default(\"0\")\n\n    @@map(\"library_statistics\")\n}\n\nmodel Client {\n    id           Int      @id @default(autoincrement())\n    uuid         String   @unique\n    name         String\n    platform     Int      @default(0)\n    version      String?\n    online       Boolean? @default(true)\n    last_seen    DateTime @default(now())\n    timezone     String?\n    date_created DateTime @default(now())\n    // jobs         Job[]\n\n    @@map(\"clients\")\n}\n\nmodel Location {\n    id                 Int      @id @default(autoincrement())\n    name               String?\n    local_path         String?\n    total_capacity     Int?\n    available_capacity Int?\n    filesystem         String?\n    disk_type          Int?\n    is_removable       Boolean  @default(true)\n    is_ejectable       Boolean  @default(true)\n    is_root_filesystem Boolean  @default(true)\n    is_online          Boolean  @default(true)\n    date_created       DateTime @default(now())\n\n    file_paths FilePath[]\n    @@map(\"locations\")\n}\n\nmodel File {\n    id               Int     @id @default(autoincrement())\n    kind             Int     @default(0)\n    size_in_bytes    String\n    partial_checksum String\n    checksum         String? @unique\n    encryption       Int     @default(0)\n    ipfs_id          String?\n\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    date_indexed  DateTime @default(now())\n\n    file_tags   TagOnFile[]\n    file_labels LabelOnFile[]\n    file_paths  FilePath[]\n    comments    Comment[]\n    @@map(\"files\")\n}\n\nmodel FilePath {\n    id                Int     @id @default(autoincrement())\n    is_dir            Boolean @default(false)\n    location_id       Int\n    materialized_path String\n    name              String\n    extension         String?\n    file_id           Int?\n    parent_id         Int?\n    encryption        Int     @default(0)\n    permissions       String?\n\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    date_indexed  DateTime @default(now())\n\n    file     File?      @relation(fields: [file_id], references: [id], onDelete: Cascade, onUpdate: Cascade)\n    location Location?  @relation(fields: [location_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n    parent   FilePath?  @relation(\"directory_file_paths\", fields: [parent_id], references: [id])\n    children FilePath[] @relation(\"directory_file_paths\")\n\n    @@unique([location_id, materialized_path, name, extension])\n    @@map(\"file_paths\")\n}\n\nmodel Tag {\n    id              Int      @id @default(autoincrement())\n    name            String?\n    encryption      Int?     @default(0)\n    total_files     Int?     @default(0)\n    redundancy_goal Int?     @default(1)\n    date_created    DateTime @default(now())\n    date_modified   DateTime @default(now())\n\n    tag_files TagOnFile[]\n    @@map(\"tags\")\n}\n\nmodel TagOnFile {\n    date_created DateTime @default(now())\n\n    tag_id Int\n    tag    Tag @relation(fields: [tag_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    file_id Int\n    file    File @relation(fields: [file_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@id([tag_id, file_id])\n    @@map(\"tags_on_files\")\n}\n\nmodel Label {\n    id            Int      @id @default(autoincrement())\n    name          String?\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n\n    label_files LabelOnFile[]\n    @@map(\"labels\")\n}\n\nmodel LabelOnFile {\n    date_created DateTime @default(now())\n\n    label_id Int\n    label    Label @relation(fields: [label_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    file_id Int\n    file    File @relation(fields: [file_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@id([label_id, file_id])\n    @@map(\"label_on_files\")\n}\n\nmodel Job {\n    id     String @id\n    // client_id Int\n    action Int\n    status Int    @default(0)\n\n    task_count           Int      @default(1)\n    completed_task_count Int      @default(0)\n    date_created         DateTime @default(now())\n    date_modified        DateTime @default(now())\n    // clients              Client   @relation(fields: [client_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n    seconds_elapsed      Int      @default(0)\n\n    @@map(\"jobs\")\n}\n\nmodel Space {\n    id            Int      @id @default(autoincrement())\n    name          String\n    encryption    Int?     @default(0) // remove\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    Library       Library? @relation(fields: [libraryId], references: [id])\n    libraryId     Int?\n\n    @@map(\"spaces\")\n}\n\nmodel Album {\n    id        Int     @id @default(autoincrement())\n    name      String\n    is_hidden Boolean @default(false)\n\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n\n    @@map(\"albums\")\n}\n\nmodel Comment {\n    id            Int      @id @default(autoincrement())\n    content       String\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    file_id       Int?\n    file          File?    @relation(fields: [file_id], references: [id])\n\n    @@map(\"comments\")\n}\n" ;
	let config = parse_configuration(datamodel_str)?.subject;
	let source = config
		.datasources
		.first()
		.expect("Pleasy supply a datasource in your schema.prisma file");
	let url = if let Some(url) = source.load_shadow_database_url()? {
		url
	} else {
		source.load_url(|key| std::env::var(key).ok())?
	};
	let url = match url.split(":").collect::<Vec<_>>().as_slice() {
		["file", path] => {
			if Path::new("./schema.prisma").exists() {
				url
			} else if Path::new("./prisma/schema.prisma").exists() {
				format!("file:./prisma/{}", path)
			} else {
				url
			}
		},
		_ => url,
	};
	new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<PrismaClient, NewClientError> {
	let datamodel_str = "datasource db {\n    provider = \"sqlite\"\n    url      = \"file:dev.db\"\n}\n\ngenerator client {\n    provider = \"prisma-client-rust\"\n    output   = \"../src/prisma.rs\"\n}\n\nmodel Migration {\n    id            Int      @id @default(autoincrement())\n    name          String\n    checksum      String   @unique\n    steps_applied Int      @default(0)\n    applied_at    DateTime @default(now())\n\n    @@map(\"_migrations\")\n}\n\nmodel Library {\n    id           Int      @id @default(autoincrement())\n    uuid         String   @unique\n    name         String\n    remote_id    String?\n    is_primary   Boolean  @default(true)\n    encryption   Int      @default(0)\n    date_created DateTime @default(now())\n    timezone     String?\n    spaces       Space[]\n\n    @@map(\"libraries\")\n}\n\nmodel LibraryStatistics {\n    id                  Int      @id @default(autoincrement())\n    date_captured       DateTime @default(now())\n    library_id          Int      @unique\n    total_file_count    Int      @default(0)\n    total_bytes_used    String   @default(\"0\")\n    total_byte_capacity String   @default(\"0\")\n    total_unique_bytes  String   @default(\"0\")\n\n    @@map(\"library_statistics\")\n}\n\nmodel Client {\n    id           Int      @id @default(autoincrement())\n    uuid         String   @unique\n    name         String\n    platform     Int      @default(0)\n    version      String?\n    online       Boolean? @default(true)\n    last_seen    DateTime @default(now())\n    timezone     String?\n    date_created DateTime @default(now())\n    // jobs         Job[]\n\n    @@map(\"clients\")\n}\n\nmodel Location {\n    id                 Int      @id @default(autoincrement())\n    name               String?\n    local_path         String?\n    total_capacity     Int?\n    available_capacity Int?\n    filesystem         String?\n    disk_type          Int?\n    is_removable       Boolean  @default(true)\n    is_ejectable       Boolean  @default(true)\n    is_root_filesystem Boolean  @default(true)\n    is_online          Boolean  @default(true)\n    date_created       DateTime @default(now())\n\n    file_paths FilePath[]\n    @@map(\"locations\")\n}\n\nmodel File {\n    id               Int     @id @default(autoincrement())\n    kind             Int     @default(0)\n    size_in_bytes    String\n    partial_checksum String\n    checksum         String? @unique\n    encryption       Int     @default(0)\n    ipfs_id          String?\n\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    date_indexed  DateTime @default(now())\n\n    file_tags   TagOnFile[]\n    file_labels LabelOnFile[]\n    file_paths  FilePath[]\n    comments    Comment[]\n    @@map(\"files\")\n}\n\nmodel FilePath {\n    id                Int     @id @default(autoincrement())\n    is_dir            Boolean @default(false)\n    location_id       Int\n    materialized_path String\n    name              String\n    extension         String?\n    file_id           Int?\n    parent_id         Int?\n    encryption        Int     @default(0)\n    permissions       String?\n\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    date_indexed  DateTime @default(now())\n\n    file     File?      @relation(fields: [file_id], references: [id], onDelete: Cascade, onUpdate: Cascade)\n    location Location?  @relation(fields: [location_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n    parent   FilePath?  @relation(\"directory_file_paths\", fields: [parent_id], references: [id])\n    children FilePath[] @relation(\"directory_file_paths\")\n\n    @@unique([location_id, materialized_path, name, extension])\n    @@map(\"file_paths\")\n}\n\nmodel Tag {\n    id              Int      @id @default(autoincrement())\n    name            String?\n    encryption      Int?     @default(0)\n    total_files     Int?     @default(0)\n    redundancy_goal Int?     @default(1)\n    date_created    DateTime @default(now())\n    date_modified   DateTime @default(now())\n\n    tag_files TagOnFile[]\n    @@map(\"tags\")\n}\n\nmodel TagOnFile {\n    date_created DateTime @default(now())\n\n    tag_id Int\n    tag    Tag @relation(fields: [tag_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    file_id Int\n    file    File @relation(fields: [file_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@id([tag_id, file_id])\n    @@map(\"tags_on_files\")\n}\n\nmodel Label {\n    id            Int      @id @default(autoincrement())\n    name          String?\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n\n    label_files LabelOnFile[]\n    @@map(\"labels\")\n}\n\nmodel LabelOnFile {\n    date_created DateTime @default(now())\n\n    label_id Int\n    label    Label @relation(fields: [label_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    file_id Int\n    file    File @relation(fields: [file_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n    @@id([label_id, file_id])\n    @@map(\"label_on_files\")\n}\n\nmodel Job {\n    id     String @id\n    // client_id Int\n    action Int\n    status Int    @default(0)\n\n    task_count           Int      @default(1)\n    completed_task_count Int      @default(0)\n    date_created         DateTime @default(now())\n    date_modified        DateTime @default(now())\n    // clients              Client   @relation(fields: [client_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n    seconds_elapsed      Int      @default(0)\n\n    @@map(\"jobs\")\n}\n\nmodel Space {\n    id            Int      @id @default(autoincrement())\n    name          String\n    encryption    Int?     @default(0) // remove\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    Library       Library? @relation(fields: [libraryId], references: [id])\n    libraryId     Int?\n\n    @@map(\"spaces\")\n}\n\nmodel Album {\n    id        Int     @id @default(autoincrement())\n    name      String\n    is_hidden Boolean @default(false)\n\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n\n    @@map(\"albums\")\n}\n\nmodel Comment {\n    id            Int      @id @default(autoincrement())\n    content       String\n    date_created  DateTime @default(now())\n    date_modified DateTime @default(now())\n    file_id       Int?\n    file          File?    @relation(fields: [file_id], references: [id])\n\n    @@map(\"comments\")\n}\n" ;
	let config = parse_configuration(datamodel_str)?.subject;
	let source = config
		.datasources
		.first()
		.expect("Pleasy supply a datasource in your schema.prisma file");
	let (db_name, executor) = executor::load(&source, &[], &url).await?;
	let internal_model = InternalDataModelBuilder::new(&datamodel_str).build(db_name);
	let query_schema = Arc::new(schema_builder::build(
		internal_model,
		BuildMode::Modern,
		true,
		source.capabilities(),
		vec![],
		source.referential_integrity(),
	));
	executor.primary_connector().get_connection().await?;
	Ok(PrismaClient {
		executor,
		query_schema,
	})
}
impl PrismaClient {
	pub async fn _query_raw<T: serde::de::DeserializeOwned>(
		&self,
		query: &str,
	) -> QueryResult<Vec<T>> {
		let query = Query {
			ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
			operation: "mutation".into(),
			method: "queryRaw".into(),
			inputs: vec![
				Input {
					name: "query".into(),
					value: Some(query.into()),
					..Default::default()
				},
				Input {
					name: "parameters".into(),
					value: Some("[]".into()),
					..Default::default()
				},
			],
			name: "".into(),
			model: "".into(),
			outputs: vec![],
		};
		query.perform().await
	}
	pub async fn _execute_raw(&self, query: &str) -> QueryResult<i64> {
		let query = Query {
			ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
			operation: "mutation".into(),
			method: "executeRaw".into(),
			inputs: vec![
				Input {
					name: "query".into(),
					value: Some(query.into()),
					..Default::default()
				},
				Input {
					name: "parameters".into(),
					value: Some("[]".into()),
					..Default::default()
				},
			],
			name: "".into(),
			model: "".into(),
			outputs: vec![],
		};
		query.perform().await.map(|result: i64| result)
	}
	pub fn migration(&self) -> MigrationActions {
		MigrationActions { client: &self }
	}
	pub fn library(&self) -> LibraryActions {
		LibraryActions { client: &self }
	}
	pub fn library_statistics(&self) -> LibraryStatisticsActions {
		LibraryStatisticsActions { client: &self }
	}
	pub fn client(&self) -> ClientActions {
		ClientActions { client: &self }
	}
	pub fn location(&self) -> LocationActions {
		LocationActions { client: &self }
	}
	pub fn file(&self) -> FileActions {
		FileActions { client: &self }
	}
	pub fn file_path(&self) -> FilePathActions {
		FilePathActions { client: &self }
	}
	pub fn tag(&self) -> TagActions {
		TagActions { client: &self }
	}
	pub fn tag_on_file(&self) -> TagOnFileActions {
		TagOnFileActions { client: &self }
	}
	pub fn label(&self) -> LabelActions {
		LabelActions { client: &self }
	}
	pub fn label_on_file(&self) -> LabelOnFileActions {
		LabelOnFileActions { client: &self }
	}
	pub fn job(&self) -> JobActions {
		JobActions { client: &self }
	}
	pub fn space(&self) -> SpaceActions {
		SpaceActions { client: &self }
	}
	pub fn album(&self) -> AlbumActions {
		AlbumActions { client: &self }
	}
	pub fn comment(&self) -> CommentActions {
		CommentActions { client: &self }
	}
}
fn migration_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("checksum"),
		Output::new("steps_applied"),
		Output::new("applied_at"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MigrationData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "checksum")]
	pub checksum: String,
	#[serde(rename = "steps_applied")]
	pub steps_applied: i32,
	#[serde(rename = "applied_at")]
	pub applied_at: chrono::DateTime<chrono::Utc>,
}
impl MigrationData {}
pub struct Migration;
impl Migration {
	pub fn id() -> MigrationIdField {
		MigrationIdField {}
	}
	pub fn name() -> MigrationNameField {
		MigrationNameField {}
	}
	pub fn checksum() -> MigrationChecksumField {
		MigrationChecksumField {}
	}
	pub fn steps_applied() -> MigrationStepsAppliedField {
		MigrationStepsAppliedField {}
	}
	pub fn applied_at() -> MigrationAppliedAtField {
		MigrationAppliedAtField {}
	}
}
pub struct MigrationIdField {}
impl MigrationIdField {
	pub fn set<T: From<MigrationSetId>>(&self, value: i32) -> T {
		MigrationSetId(value).into()
	}
	pub fn equals<T: From<MigrationWhereUniqueParam>>(&self, value: i32) -> T {
		MigrationWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> MigrationOrderByParam {
		MigrationOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> MigrationCursor {
		MigrationCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> MigrationSetParam {
		MigrationSetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> MigrationSetParam {
		MigrationSetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> MigrationSetParam {
		MigrationSetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> MigrationSetParam {
		MigrationSetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> MigrationWhereParam {
		MigrationWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> MigrationWhereParam {
		MigrationWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> MigrationWhereParam {
		MigrationWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> MigrationWhereParam {
		MigrationWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> MigrationWhereParam {
		MigrationWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> MigrationWhereParam {
		MigrationWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> MigrationWhereParam {
		MigrationWhereParam::IdNot(value)
	}
}
pub struct MigrationSetId(i32);
impl From<MigrationSetId> for MigrationSetParam {
	fn from(value: MigrationSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct MigrationNameField {}
impl MigrationNameField {
	pub fn set<T: From<MigrationSetName>>(&self, value: String) -> T {
		MigrationSetName(value).into()
	}
	pub fn equals(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> MigrationOrderByParam {
		MigrationOrderByParam::Name(direction)
	}
	pub fn cursor(&self, cursor: String) -> MigrationCursor {
		MigrationCursor::Name(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> MigrationWhereParam {
		MigrationWhereParam::NameInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> MigrationWhereParam {
		MigrationWhereParam::NameNotInVec(value)
	}
	pub fn lt(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameLt(value)
	}
	pub fn lte(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameLte(value)
	}
	pub fn gt(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameGt(value)
	}
	pub fn gte(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameGte(value)
	}
	pub fn contains(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameContains(value)
	}
	pub fn starts_with(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameEndsWith(value)
	}
	pub fn not(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::NameNot(value)
	}
}
pub struct MigrationSetName(String);
impl From<MigrationSetName> for MigrationSetParam {
	fn from(value: MigrationSetName) -> Self {
		Self::SetName(value.0)
	}
}
pub struct MigrationChecksumField {}
impl MigrationChecksumField {
	pub fn set<T: From<MigrationSetChecksum>>(&self, value: String) -> T {
		MigrationSetChecksum(value).into()
	}
	pub fn equals<T: From<MigrationWhereUniqueParam>>(&self, value: String) -> T {
		MigrationWhereUniqueParam::ChecksumEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> MigrationOrderByParam {
		MigrationOrderByParam::Checksum(direction)
	}
	pub fn cursor(&self, cursor: String) -> MigrationCursor {
		MigrationCursor::Checksum(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumNotInVec(value)
	}
	pub fn lt(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumLt(value)
	}
	pub fn lte(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumLte(value)
	}
	pub fn gt(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumGt(value)
	}
	pub fn gte(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumGte(value)
	}
	pub fn contains(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumContains(value)
	}
	pub fn starts_with(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumEndsWith(value)
	}
	pub fn not(&self, value: String) -> MigrationWhereParam {
		MigrationWhereParam::ChecksumNot(value)
	}
}
pub struct MigrationSetChecksum(String);
impl From<MigrationSetChecksum> for MigrationSetParam {
	fn from(value: MigrationSetChecksum) -> Self {
		Self::SetChecksum(value.0)
	}
}
pub struct MigrationStepsAppliedField {}
impl MigrationStepsAppliedField {
	pub fn set<T: From<MigrationSetStepsApplied>>(&self, value: i32) -> T {
		MigrationSetStepsApplied(value).into()
	}
	pub fn equals(&self, value: i32) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> MigrationOrderByParam {
		MigrationOrderByParam::StepsApplied(direction)
	}
	pub fn cursor(&self, cursor: i32) -> MigrationCursor {
		MigrationCursor::StepsApplied(cursor)
	}
	pub fn increment(&self, value: i32) -> MigrationSetParam {
		MigrationSetParam::SetStepsApplied(value)
	}
	pub fn decrement(&self, value: i32) -> MigrationSetParam {
		MigrationSetParam::SetStepsApplied(value)
	}
	pub fn multiply(&self, value: i32) -> MigrationSetParam {
		MigrationSetParam::SetStepsApplied(value)
	}
	pub fn divide(&self, value: i32) -> MigrationSetParam {
		MigrationSetParam::SetStepsApplied(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedLt(value)
	}
	pub fn lte(&self, value: i32) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedLte(value)
	}
	pub fn gt(&self, value: i32) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedGt(value)
	}
	pub fn gte(&self, value: i32) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedGte(value)
	}
	pub fn not(&self, value: i32) -> MigrationWhereParam {
		MigrationWhereParam::StepsAppliedNot(value)
	}
}
pub struct MigrationSetStepsApplied(i32);
impl From<MigrationSetStepsApplied> for MigrationSetParam {
	fn from(value: MigrationSetStepsApplied) -> Self {
		Self::SetStepsApplied(value.0)
	}
}
pub struct MigrationAppliedAtField {}
impl MigrationAppliedAtField {
	pub fn set<T: From<MigrationSetAppliedAt>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		MigrationSetAppliedAt(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> MigrationOrderByParam {
		MigrationOrderByParam::AppliedAt(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> MigrationCursor {
		MigrationCursor::AppliedAt(cursor)
	}
	pub fn in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> MigrationWhereParam {
		MigrationWhereParam::AppliedAtNot(value)
	}
}
pub struct MigrationSetAppliedAt(chrono::DateTime<chrono::Utc>);
impl From<MigrationSetAppliedAt> for MigrationSetParam {
	fn from(value: MigrationSetAppliedAt) -> Self {
		Self::SetAppliedAt(value.0)
	}
}
pub enum MigrationWithParam {}
impl MigrationWithParam {
	pub fn to_output(self) -> Output {
		match self {}
	}
}
pub enum MigrationSetParam {
	SetId(i32),
	SetName(String),
	SetChecksum(String),
	SetStepsApplied(i32),
	SetAppliedAt(chrono::DateTime<chrono::Utc>),
}
impl MigrationSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetName(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetChecksum(value) => Field {
				name: "checksum".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetStepsApplied(value) => Field {
				name: "steps_applied".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetAppliedAt(value) => Field {
				name: "applied_at".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum MigrationOrderByParam {
	Id(Direction),
	Name(Direction),
	Checksum(Direction),
	StepsApplied(Direction),
	AppliedAt(Direction),
}
impl MigrationOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Name(direction) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Checksum(direction) => Field {
				name: "checksum".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::StepsApplied(direction) => Field {
				name: "steps_applied".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::AppliedAt(direction) => Field {
				name: "applied_at".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum MigrationCursor {
	Id(i32),
	Name(String),
	Checksum(String),
	StepsApplied(i32),
	AppliedAt(chrono::DateTime<chrono::Utc>),
}
impl MigrationCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Checksum(value) => Field {
				name: "checksum".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::StepsApplied(value) => Field {
				name: "steps_applied".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::AppliedAt(value) => Field {
				name: "applied_at".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum MigrationWhereParam {
	Not(Vec<MigrationWhereParam>),
	Or(Vec<MigrationWhereParam>),
	And(Vec<MigrationWhereParam>),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	NameEquals(String),
	NameInVec(Vec<String>),
	NameNotInVec(Vec<String>),
	NameLt(String),
	NameLte(String),
	NameGt(String),
	NameGte(String),
	NameContains(String),
	NameStartsWith(String),
	NameEndsWith(String),
	NameNot(String),
	ChecksumEquals(String),
	ChecksumInVec(Vec<String>),
	ChecksumNotInVec(Vec<String>),
	ChecksumLt(String),
	ChecksumLte(String),
	ChecksumGt(String),
	ChecksumGte(String),
	ChecksumContains(String),
	ChecksumStartsWith(String),
	ChecksumEndsWith(String),
	ChecksumNot(String),
	StepsAppliedEquals(i32),
	StepsAppliedInVec(Vec<i32>),
	StepsAppliedNotInVec(Vec<i32>),
	StepsAppliedLt(i32),
	StepsAppliedLte(i32),
	StepsAppliedGt(i32),
	StepsAppliedGte(i32),
	StepsAppliedNot(i32),
	AppliedAtEquals(chrono::DateTime<chrono::Utc>),
	AppliedAtInVec(Vec<chrono::DateTime<chrono::Utc>>),
	AppliedAtNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	AppliedAtLt(chrono::DateTime<chrono::Utc>),
	AppliedAtLte(chrono::DateTime<chrono::Utc>),
	AppliedAtGt(chrono::DateTime<chrono::Utc>),
	AppliedAtGte(chrono::DateTime<chrono::Utc>),
	AppliedAtNot(chrono::DateTime<chrono::Utc>),
}
impl MigrationWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNotInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameStartsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEndsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNot(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumEquals(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumInVec(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumNotInVec(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumLt(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumLte(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumGt(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumGte(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumContains(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumStartsWith(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumEndsWith(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumNot(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedEquals(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedInVec(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedNotInVec(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedLt(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedLte(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedGt(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedGte(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StepsAppliedNot(value) => Field {
				name: "steps_applied".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtEquals(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtInVec(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtNotInVec(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtLt(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtLte(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtGt(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtGte(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AppliedAtNot(value) => Field {
				name: "applied_at".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum MigrationWhereUniqueParam {
	IdEquals(i32),
	ChecksumEquals(String),
}
impl From<MigrationWhereUniqueParam> for MigrationWhereParam {
	fn from(value: MigrationWhereUniqueParam) -> Self {
		match value {
			MigrationWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
			MigrationWhereUniqueParam::ChecksumEquals(value) => {
				Self::ChecksumEquals(value)
			},
		}
	}
}
impl From<Operator<Self>> for MigrationWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct MigrationFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<MigrationOrderByParam>,
	with_params: Vec<MigrationWithParam>,
}
impl<'a> MigrationFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<MigrationData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> MigrationDelete<'a> {
		MigrationDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Migration".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<MigrationSetParam>) -> MigrationUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		MigrationUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: MigrationOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: MigrationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: MigrationCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct MigrationFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<MigrationOrderByParam>,
	with_params: Vec<MigrationWithParam>,
}
impl<'a> MigrationFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<MigrationData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: MigrationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: MigrationOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: MigrationCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct MigrationFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<MigrationWithParam>,
}
impl<'a> MigrationFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<MigrationData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> MigrationDelete<'a> {
		MigrationDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Migration".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<MigrationSetParam>) -> MigrationUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		MigrationUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: MigrationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct MigrationCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<MigrationWithParam>,
}
impl<'a> MigrationCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<MigrationData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: MigrationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct MigrationUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<MigrationWithParam>,
}
impl<'a> MigrationUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<MigrationData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: MigrationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct MigrationUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<MigrationWithParam>,
}
impl<'a> MigrationUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<MigrationData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: MigrationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct MigrationUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> MigrationUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<MigrationData> {
		self.query.perform().await
	}
	pub fn create(
		mut self,
		name: MigrationSetName,
		checksum: MigrationSetChecksum,
		params: Vec<MigrationSetParam>,
	) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(MigrationSetParam::from(name).to_field());
		input_fields.push(MigrationSetParam::from(checksum).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<MigrationSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct MigrationDelete<'a> {
	query: Query<'a>,
}
impl<'a> MigrationDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct MigrationActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> MigrationActions<'a> {
	pub fn find_unique(&self, param: MigrationWhereUniqueParam) -> MigrationFindUnique {
		let param: MigrationWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Migration".into(),
			outputs: migration_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		MigrationFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<MigrationWhereParam>) -> MigrationFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Migration".into(),
			outputs: migration_outputs(),
			inputs,
		};
		MigrationFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<MigrationWhereParam>) -> MigrationFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Migration".into(),
			outputs: migration_outputs(),
			inputs,
		};
		MigrationFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		name: MigrationSetName,
		checksum: MigrationSetChecksum,
		params: Vec<MigrationSetParam>,
	) -> MigrationCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(MigrationSetParam::from(name).to_field());
		input_fields.push(MigrationSetParam::from(checksum).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Migration".into(),
			outputs: migration_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		MigrationCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: MigrationWhereUniqueParam) -> MigrationUpsertOne {
		let param: MigrationWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "Migration".into(),
			outputs: migration_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		MigrationUpsertOne { query }
	}
}
fn library_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("uuid"),
		Output::new("name"),
		Output::new("remote_id"),
		Output::new("is_primary"),
		Output::new("encryption"),
		Output::new("date_created"),
		Output::new("timezone"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LibraryData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "uuid")]
	pub uuid: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "remote_id")]
	pub remote_id: Option<String>,
	#[serde(rename = "is_primary")]
	pub is_primary: bool,
	#[serde(rename = "encryption")]
	pub encryption: i32,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "timezone")]
	pub timezone: Option<String>,
	#[serde(rename = "spaces")]
	spaces: Option<Vec<SpaceData>>,
}
impl LibraryData {
	pub fn spaces(&self) -> Result<&Vec<SpaceData>, String> {
		match self . spaces . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access spaces but did not fetch it using the .with() syntax" . to_string ()) , }
	}
}
pub struct Library;
impl Library {
	pub fn id() -> LibraryIdField {
		LibraryIdField {}
	}
	pub fn uuid() -> LibraryUuidField {
		LibraryUuidField {}
	}
	pub fn name() -> LibraryNameField {
		LibraryNameField {}
	}
	pub fn remote_id() -> LibraryRemoteIdField {
		LibraryRemoteIdField {}
	}
	pub fn is_primary() -> LibraryIsPrimaryField {
		LibraryIsPrimaryField {}
	}
	pub fn encryption() -> LibraryEncryptionField {
		LibraryEncryptionField {}
	}
	pub fn date_created() -> LibraryDateCreatedField {
		LibraryDateCreatedField {}
	}
	pub fn timezone() -> LibraryTimezoneField {
		LibraryTimezoneField {}
	}
	pub fn spaces() -> LibrarySpacesField {
		LibrarySpacesField {}
	}
}
pub struct LibraryIdField {}
impl LibraryIdField {
	pub fn set<T: From<LibrarySetId>>(&self, value: i32) -> T {
		LibrarySetId(value).into()
	}
	pub fn equals<T: From<LibraryWhereUniqueParam>>(&self, value: i32) -> T {
		LibraryWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryOrderByParam {
		LibraryOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LibraryCursor {
		LibraryCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> LibrarySetParam {
		LibrarySetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> LibrarySetParam {
		LibrarySetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> LibrarySetParam {
		LibrarySetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> LibrarySetParam {
		LibrarySetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LibraryWhereParam {
		LibraryWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LibraryWhereParam {
		LibraryWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LibraryWhereParam {
		LibraryWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> LibraryWhereParam {
		LibraryWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> LibraryWhereParam {
		LibraryWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> LibraryWhereParam {
		LibraryWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> LibraryWhereParam {
		LibraryWhereParam::IdNot(value)
	}
}
pub struct LibrarySetId(i32);
impl From<LibrarySetId> for LibrarySetParam {
	fn from(value: LibrarySetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct LibraryUuidField {}
impl LibraryUuidField {
	pub fn set<T: From<LibrarySetUuid>>(&self, value: String) -> T {
		LibrarySetUuid(value).into()
	}
	pub fn equals<T: From<LibraryWhereUniqueParam>>(&self, value: String) -> T {
		LibraryWhereUniqueParam::UuidEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryOrderByParam {
		LibraryOrderByParam::Uuid(direction)
	}
	pub fn cursor(&self, cursor: String) -> LibraryCursor {
		LibraryCursor::Uuid(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> LibraryWhereParam {
		LibraryWhereParam::UuidInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> LibraryWhereParam {
		LibraryWhereParam::UuidNotInVec(value)
	}
	pub fn lt(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidLt(value)
	}
	pub fn lte(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidLte(value)
	}
	pub fn gt(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidGt(value)
	}
	pub fn gte(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidGte(value)
	}
	pub fn contains(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidContains(value)
	}
	pub fn starts_with(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidEndsWith(value)
	}
	pub fn not(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::UuidNot(value)
	}
}
pub struct LibrarySetUuid(String);
impl From<LibrarySetUuid> for LibrarySetParam {
	fn from(value: LibrarySetUuid) -> Self {
		Self::SetUuid(value.0)
	}
}
pub struct LibraryNameField {}
impl LibraryNameField {
	pub fn set<T: From<LibrarySetName>>(&self, value: String) -> T {
		LibrarySetName(value).into()
	}
	pub fn equals(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryOrderByParam {
		LibraryOrderByParam::Name(direction)
	}
	pub fn cursor(&self, cursor: String) -> LibraryCursor {
		LibraryCursor::Name(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> LibraryWhereParam {
		LibraryWhereParam::NameInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> LibraryWhereParam {
		LibraryWhereParam::NameNotInVec(value)
	}
	pub fn lt(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameLt(value)
	}
	pub fn lte(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameLte(value)
	}
	pub fn gt(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameGt(value)
	}
	pub fn gte(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameGte(value)
	}
	pub fn contains(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameContains(value)
	}
	pub fn starts_with(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameEndsWith(value)
	}
	pub fn not(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::NameNot(value)
	}
}
pub struct LibrarySetName(String);
impl From<LibrarySetName> for LibrarySetParam {
	fn from(value: LibrarySetName) -> Self {
		Self::SetName(value.0)
	}
}
pub struct LibraryRemoteIdField {}
impl LibraryRemoteIdField {
	pub fn set<T: From<LibrarySetRemoteId>>(&self, value: String) -> T {
		LibrarySetRemoteId(value).into()
	}
	pub fn equals(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryOrderByParam {
		LibraryOrderByParam::RemoteId(direction)
	}
	pub fn cursor(&self, cursor: String) -> LibraryCursor {
		LibraryCursor::RemoteId(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdNotInVec(value)
	}
	pub fn lt(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdLt(value)
	}
	pub fn lte(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdLte(value)
	}
	pub fn gt(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdGt(value)
	}
	pub fn gte(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdGte(value)
	}
	pub fn contains(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdContains(value)
	}
	pub fn starts_with(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdEndsWith(value)
	}
	pub fn not(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::RemoteIdNot(value)
	}
}
pub struct LibrarySetRemoteId(String);
impl From<LibrarySetRemoteId> for LibrarySetParam {
	fn from(value: LibrarySetRemoteId) -> Self {
		Self::SetRemoteId(value.0)
	}
}
pub struct LibraryIsPrimaryField {}
impl LibraryIsPrimaryField {
	pub fn set<T: From<LibrarySetIsPrimary>>(&self, value: bool) -> T {
		LibrarySetIsPrimary(value).into()
	}
	pub fn equals(&self, value: bool) -> LibraryWhereParam {
		LibraryWhereParam::IsPrimaryEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryOrderByParam {
		LibraryOrderByParam::IsPrimary(direction)
	}
	pub fn cursor(&self, cursor: bool) -> LibraryCursor {
		LibraryCursor::IsPrimary(cursor)
	}
}
pub struct LibrarySetIsPrimary(bool);
impl From<LibrarySetIsPrimary> for LibrarySetParam {
	fn from(value: LibrarySetIsPrimary) -> Self {
		Self::SetIsPrimary(value.0)
	}
}
pub struct LibraryEncryptionField {}
impl LibraryEncryptionField {
	pub fn set<T: From<LibrarySetEncryption>>(&self, value: i32) -> T {
		LibrarySetEncryption(value).into()
	}
	pub fn equals(&self, value: i32) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryOrderByParam {
		LibraryOrderByParam::Encryption(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LibraryCursor {
		LibraryCursor::Encryption(cursor)
	}
	pub fn increment(&self, value: i32) -> LibrarySetParam {
		LibrarySetParam::SetEncryption(value)
	}
	pub fn decrement(&self, value: i32) -> LibrarySetParam {
		LibrarySetParam::SetEncryption(value)
	}
	pub fn multiply(&self, value: i32) -> LibrarySetParam {
		LibrarySetParam::SetEncryption(value)
	}
	pub fn divide(&self, value: i32) -> LibrarySetParam {
		LibrarySetParam::SetEncryption(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionLt(value)
	}
	pub fn lte(&self, value: i32) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionLte(value)
	}
	pub fn gt(&self, value: i32) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionGt(value)
	}
	pub fn gte(&self, value: i32) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionGte(value)
	}
	pub fn not(&self, value: i32) -> LibraryWhereParam {
		LibraryWhereParam::EncryptionNot(value)
	}
}
pub struct LibrarySetEncryption(i32);
impl From<LibrarySetEncryption> for LibrarySetParam {
	fn from(value: LibrarySetEncryption) -> Self {
		Self::SetEncryption(value.0)
	}
}
pub struct LibraryDateCreatedField {}
impl LibraryDateCreatedField {
	pub fn set<T: From<LibrarySetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		LibrarySetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryOrderByParam {
		LibraryOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> LibraryCursor {
		LibraryCursor::DateCreated(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> LibraryWhereParam {
		LibraryWhereParam::DateCreatedNot(value)
	}
}
pub struct LibrarySetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<LibrarySetDateCreated> for LibrarySetParam {
	fn from(value: LibrarySetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct LibraryTimezoneField {}
impl LibraryTimezoneField {
	pub fn set<T: From<LibrarySetTimezone>>(&self, value: String) -> T {
		LibrarySetTimezone(value).into()
	}
	pub fn equals(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryOrderByParam {
		LibraryOrderByParam::Timezone(direction)
	}
	pub fn cursor(&self, cursor: String) -> LibraryCursor {
		LibraryCursor::Timezone(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneNotInVec(value)
	}
	pub fn lt(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneLt(value)
	}
	pub fn lte(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneLte(value)
	}
	pub fn gt(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneGt(value)
	}
	pub fn gte(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneGte(value)
	}
	pub fn contains(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneContains(value)
	}
	pub fn starts_with(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneEndsWith(value)
	}
	pub fn not(&self, value: String) -> LibraryWhereParam {
		LibraryWhereParam::TimezoneNot(value)
	}
}
pub struct LibrarySetTimezone(String);
impl From<LibrarySetTimezone> for LibrarySetParam {
	fn from(value: LibrarySetTimezone) -> Self {
		Self::SetTimezone(value.0)
	}
}
pub struct LibrarySpacesField {}
impl LibrarySpacesField {
	pub fn some(&self, value: Vec<SpaceWhereParam>) -> LibraryWhereParam {
		LibraryWhereParam::SpacesSome(value)
	}
	pub fn every(&self, value: Vec<SpaceWhereParam>) -> LibraryWhereParam {
		LibraryWhereParam::SpacesEvery(value)
	}
	pub fn fetch(&self, params: Vec<SpaceWhereParam>) -> LibraryWithParam {
		LibraryWithParam::Spaces(params)
	}
	pub fn link<T: From<LibraryLinkSpaces>>(
		&self,
		params: Vec<SpaceWhereUniqueParam>,
	) -> T {
		LibraryLinkSpaces(params).into()
	}
	pub fn unlink(&self, params: Vec<SpaceWhereUniqueParam>) -> LibrarySetParam {
		LibrarySetParam::UnLinkSpaces(params)
	}
}
pub struct LibraryLinkSpaces(Vec<SpaceWhereUniqueParam>);
impl From<LibraryLinkSpaces> for LibrarySetParam {
	fn from(value: LibraryLinkSpaces) -> Self {
		Self::LinkSpaces(value.0)
	}
}
pub enum LibraryWithParam {
	Spaces(Vec<SpaceWhereParam>),
}
impl LibraryWithParam {
	pub fn to_output(self) -> Output {
		match self {
			Self::Spaces(where_params) => Output {
				name: "spaces".into(),
				outputs: space_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params
							.into_iter()
							.map(|param| Into::<SpaceWhereParam>::into(param).to_field())
							.collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
		}
	}
}
pub enum LibrarySetParam {
	SetId(i32),
	SetUuid(String),
	SetName(String),
	SetRemoteId(String),
	SetIsPrimary(bool),
	SetEncryption(i32),
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	SetTimezone(String),
	LinkSpaces(Vec<SpaceWhereUniqueParam>),
	UnLinkSpaces(Vec<SpaceWhereUniqueParam>),
}
impl LibrarySetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetUuid(value) => Field {
				name: "uuid".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetName(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetRemoteId(value) => Field {
				name: "remote_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetIsPrimary(value) => Field {
				name: "is_primary".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetEncryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetTimezone(value) => Field {
				name: "timezone".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkSpaces(where_params) => Field {
				name: "spaces".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| Into::<SpaceWhereParam>::into(param).to_field())
							.collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkSpaces(where_params) => Field {
				name: "spaces".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| Into::<SpaceWhereParam>::into(param).to_field())
							.collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum LibraryOrderByParam {
	Id(Direction),
	Uuid(Direction),
	Name(Direction),
	RemoteId(Direction),
	IsPrimary(Direction),
	Encryption(Direction),
	DateCreated(Direction),
	Timezone(Direction),
}
impl LibraryOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Uuid(direction) => Field {
				name: "uuid".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Name(direction) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::RemoteId(direction) => Field {
				name: "remote_id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::IsPrimary(direction) => Field {
				name: "is_primary".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Encryption(direction) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Timezone(direction) => Field {
				name: "timezone".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum LibraryCursor {
	Id(i32),
	Uuid(String),
	Name(String),
	RemoteId(String),
	IsPrimary(bool),
	Encryption(i32),
	DateCreated(chrono::DateTime<chrono::Utc>),
	Timezone(String),
}
impl LibraryCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Uuid(value) => Field {
				name: "uuid".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::RemoteId(value) => Field {
				name: "remote_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsPrimary(value) => Field {
				name: "is_primary".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Encryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Timezone(value) => Field {
				name: "timezone".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum LibraryWhereParam {
	Not(Vec<LibraryWhereParam>),
	Or(Vec<LibraryWhereParam>),
	And(Vec<LibraryWhereParam>),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	UuidEquals(String),
	UuidInVec(Vec<String>),
	UuidNotInVec(Vec<String>),
	UuidLt(String),
	UuidLte(String),
	UuidGt(String),
	UuidGte(String),
	UuidContains(String),
	UuidStartsWith(String),
	UuidEndsWith(String),
	UuidNot(String),
	NameEquals(String),
	NameInVec(Vec<String>),
	NameNotInVec(Vec<String>),
	NameLt(String),
	NameLte(String),
	NameGt(String),
	NameGte(String),
	NameContains(String),
	NameStartsWith(String),
	NameEndsWith(String),
	NameNot(String),
	RemoteIdEquals(String),
	RemoteIdInVec(Vec<String>),
	RemoteIdNotInVec(Vec<String>),
	RemoteIdLt(String),
	RemoteIdLte(String),
	RemoteIdGt(String),
	RemoteIdGte(String),
	RemoteIdContains(String),
	RemoteIdStartsWith(String),
	RemoteIdEndsWith(String),
	RemoteIdNot(String),
	IsPrimaryEquals(bool),
	EncryptionEquals(i32),
	EncryptionInVec(Vec<i32>),
	EncryptionNotInVec(Vec<i32>),
	EncryptionLt(i32),
	EncryptionLte(i32),
	EncryptionGt(i32),
	EncryptionGte(i32),
	EncryptionNot(i32),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	TimezoneEquals(String),
	TimezoneInVec(Vec<String>),
	TimezoneNotInVec(Vec<String>),
	TimezoneLt(String),
	TimezoneLte(String),
	TimezoneGt(String),
	TimezoneGte(String),
	TimezoneContains(String),
	TimezoneStartsWith(String),
	TimezoneEndsWith(String),
	TimezoneNot(String),
	SpacesSome(Vec<SpaceWhereParam>),
	SpacesEvery(Vec<SpaceWhereParam>),
}
impl LibraryWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidEquals(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidInVec(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidNotInVec(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidLt(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidLte(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidGt(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidGte(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidContains(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidStartsWith(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidEndsWith(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidNot(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNotInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameStartsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEndsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNot(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdEquals(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdInVec(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdNotInVec(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdLt(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdLte(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdGt(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdGte(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdContains(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdStartsWith(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdEndsWith(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RemoteIdNot(value) => Field {
				name: "remote_id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsPrimaryEquals(value) => Field {
				name: "is_primary".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionEquals(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionInVec(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionNotInVec(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLt(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLte(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGt(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGte(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionNot(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneEquals(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneInVec(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneNotInVec(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneLt(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneLte(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneGt(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneGte(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneContains(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneStartsWith(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneEndsWith(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneNot(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SpacesSome(value) => Field {
				name: "spaces".into(),
				fields: Some(vec![Field {
					name: "some".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SpacesEvery(value) => Field {
				name: "spaces".into(),
				fields: Some(vec![Field {
					name: "every".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum LibraryWhereUniqueParam {
	IdEquals(i32),
	UuidEquals(String),
}
impl From<LibraryWhereUniqueParam> for LibraryWhereParam {
	fn from(value: LibraryWhereUniqueParam) -> Self {
		match value {
			LibraryWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
			LibraryWhereUniqueParam::UuidEquals(value) => Self::UuidEquals(value),
		}
	}
}
impl From<Operator<Self>> for LibraryWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct LibraryFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<LibraryOrderByParam>,
	with_params: Vec<LibraryWithParam>,
}
impl<'a> LibraryFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<LibraryData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> LibraryDelete<'a> {
		LibraryDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Library".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LibrarySetParam>) -> LibraryUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LibraryUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: LibraryOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: LibraryWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: LibraryCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct LibraryFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<LibraryOrderByParam>,
	with_params: Vec<LibraryWithParam>,
}
impl<'a> LibraryFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<LibraryData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: LibraryWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: LibraryOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: LibraryCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct LibraryFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<LibraryWithParam>,
}
impl<'a> LibraryFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<LibraryData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> LibraryDelete<'a> {
		LibraryDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Library".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LibrarySetParam>) -> LibraryUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LibraryUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: LibraryWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LibraryCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<LibraryWithParam>,
}
impl<'a> LibraryCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<LibraryData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: LibraryWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LibraryUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<LibraryWithParam>,
}
impl<'a> LibraryUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<LibraryData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: LibraryWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LibraryUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<LibraryWithParam>,
}
impl<'a> LibraryUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<LibraryData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: LibraryWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LibraryUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> LibraryUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<LibraryData> {
		self.query.perform().await
	}
	pub fn create(
		mut self,
		uuid: LibrarySetUuid,
		name: LibrarySetName,
		params: Vec<LibrarySetParam>,
	) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(LibrarySetParam::from(uuid).to_field());
		input_fields.push(LibrarySetParam::from(name).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<LibrarySetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct LibraryDelete<'a> {
	query: Query<'a>,
}
impl<'a> LibraryDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct LibraryActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> LibraryActions<'a> {
	pub fn find_unique(&self, param: LibraryWhereUniqueParam) -> LibraryFindUnique {
		let param: LibraryWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Library".into(),
			outputs: library_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LibraryFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<LibraryWhereParam>) -> LibraryFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Library".into(),
			outputs: library_outputs(),
			inputs,
		};
		LibraryFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<LibraryWhereParam>) -> LibraryFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Library".into(),
			outputs: library_outputs(),
			inputs,
		};
		LibraryFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		uuid: LibrarySetUuid,
		name: LibrarySetName,
		params: Vec<LibrarySetParam>,
	) -> LibraryCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(LibrarySetParam::from(uuid).to_field());
		input_fields.push(LibrarySetParam::from(name).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Library".into(),
			outputs: library_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		LibraryCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: LibraryWhereUniqueParam) -> LibraryUpsertOne {
		let param: LibraryWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "Library".into(),
			outputs: library_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LibraryUpsertOne { query }
	}
}
fn library_statistics_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("date_captured"),
		Output::new("library_id"),
		Output::new("total_file_count"),
		Output::new("total_bytes_used"),
		Output::new("total_byte_capacity"),
		Output::new("total_unique_bytes"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LibraryStatisticsData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "date_captured")]
	pub date_captured: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "library_id")]
	pub library_id: i32,
	#[serde(rename = "total_file_count")]
	pub total_file_count: i32,
	#[serde(rename = "total_bytes_used")]
	pub total_bytes_used: String,
	#[serde(rename = "total_byte_capacity")]
	pub total_byte_capacity: String,
	#[serde(rename = "total_unique_bytes")]
	pub total_unique_bytes: String,
}
impl LibraryStatisticsData {}
pub struct LibraryStatistics;
impl LibraryStatistics {
	pub fn id() -> LibraryStatisticsIdField {
		LibraryStatisticsIdField {}
	}
	pub fn date_captured() -> LibraryStatisticsDateCapturedField {
		LibraryStatisticsDateCapturedField {}
	}
	pub fn library_id() -> LibraryStatisticsLibraryIdField {
		LibraryStatisticsLibraryIdField {}
	}
	pub fn total_file_count() -> LibraryStatisticsTotalFileCountField {
		LibraryStatisticsTotalFileCountField {}
	}
	pub fn total_bytes_used() -> LibraryStatisticsTotalBytesUsedField {
		LibraryStatisticsTotalBytesUsedField {}
	}
	pub fn total_byte_capacity() -> LibraryStatisticsTotalByteCapacityField {
		LibraryStatisticsTotalByteCapacityField {}
	}
	pub fn total_unique_bytes() -> LibraryStatisticsTotalUniqueBytesField {
		LibraryStatisticsTotalUniqueBytesField {}
	}
}
pub struct LibraryStatisticsIdField {}
impl LibraryStatisticsIdField {
	pub fn set<T: From<LibraryStatisticsSetId>>(&self, value: i32) -> T {
		LibraryStatisticsSetId(value).into()
	}
	pub fn equals<T: From<LibraryStatisticsWhereUniqueParam>>(&self, value: i32) -> T {
		LibraryStatisticsWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryStatisticsOrderByParam {
		LibraryStatisticsOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LibraryStatisticsCursor {
		LibraryStatisticsCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::IdNot(value)
	}
}
pub struct LibraryStatisticsSetId(i32);
impl From<LibraryStatisticsSetId> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct LibraryStatisticsDateCapturedField {}
impl LibraryStatisticsDateCapturedField {
	pub fn set<T: From<LibraryStatisticsSetDateCaptured>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		LibraryStatisticsSetDateCaptured(value).into()
	}
	pub fn equals(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryStatisticsOrderByParam {
		LibraryStatisticsOrderByParam::DateCaptured(direction)
	}
	pub fn cursor(
		&self,
		cursor: chrono::DateTime<chrono::Utc>,
	) -> LibraryStatisticsCursor {
		LibraryStatisticsCursor::DateCaptured(cursor)
	}
	pub fn in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedNotInVec(value)
	}
	pub fn lt(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedLt(value)
	}
	pub fn lte(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedLte(value)
	}
	pub fn gt(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedGt(value)
	}
	pub fn gte(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedGte(value)
	}
	pub fn not(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::DateCapturedNot(value)
	}
}
pub struct LibraryStatisticsSetDateCaptured(chrono::DateTime<chrono::Utc>);
impl From<LibraryStatisticsSetDateCaptured> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetDateCaptured) -> Self {
		Self::SetDateCaptured(value.0)
	}
}
pub struct LibraryStatisticsLibraryIdField {}
impl LibraryStatisticsLibraryIdField {
	pub fn set<T: From<LibraryStatisticsSetLibraryId>>(&self, value: i32) -> T {
		LibraryStatisticsSetLibraryId(value).into()
	}
	pub fn equals<T: From<LibraryStatisticsWhereUniqueParam>>(&self, value: i32) -> T {
		LibraryStatisticsWhereUniqueParam::LibraryIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryStatisticsOrderByParam {
		LibraryStatisticsOrderByParam::LibraryId(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LibraryStatisticsCursor {
		LibraryStatisticsCursor::LibraryId(cursor)
	}
	pub fn increment(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetLibraryId(value)
	}
	pub fn decrement(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetLibraryId(value)
	}
	pub fn multiply(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetLibraryId(value)
	}
	pub fn divide(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetLibraryId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdLt(value)
	}
	pub fn lte(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdLte(value)
	}
	pub fn gt(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdGt(value)
	}
	pub fn gte(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdGte(value)
	}
	pub fn not(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::LibraryIdNot(value)
	}
}
pub struct LibraryStatisticsSetLibraryId(i32);
impl From<LibraryStatisticsSetLibraryId> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetLibraryId) -> Self {
		Self::SetLibraryId(value.0)
	}
}
pub struct LibraryStatisticsTotalFileCountField {}
impl LibraryStatisticsTotalFileCountField {
	pub fn set<T: From<LibraryStatisticsSetTotalFileCount>>(&self, value: i32) -> T {
		LibraryStatisticsSetTotalFileCount(value).into()
	}
	pub fn equals(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryStatisticsOrderByParam {
		LibraryStatisticsOrderByParam::TotalFileCount(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LibraryStatisticsCursor {
		LibraryStatisticsCursor::TotalFileCount(cursor)
	}
	pub fn increment(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetTotalFileCount(value)
	}
	pub fn decrement(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetTotalFileCount(value)
	}
	pub fn multiply(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetTotalFileCount(value)
	}
	pub fn divide(&self, value: i32) -> LibraryStatisticsSetParam {
		LibraryStatisticsSetParam::SetTotalFileCount(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountLt(value)
	}
	pub fn lte(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountLte(value)
	}
	pub fn gt(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountGt(value)
	}
	pub fn gte(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountGte(value)
	}
	pub fn not(&self, value: i32) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalFileCountNot(value)
	}
}
pub struct LibraryStatisticsSetTotalFileCount(i32);
impl From<LibraryStatisticsSetTotalFileCount> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetTotalFileCount) -> Self {
		Self::SetTotalFileCount(value.0)
	}
}
pub struct LibraryStatisticsTotalBytesUsedField {}
impl LibraryStatisticsTotalBytesUsedField {
	pub fn set<T: From<LibraryStatisticsSetTotalBytesUsed>>(&self, value: String) -> T {
		LibraryStatisticsSetTotalBytesUsed(value).into()
	}
	pub fn equals(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryStatisticsOrderByParam {
		LibraryStatisticsOrderByParam::TotalBytesUsed(direction)
	}
	pub fn cursor(&self, cursor: String) -> LibraryStatisticsCursor {
		LibraryStatisticsCursor::TotalBytesUsed(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedNotInVec(value)
	}
	pub fn lt(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedLt(value)
	}
	pub fn lte(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedLte(value)
	}
	pub fn gt(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedGt(value)
	}
	pub fn gte(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedGte(value)
	}
	pub fn contains(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedContains(value)
	}
	pub fn starts_with(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedEndsWith(value)
	}
	pub fn not(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalBytesUsedNot(value)
	}
}
pub struct LibraryStatisticsSetTotalBytesUsed(String);
impl From<LibraryStatisticsSetTotalBytesUsed> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetTotalBytesUsed) -> Self {
		Self::SetTotalBytesUsed(value.0)
	}
}
pub struct LibraryStatisticsTotalByteCapacityField {}
impl LibraryStatisticsTotalByteCapacityField {
	pub fn set<T: From<LibraryStatisticsSetTotalByteCapacity>>(
		&self,
		value: String,
	) -> T {
		LibraryStatisticsSetTotalByteCapacity(value).into()
	}
	pub fn equals(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryStatisticsOrderByParam {
		LibraryStatisticsOrderByParam::TotalByteCapacity(direction)
	}
	pub fn cursor(&self, cursor: String) -> LibraryStatisticsCursor {
		LibraryStatisticsCursor::TotalByteCapacity(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityNotInVec(value)
	}
	pub fn lt(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityLt(value)
	}
	pub fn lte(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityLte(value)
	}
	pub fn gt(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityGt(value)
	}
	pub fn gte(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityGte(value)
	}
	pub fn contains(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityContains(value)
	}
	pub fn starts_with(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityEndsWith(value)
	}
	pub fn not(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalByteCapacityNot(value)
	}
}
pub struct LibraryStatisticsSetTotalByteCapacity(String);
impl From<LibraryStatisticsSetTotalByteCapacity> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetTotalByteCapacity) -> Self {
		Self::SetTotalByteCapacity(value.0)
	}
}
pub struct LibraryStatisticsTotalUniqueBytesField {}
impl LibraryStatisticsTotalUniqueBytesField {
	pub fn set<T: From<LibraryStatisticsSetTotalUniqueBytes>>(&self, value: String) -> T {
		LibraryStatisticsSetTotalUniqueBytes(value).into()
	}
	pub fn equals(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LibraryStatisticsOrderByParam {
		LibraryStatisticsOrderByParam::TotalUniqueBytes(direction)
	}
	pub fn cursor(&self, cursor: String) -> LibraryStatisticsCursor {
		LibraryStatisticsCursor::TotalUniqueBytes(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesNotInVec(value)
	}
	pub fn lt(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesLt(value)
	}
	pub fn lte(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesLte(value)
	}
	pub fn gt(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesGt(value)
	}
	pub fn gte(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesGte(value)
	}
	pub fn contains(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesContains(value)
	}
	pub fn starts_with(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesEndsWith(value)
	}
	pub fn not(&self, value: String) -> LibraryStatisticsWhereParam {
		LibraryStatisticsWhereParam::TotalUniqueBytesNot(value)
	}
}
pub struct LibraryStatisticsSetTotalUniqueBytes(String);
impl From<LibraryStatisticsSetTotalUniqueBytes> for LibraryStatisticsSetParam {
	fn from(value: LibraryStatisticsSetTotalUniqueBytes) -> Self {
		Self::SetTotalUniqueBytes(value.0)
	}
}
pub enum LibraryStatisticsWithParam {}
impl LibraryStatisticsWithParam {
	pub fn to_output(self) -> Output {
		match self {}
	}
}
pub enum LibraryStatisticsSetParam {
	SetId(i32),
	SetDateCaptured(chrono::DateTime<chrono::Utc>),
	SetLibraryId(i32),
	SetTotalFileCount(i32),
	SetTotalBytesUsed(String),
	SetTotalByteCapacity(String),
	SetTotalUniqueBytes(String),
}
impl LibraryStatisticsSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCaptured(value) => Field {
				name: "date_captured".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetLibraryId(value) => Field {
				name: "library_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetTotalFileCount(value) => Field {
				name: "total_file_count".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetTotalBytesUsed(value) => Field {
				name: "total_bytes_used".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetTotalByteCapacity(value) => Field {
				name: "total_byte_capacity".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetTotalUniqueBytes(value) => Field {
				name: "total_unique_bytes".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum LibraryStatisticsOrderByParam {
	Id(Direction),
	DateCaptured(Direction),
	LibraryId(Direction),
	TotalFileCount(Direction),
	TotalBytesUsed(Direction),
	TotalByteCapacity(Direction),
	TotalUniqueBytes(Direction),
}
impl LibraryStatisticsOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCaptured(direction) => Field {
				name: "date_captured".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::LibraryId(direction) => Field {
				name: "library_id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::TotalFileCount(direction) => Field {
				name: "total_file_count".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::TotalBytesUsed(direction) => Field {
				name: "total_bytes_used".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::TotalByteCapacity(direction) => Field {
				name: "total_byte_capacity".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::TotalUniqueBytes(direction) => Field {
				name: "total_unique_bytes".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum LibraryStatisticsCursor {
	Id(i32),
	DateCaptured(chrono::DateTime<chrono::Utc>),
	LibraryId(i32),
	TotalFileCount(i32),
	TotalBytesUsed(String),
	TotalByteCapacity(String),
	TotalUniqueBytes(String),
}
impl LibraryStatisticsCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCaptured(value) => Field {
				name: "date_captured".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LibraryId(value) => Field {
				name: "library_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalFileCount(value) => Field {
				name: "total_file_count".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalBytesUsed(value) => Field {
				name: "total_bytes_used".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalByteCapacity(value) => Field {
				name: "total_byte_capacity".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalUniqueBytes(value) => Field {
				name: "total_unique_bytes".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum LibraryStatisticsWhereParam {
	Not(Vec<LibraryStatisticsWhereParam>),
	Or(Vec<LibraryStatisticsWhereParam>),
	And(Vec<LibraryStatisticsWhereParam>),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	DateCapturedEquals(chrono::DateTime<chrono::Utc>),
	DateCapturedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCapturedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCapturedLt(chrono::DateTime<chrono::Utc>),
	DateCapturedLte(chrono::DateTime<chrono::Utc>),
	DateCapturedGt(chrono::DateTime<chrono::Utc>),
	DateCapturedGte(chrono::DateTime<chrono::Utc>),
	DateCapturedNot(chrono::DateTime<chrono::Utc>),
	LibraryIdEquals(i32),
	LibraryIdInVec(Vec<i32>),
	LibraryIdNotInVec(Vec<i32>),
	LibraryIdLt(i32),
	LibraryIdLte(i32),
	LibraryIdGt(i32),
	LibraryIdGte(i32),
	LibraryIdNot(i32),
	TotalFileCountEquals(i32),
	TotalFileCountInVec(Vec<i32>),
	TotalFileCountNotInVec(Vec<i32>),
	TotalFileCountLt(i32),
	TotalFileCountLte(i32),
	TotalFileCountGt(i32),
	TotalFileCountGte(i32),
	TotalFileCountNot(i32),
	TotalBytesUsedEquals(String),
	TotalBytesUsedInVec(Vec<String>),
	TotalBytesUsedNotInVec(Vec<String>),
	TotalBytesUsedLt(String),
	TotalBytesUsedLte(String),
	TotalBytesUsedGt(String),
	TotalBytesUsedGte(String),
	TotalBytesUsedContains(String),
	TotalBytesUsedStartsWith(String),
	TotalBytesUsedEndsWith(String),
	TotalBytesUsedNot(String),
	TotalByteCapacityEquals(String),
	TotalByteCapacityInVec(Vec<String>),
	TotalByteCapacityNotInVec(Vec<String>),
	TotalByteCapacityLt(String),
	TotalByteCapacityLte(String),
	TotalByteCapacityGt(String),
	TotalByteCapacityGte(String),
	TotalByteCapacityContains(String),
	TotalByteCapacityStartsWith(String),
	TotalByteCapacityEndsWith(String),
	TotalByteCapacityNot(String),
	TotalUniqueBytesEquals(String),
	TotalUniqueBytesInVec(Vec<String>),
	TotalUniqueBytesNotInVec(Vec<String>),
	TotalUniqueBytesLt(String),
	TotalUniqueBytesLte(String),
	TotalUniqueBytesGt(String),
	TotalUniqueBytesGte(String),
	TotalUniqueBytesContains(String),
	TotalUniqueBytesStartsWith(String),
	TotalUniqueBytesEndsWith(String),
	TotalUniqueBytesNot(String),
}
impl LibraryStatisticsWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedEquals(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedInVec(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedNotInVec(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedLt(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedLte(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedGt(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedGte(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCapturedNot(value) => Field {
				name: "date_captured".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdEquals(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdInVec(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdNotInVec(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdLt(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdLte(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdGt(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdGte(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdNot(value) => Field {
				name: "library_id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountEquals(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountInVec(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountNotInVec(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountLt(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountLte(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountGt(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountGte(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFileCountNot(value) => Field {
				name: "total_file_count".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedEquals(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedInVec(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedNotInVec(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedLt(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedLte(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedGt(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedGte(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedContains(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedStartsWith(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedEndsWith(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalBytesUsedNot(value) => Field {
				name: "total_bytes_used".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityEquals(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityInVec(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityNotInVec(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityLt(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityLte(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityGt(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityGte(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityContains(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityStartsWith(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityEndsWith(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalByteCapacityNot(value) => Field {
				name: "total_byte_capacity".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesEquals(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesInVec(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesNotInVec(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesLt(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesLte(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesGt(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesGte(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesContains(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesStartsWith(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesEndsWith(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalUniqueBytesNot(value) => Field {
				name: "total_unique_bytes".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum LibraryStatisticsWhereUniqueParam {
	IdEquals(i32),
	LibraryIdEquals(i32),
}
impl From<LibraryStatisticsWhereUniqueParam> for LibraryStatisticsWhereParam {
	fn from(value: LibraryStatisticsWhereUniqueParam) -> Self {
		match value {
			LibraryStatisticsWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
			LibraryStatisticsWhereUniqueParam::LibraryIdEquals(value) => {
				Self::LibraryIdEquals(value)
			},
		}
	}
}
impl From<Operator<Self>> for LibraryStatisticsWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct LibraryStatisticsFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<LibraryStatisticsOrderByParam>,
	with_params: Vec<LibraryStatisticsWithParam>,
}
impl<'a> LibraryStatisticsFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<LibraryStatisticsData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> LibraryStatisticsDelete<'a> {
		LibraryStatisticsDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "LibraryStatistics".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(
		mut self,
		params: Vec<LibraryStatisticsSetParam>,
	) -> LibraryStatisticsUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LibraryStatisticsUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: LibraryStatisticsOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: LibraryStatisticsWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: LibraryStatisticsCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct LibraryStatisticsFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<LibraryStatisticsOrderByParam>,
	with_params: Vec<LibraryStatisticsWithParam>,
}
impl<'a> LibraryStatisticsFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<LibraryStatisticsData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: LibraryStatisticsWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: LibraryStatisticsOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: LibraryStatisticsCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct LibraryStatisticsFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<LibraryStatisticsWithParam>,
}
impl<'a> LibraryStatisticsFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<LibraryStatisticsData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> LibraryStatisticsDelete<'a> {
		LibraryStatisticsDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "LibraryStatistics".into(),
				..self.query
			},
		}
	}
	pub fn update(
		mut self,
		params: Vec<LibraryStatisticsSetParam>,
	) -> LibraryStatisticsUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LibraryStatisticsUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: LibraryStatisticsWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LibraryStatisticsCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<LibraryStatisticsWithParam>,
}
impl<'a> LibraryStatisticsCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<LibraryStatisticsData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: LibraryStatisticsWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LibraryStatisticsUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<LibraryStatisticsWithParam>,
}
impl<'a> LibraryStatisticsUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<LibraryStatisticsData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: LibraryStatisticsWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LibraryStatisticsUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<LibraryStatisticsWithParam>,
}
impl<'a> LibraryStatisticsUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<LibraryStatisticsData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: LibraryStatisticsWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LibraryStatisticsUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> LibraryStatisticsUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<LibraryStatisticsData> {
		self.query.perform().await
	}
	pub fn create(
		mut self,
		library_id: LibraryStatisticsSetLibraryId,
		params: Vec<LibraryStatisticsSetParam>,
	) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(LibraryStatisticsSetParam::from(library_id).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<LibraryStatisticsSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct LibraryStatisticsDelete<'a> {
	query: Query<'a>,
}
impl<'a> LibraryStatisticsDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct LibraryStatisticsActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> LibraryStatisticsActions<'a> {
	pub fn find_unique(
		&self,
		param: LibraryStatisticsWhereUniqueParam,
	) -> LibraryStatisticsFindUnique {
		let param: LibraryStatisticsWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "LibraryStatistics".into(),
			outputs: library_statistics_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LibraryStatisticsFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(
		&self,
		params: Vec<LibraryStatisticsWhereParam>,
	) -> LibraryStatisticsFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "LibraryStatistics".into(),
			outputs: library_statistics_outputs(),
			inputs,
		};
		LibraryStatisticsFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(
		&self,
		params: Vec<LibraryStatisticsWhereParam>,
	) -> LibraryStatisticsFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "LibraryStatistics".into(),
			outputs: library_statistics_outputs(),
			inputs,
		};
		LibraryStatisticsFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		library_id: LibraryStatisticsSetLibraryId,
		params: Vec<LibraryStatisticsSetParam>,
	) -> LibraryStatisticsCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(LibraryStatisticsSetParam::from(library_id).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "LibraryStatistics".into(),
			outputs: library_statistics_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		LibraryStatisticsCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(
		&self,
		param: LibraryStatisticsWhereUniqueParam,
	) -> LibraryStatisticsUpsertOne {
		let param: LibraryStatisticsWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "LibraryStatistics".into(),
			outputs: library_statistics_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LibraryStatisticsUpsertOne { query }
	}
}
fn client_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("uuid"),
		Output::new("name"),
		Output::new("platform"),
		Output::new("version"),
		Output::new("online"),
		Output::new("last_seen"),
		Output::new("timezone"),
		Output::new("date_created"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "uuid")]
	pub uuid: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "platform")]
	pub platform: i32,
	#[serde(rename = "version")]
	pub version: Option<String>,
	#[serde(rename = "online")]
	pub online: Option<bool>,
	#[serde(rename = "last_seen")]
	pub last_seen: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "timezone")]
	pub timezone: Option<String>,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
}
impl ClientData {}
pub struct Client;
impl Client {
	pub fn id() -> ClientIdField {
		ClientIdField {}
	}
	pub fn uuid() -> ClientUuidField {
		ClientUuidField {}
	}
	pub fn name() -> ClientNameField {
		ClientNameField {}
	}
	pub fn platform() -> ClientPlatformField {
		ClientPlatformField {}
	}
	pub fn version() -> ClientVersionField {
		ClientVersionField {}
	}
	pub fn online() -> ClientOnlineField {
		ClientOnlineField {}
	}
	pub fn last_seen() -> ClientLastSeenField {
		ClientLastSeenField {}
	}
	pub fn timezone() -> ClientTimezoneField {
		ClientTimezoneField {}
	}
	pub fn date_created() -> ClientDateCreatedField {
		ClientDateCreatedField {}
	}
}
pub struct ClientIdField {}
impl ClientIdField {
	pub fn set<T: From<ClientSetId>>(&self, value: i32) -> T {
		ClientSetId(value).into()
	}
	pub fn equals<T: From<ClientWhereUniqueParam>>(&self, value: i32) -> T {
		ClientWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> ClientOrderByParam {
		ClientOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> ClientCursor {
		ClientCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> ClientSetParam {
		ClientSetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> ClientSetParam {
		ClientSetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> ClientSetParam {
		ClientSetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> ClientSetParam {
		ClientSetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> ClientWhereParam {
		ClientWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> ClientWhereParam {
		ClientWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> ClientWhereParam {
		ClientWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> ClientWhereParam {
		ClientWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> ClientWhereParam {
		ClientWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> ClientWhereParam {
		ClientWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> ClientWhereParam {
		ClientWhereParam::IdNot(value)
	}
}
pub struct ClientSetId(i32);
impl From<ClientSetId> for ClientSetParam {
	fn from(value: ClientSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct ClientUuidField {}
impl ClientUuidField {
	pub fn set<T: From<ClientSetUuid>>(&self, value: String) -> T {
		ClientSetUuid(value).into()
	}
	pub fn equals<T: From<ClientWhereUniqueParam>>(&self, value: String) -> T {
		ClientWhereUniqueParam::UuidEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> ClientOrderByParam {
		ClientOrderByParam::Uuid(direction)
	}
	pub fn cursor(&self, cursor: String) -> ClientCursor {
		ClientCursor::Uuid(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> ClientWhereParam {
		ClientWhereParam::UuidInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> ClientWhereParam {
		ClientWhereParam::UuidNotInVec(value)
	}
	pub fn lt(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidLt(value)
	}
	pub fn lte(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidLte(value)
	}
	pub fn gt(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidGt(value)
	}
	pub fn gte(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidGte(value)
	}
	pub fn contains(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidContains(value)
	}
	pub fn starts_with(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidEndsWith(value)
	}
	pub fn not(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::UuidNot(value)
	}
}
pub struct ClientSetUuid(String);
impl From<ClientSetUuid> for ClientSetParam {
	fn from(value: ClientSetUuid) -> Self {
		Self::SetUuid(value.0)
	}
}
pub struct ClientNameField {}
impl ClientNameField {
	pub fn set<T: From<ClientSetName>>(&self, value: String) -> T {
		ClientSetName(value).into()
	}
	pub fn equals(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> ClientOrderByParam {
		ClientOrderByParam::Name(direction)
	}
	pub fn cursor(&self, cursor: String) -> ClientCursor {
		ClientCursor::Name(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> ClientWhereParam {
		ClientWhereParam::NameInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> ClientWhereParam {
		ClientWhereParam::NameNotInVec(value)
	}
	pub fn lt(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameLt(value)
	}
	pub fn lte(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameLte(value)
	}
	pub fn gt(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameGt(value)
	}
	pub fn gte(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameGte(value)
	}
	pub fn contains(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameContains(value)
	}
	pub fn starts_with(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameEndsWith(value)
	}
	pub fn not(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::NameNot(value)
	}
}
pub struct ClientSetName(String);
impl From<ClientSetName> for ClientSetParam {
	fn from(value: ClientSetName) -> Self {
		Self::SetName(value.0)
	}
}
pub struct ClientPlatformField {}
impl ClientPlatformField {
	pub fn set<T: From<ClientSetPlatform>>(&self, value: i32) -> T {
		ClientSetPlatform(value).into()
	}
	pub fn equals(&self, value: i32) -> ClientWhereParam {
		ClientWhereParam::PlatformEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> ClientOrderByParam {
		ClientOrderByParam::Platform(direction)
	}
	pub fn cursor(&self, cursor: i32) -> ClientCursor {
		ClientCursor::Platform(cursor)
	}
	pub fn increment(&self, value: i32) -> ClientSetParam {
		ClientSetParam::SetPlatform(value)
	}
	pub fn decrement(&self, value: i32) -> ClientSetParam {
		ClientSetParam::SetPlatform(value)
	}
	pub fn multiply(&self, value: i32) -> ClientSetParam {
		ClientSetParam::SetPlatform(value)
	}
	pub fn divide(&self, value: i32) -> ClientSetParam {
		ClientSetParam::SetPlatform(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> ClientWhereParam {
		ClientWhereParam::PlatformInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> ClientWhereParam {
		ClientWhereParam::PlatformNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> ClientWhereParam {
		ClientWhereParam::PlatformLt(value)
	}
	pub fn lte(&self, value: i32) -> ClientWhereParam {
		ClientWhereParam::PlatformLte(value)
	}
	pub fn gt(&self, value: i32) -> ClientWhereParam {
		ClientWhereParam::PlatformGt(value)
	}
	pub fn gte(&self, value: i32) -> ClientWhereParam {
		ClientWhereParam::PlatformGte(value)
	}
	pub fn not(&self, value: i32) -> ClientWhereParam {
		ClientWhereParam::PlatformNot(value)
	}
}
pub struct ClientSetPlatform(i32);
impl From<ClientSetPlatform> for ClientSetParam {
	fn from(value: ClientSetPlatform) -> Self {
		Self::SetPlatform(value.0)
	}
}
pub struct ClientVersionField {}
impl ClientVersionField {
	pub fn set<T: From<ClientSetVersion>>(&self, value: String) -> T {
		ClientSetVersion(value).into()
	}
	pub fn equals(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> ClientOrderByParam {
		ClientOrderByParam::Version(direction)
	}
	pub fn cursor(&self, cursor: String) -> ClientCursor {
		ClientCursor::Version(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> ClientWhereParam {
		ClientWhereParam::VersionInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> ClientWhereParam {
		ClientWhereParam::VersionNotInVec(value)
	}
	pub fn lt(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionLt(value)
	}
	pub fn lte(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionLte(value)
	}
	pub fn gt(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionGt(value)
	}
	pub fn gte(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionGte(value)
	}
	pub fn contains(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionContains(value)
	}
	pub fn starts_with(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionEndsWith(value)
	}
	pub fn not(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::VersionNot(value)
	}
}
pub struct ClientSetVersion(String);
impl From<ClientSetVersion> for ClientSetParam {
	fn from(value: ClientSetVersion) -> Self {
		Self::SetVersion(value.0)
	}
}
pub struct ClientOnlineField {}
impl ClientOnlineField {
	pub fn set<T: From<ClientSetOnline>>(&self, value: bool) -> T {
		ClientSetOnline(value).into()
	}
	pub fn equals(&self, value: bool) -> ClientWhereParam {
		ClientWhereParam::OnlineEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> ClientOrderByParam {
		ClientOrderByParam::Online(direction)
	}
	pub fn cursor(&self, cursor: bool) -> ClientCursor {
		ClientCursor::Online(cursor)
	}
}
pub struct ClientSetOnline(bool);
impl From<ClientSetOnline> for ClientSetParam {
	fn from(value: ClientSetOnline) -> Self {
		Self::SetOnline(value.0)
	}
}
pub struct ClientLastSeenField {}
impl ClientLastSeenField {
	pub fn set<T: From<ClientSetLastSeen>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		ClientSetLastSeen(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::LastSeenEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> ClientOrderByParam {
		ClientOrderByParam::LastSeen(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> ClientCursor {
		ClientCursor::LastSeen(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> ClientWhereParam {
		ClientWhereParam::LastSeenInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> ClientWhereParam {
		ClientWhereParam::LastSeenNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::LastSeenLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::LastSeenLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::LastSeenGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::LastSeenGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::LastSeenNot(value)
	}
}
pub struct ClientSetLastSeen(chrono::DateTime<chrono::Utc>);
impl From<ClientSetLastSeen> for ClientSetParam {
	fn from(value: ClientSetLastSeen) -> Self {
		Self::SetLastSeen(value.0)
	}
}
pub struct ClientTimezoneField {}
impl ClientTimezoneField {
	pub fn set<T: From<ClientSetTimezone>>(&self, value: String) -> T {
		ClientSetTimezone(value).into()
	}
	pub fn equals(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> ClientOrderByParam {
		ClientOrderByParam::Timezone(direction)
	}
	pub fn cursor(&self, cursor: String) -> ClientCursor {
		ClientCursor::Timezone(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> ClientWhereParam {
		ClientWhereParam::TimezoneInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> ClientWhereParam {
		ClientWhereParam::TimezoneNotInVec(value)
	}
	pub fn lt(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneLt(value)
	}
	pub fn lte(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneLte(value)
	}
	pub fn gt(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneGt(value)
	}
	pub fn gte(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneGte(value)
	}
	pub fn contains(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneContains(value)
	}
	pub fn starts_with(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneEndsWith(value)
	}
	pub fn not(&self, value: String) -> ClientWhereParam {
		ClientWhereParam::TimezoneNot(value)
	}
}
pub struct ClientSetTimezone(String);
impl From<ClientSetTimezone> for ClientSetParam {
	fn from(value: ClientSetTimezone) -> Self {
		Self::SetTimezone(value.0)
	}
}
pub struct ClientDateCreatedField {}
impl ClientDateCreatedField {
	pub fn set<T: From<ClientSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		ClientSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> ClientOrderByParam {
		ClientOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> ClientCursor {
		ClientCursor::DateCreated(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> ClientWhereParam {
		ClientWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> ClientWhereParam {
		ClientWhereParam::DateCreatedNot(value)
	}
}
pub struct ClientSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<ClientSetDateCreated> for ClientSetParam {
	fn from(value: ClientSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub enum ClientWithParam {}
impl ClientWithParam {
	pub fn to_output(self) -> Output {
		match self {}
	}
}
pub enum ClientSetParam {
	SetId(i32),
	SetUuid(String),
	SetName(String),
	SetPlatform(i32),
	SetVersion(String),
	SetOnline(bool),
	SetLastSeen(chrono::DateTime<chrono::Utc>),
	SetTimezone(String),
	SetDateCreated(chrono::DateTime<chrono::Utc>),
}
impl ClientSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetUuid(value) => Field {
				name: "uuid".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetName(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetPlatform(value) => Field {
				name: "platform".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetVersion(value) => Field {
				name: "version".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetOnline(value) => Field {
				name: "online".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetLastSeen(value) => Field {
				name: "last_seen".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetTimezone(value) => Field {
				name: "timezone".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum ClientOrderByParam {
	Id(Direction),
	Uuid(Direction),
	Name(Direction),
	Platform(Direction),
	Version(Direction),
	Online(Direction),
	LastSeen(Direction),
	Timezone(Direction),
	DateCreated(Direction),
}
impl ClientOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Uuid(direction) => Field {
				name: "uuid".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Name(direction) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Platform(direction) => Field {
				name: "platform".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Version(direction) => Field {
				name: "version".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Online(direction) => Field {
				name: "online".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::LastSeen(direction) => Field {
				name: "last_seen".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Timezone(direction) => Field {
				name: "timezone".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum ClientCursor {
	Id(i32),
	Uuid(String),
	Name(String),
	Platform(i32),
	Version(String),
	Online(bool),
	LastSeen(chrono::DateTime<chrono::Utc>),
	Timezone(String),
	DateCreated(chrono::DateTime<chrono::Utc>),
}
impl ClientCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Uuid(value) => Field {
				name: "uuid".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Platform(value) => Field {
				name: "platform".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Version(value) => Field {
				name: "version".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Online(value) => Field {
				name: "online".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LastSeen(value) => Field {
				name: "last_seen".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Timezone(value) => Field {
				name: "timezone".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum ClientWhereParam {
	Not(Vec<ClientWhereParam>),
	Or(Vec<ClientWhereParam>),
	And(Vec<ClientWhereParam>),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	UuidEquals(String),
	UuidInVec(Vec<String>),
	UuidNotInVec(Vec<String>),
	UuidLt(String),
	UuidLte(String),
	UuidGt(String),
	UuidGte(String),
	UuidContains(String),
	UuidStartsWith(String),
	UuidEndsWith(String),
	UuidNot(String),
	NameEquals(String),
	NameInVec(Vec<String>),
	NameNotInVec(Vec<String>),
	NameLt(String),
	NameLte(String),
	NameGt(String),
	NameGte(String),
	NameContains(String),
	NameStartsWith(String),
	NameEndsWith(String),
	NameNot(String),
	PlatformEquals(i32),
	PlatformInVec(Vec<i32>),
	PlatformNotInVec(Vec<i32>),
	PlatformLt(i32),
	PlatformLte(i32),
	PlatformGt(i32),
	PlatformGte(i32),
	PlatformNot(i32),
	VersionEquals(String),
	VersionInVec(Vec<String>),
	VersionNotInVec(Vec<String>),
	VersionLt(String),
	VersionLte(String),
	VersionGt(String),
	VersionGte(String),
	VersionContains(String),
	VersionStartsWith(String),
	VersionEndsWith(String),
	VersionNot(String),
	OnlineEquals(bool),
	LastSeenEquals(chrono::DateTime<chrono::Utc>),
	LastSeenInVec(Vec<chrono::DateTime<chrono::Utc>>),
	LastSeenNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	LastSeenLt(chrono::DateTime<chrono::Utc>),
	LastSeenLte(chrono::DateTime<chrono::Utc>),
	LastSeenGt(chrono::DateTime<chrono::Utc>),
	LastSeenGte(chrono::DateTime<chrono::Utc>),
	LastSeenNot(chrono::DateTime<chrono::Utc>),
	TimezoneEquals(String),
	TimezoneInVec(Vec<String>),
	TimezoneNotInVec(Vec<String>),
	TimezoneLt(String),
	TimezoneLte(String),
	TimezoneGt(String),
	TimezoneGte(String),
	TimezoneContains(String),
	TimezoneStartsWith(String),
	TimezoneEndsWith(String),
	TimezoneNot(String),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
}
impl ClientWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidEquals(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidInVec(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidNotInVec(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidLt(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidLte(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidGt(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidGte(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidContains(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidStartsWith(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidEndsWith(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UuidNot(value) => Field {
				name: "uuid".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNotInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameStartsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEndsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNot(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformEquals(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformInVec(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformNotInVec(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformLt(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformLte(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformGt(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformGte(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PlatformNot(value) => Field {
				name: "platform".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionEquals(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionInVec(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionNotInVec(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionLt(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionLte(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionGt(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionGte(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionContains(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionStartsWith(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionEndsWith(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::VersionNot(value) => Field {
				name: "version".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::OnlineEquals(value) => Field {
				name: "online".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenEquals(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenInVec(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenNotInVec(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenLt(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenLte(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenGt(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenGte(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LastSeenNot(value) => Field {
				name: "last_seen".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneEquals(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneInVec(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneNotInVec(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneLt(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneLte(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneGt(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneGte(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneContains(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneStartsWith(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneEndsWith(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TimezoneNot(value) => Field {
				name: "timezone".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum ClientWhereUniqueParam {
	IdEquals(i32),
	UuidEquals(String),
}
impl From<ClientWhereUniqueParam> for ClientWhereParam {
	fn from(value: ClientWhereUniqueParam) -> Self {
		match value {
			ClientWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
			ClientWhereUniqueParam::UuidEquals(value) => Self::UuidEquals(value),
		}
	}
}
impl From<Operator<Self>> for ClientWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct ClientFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<ClientOrderByParam>,
	with_params: Vec<ClientWithParam>,
}
impl<'a> ClientFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<ClientData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> ClientDelete<'a> {
		ClientDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Client".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<ClientSetParam>) -> ClientUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		ClientUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: ClientOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: ClientWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: ClientCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct ClientFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<ClientOrderByParam>,
	with_params: Vec<ClientWithParam>,
}
impl<'a> ClientFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<ClientData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: ClientWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: ClientOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: ClientCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct ClientFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<ClientWithParam>,
}
impl<'a> ClientFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<ClientData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> ClientDelete<'a> {
		ClientDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Client".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<ClientSetParam>) -> ClientUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		ClientUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: ClientWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct ClientCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<ClientWithParam>,
}
impl<'a> ClientCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<ClientData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: ClientWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct ClientUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<ClientWithParam>,
}
impl<'a> ClientUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<ClientData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: ClientWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct ClientUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<ClientWithParam>,
}
impl<'a> ClientUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<ClientData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: ClientWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct ClientUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> ClientUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<ClientData> {
		self.query.perform().await
	}
	pub fn create(
		mut self,
		uuid: ClientSetUuid,
		name: ClientSetName,
		params: Vec<ClientSetParam>,
	) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(ClientSetParam::from(uuid).to_field());
		input_fields.push(ClientSetParam::from(name).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<ClientSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct ClientDelete<'a> {
	query: Query<'a>,
}
impl<'a> ClientDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct ClientActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> ClientActions<'a> {
	pub fn find_unique(&self, param: ClientWhereUniqueParam) -> ClientFindUnique {
		let param: ClientWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Client".into(),
			outputs: client_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		ClientFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<ClientWhereParam>) -> ClientFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Client".into(),
			outputs: client_outputs(),
			inputs,
		};
		ClientFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<ClientWhereParam>) -> ClientFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Client".into(),
			outputs: client_outputs(),
			inputs,
		};
		ClientFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		uuid: ClientSetUuid,
		name: ClientSetName,
		params: Vec<ClientSetParam>,
	) -> ClientCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(ClientSetParam::from(uuid).to_field());
		input_fields.push(ClientSetParam::from(name).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Client".into(),
			outputs: client_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		ClientCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: ClientWhereUniqueParam) -> ClientUpsertOne {
		let param: ClientWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "Client".into(),
			outputs: client_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		ClientUpsertOne { query }
	}
}
fn location_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("local_path"),
		Output::new("total_capacity"),
		Output::new("available_capacity"),
		Output::new("filesystem"),
		Output::new("disk_type"),
		Output::new("is_removable"),
		Output::new("is_ejectable"),
		Output::new("is_root_filesystem"),
		Output::new("is_online"),
		Output::new("date_created"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocationData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "name")]
	pub name: Option<String>,
	#[serde(rename = "local_path")]
	pub local_path: Option<String>,
	#[serde(rename = "total_capacity")]
	pub total_capacity: Option<i32>,
	#[serde(rename = "available_capacity")]
	pub available_capacity: Option<i32>,
	#[serde(rename = "filesystem")]
	pub filesystem: Option<String>,
	#[serde(rename = "disk_type")]
	pub disk_type: Option<i32>,
	#[serde(rename = "is_removable")]
	pub is_removable: bool,
	#[serde(rename = "is_ejectable")]
	pub is_ejectable: bool,
	#[serde(rename = "is_root_filesystem")]
	pub is_root_filesystem: bool,
	#[serde(rename = "is_online")]
	pub is_online: bool,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "file_paths")]
	file_paths: Option<Vec<FilePathData>>,
}
impl LocationData {
	pub fn file_paths(&self) -> Result<&Vec<FilePathData>, String> {
		match self . file_paths . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access file_paths but did not fetch it using the .with() syntax" . to_string ()) , }
	}
}
pub struct Location;
impl Location {
	pub fn id() -> LocationIdField {
		LocationIdField {}
	}
	pub fn name() -> LocationNameField {
		LocationNameField {}
	}
	pub fn local_path() -> LocationLocalPathField {
		LocationLocalPathField {}
	}
	pub fn total_capacity() -> LocationTotalCapacityField {
		LocationTotalCapacityField {}
	}
	pub fn available_capacity() -> LocationAvailableCapacityField {
		LocationAvailableCapacityField {}
	}
	pub fn filesystem() -> LocationFilesystemField {
		LocationFilesystemField {}
	}
	pub fn disk_type() -> LocationDiskTypeField {
		LocationDiskTypeField {}
	}
	pub fn is_removable() -> LocationIsRemovableField {
		LocationIsRemovableField {}
	}
	pub fn is_ejectable() -> LocationIsEjectableField {
		LocationIsEjectableField {}
	}
	pub fn is_root_filesystem() -> LocationIsRootFilesystemField {
		LocationIsRootFilesystemField {}
	}
	pub fn is_online() -> LocationIsOnlineField {
		LocationIsOnlineField {}
	}
	pub fn date_created() -> LocationDateCreatedField {
		LocationDateCreatedField {}
	}
	pub fn file_paths() -> LocationFilePathsField {
		LocationFilePathsField {}
	}
}
pub struct LocationIdField {}
impl LocationIdField {
	pub fn set<T: From<LocationSetId>>(&self, value: i32) -> T {
		LocationSetId(value).into()
	}
	pub fn equals<T: From<LocationWhereUniqueParam>>(&self, value: i32) -> T {
		LocationWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LocationCursor {
		LocationCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LocationWhereParam {
		LocationWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LocationWhereParam {
		LocationWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::IdNot(value)
	}
}
pub struct LocationSetId(i32);
impl From<LocationSetId> for LocationSetParam {
	fn from(value: LocationSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct LocationNameField {}
impl LocationNameField {
	pub fn set<T: From<LocationSetName>>(&self, value: String) -> T {
		LocationSetName(value).into()
	}
	pub fn equals(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::Name(direction)
	}
	pub fn cursor(&self, cursor: String) -> LocationCursor {
		LocationCursor::Name(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> LocationWhereParam {
		LocationWhereParam::NameInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> LocationWhereParam {
		LocationWhereParam::NameNotInVec(value)
	}
	pub fn lt(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameLt(value)
	}
	pub fn lte(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameLte(value)
	}
	pub fn gt(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameGt(value)
	}
	pub fn gte(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameGte(value)
	}
	pub fn contains(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameContains(value)
	}
	pub fn starts_with(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameEndsWith(value)
	}
	pub fn not(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::NameNot(value)
	}
}
pub struct LocationSetName(String);
impl From<LocationSetName> for LocationSetParam {
	fn from(value: LocationSetName) -> Self {
		Self::SetName(value.0)
	}
}
pub struct LocationLocalPathField {}
impl LocationLocalPathField {
	pub fn set<T: From<LocationSetLocalPath>>(&self, value: String) -> T {
		LocationSetLocalPath(value).into()
	}
	pub fn equals(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::LocalPath(direction)
	}
	pub fn cursor(&self, cursor: String) -> LocationCursor {
		LocationCursor::LocalPath(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> LocationWhereParam {
		LocationWhereParam::LocalPathInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> LocationWhereParam {
		LocationWhereParam::LocalPathNotInVec(value)
	}
	pub fn lt(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathLt(value)
	}
	pub fn lte(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathLte(value)
	}
	pub fn gt(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathGt(value)
	}
	pub fn gte(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathGte(value)
	}
	pub fn contains(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathContains(value)
	}
	pub fn starts_with(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathEndsWith(value)
	}
	pub fn not(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::LocalPathNot(value)
	}
}
pub struct LocationSetLocalPath(String);
impl From<LocationSetLocalPath> for LocationSetParam {
	fn from(value: LocationSetLocalPath) -> Self {
		Self::SetLocalPath(value.0)
	}
}
pub struct LocationTotalCapacityField {}
impl LocationTotalCapacityField {
	pub fn set<T: From<LocationSetTotalCapacity>>(&self, value: i32) -> T {
		LocationSetTotalCapacity(value).into()
	}
	pub fn equals(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::TotalCapacity(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LocationCursor {
		LocationCursor::TotalCapacity(cursor)
	}
	pub fn increment(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetTotalCapacity(value)
	}
	pub fn decrement(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetTotalCapacity(value)
	}
	pub fn multiply(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetTotalCapacity(value)
	}
	pub fn divide(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetTotalCapacity(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityLt(value)
	}
	pub fn lte(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityLte(value)
	}
	pub fn gt(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityGt(value)
	}
	pub fn gte(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityGte(value)
	}
	pub fn not(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::TotalCapacityNot(value)
	}
}
pub struct LocationSetTotalCapacity(i32);
impl From<LocationSetTotalCapacity> for LocationSetParam {
	fn from(value: LocationSetTotalCapacity) -> Self {
		Self::SetTotalCapacity(value.0)
	}
}
pub struct LocationAvailableCapacityField {}
impl LocationAvailableCapacityField {
	pub fn set<T: From<LocationSetAvailableCapacity>>(&self, value: i32) -> T {
		LocationSetAvailableCapacity(value).into()
	}
	pub fn equals(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::AvailableCapacity(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LocationCursor {
		LocationCursor::AvailableCapacity(cursor)
	}
	pub fn increment(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetAvailableCapacity(value)
	}
	pub fn decrement(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetAvailableCapacity(value)
	}
	pub fn multiply(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetAvailableCapacity(value)
	}
	pub fn divide(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetAvailableCapacity(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityLt(value)
	}
	pub fn lte(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityLte(value)
	}
	pub fn gt(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityGt(value)
	}
	pub fn gte(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityGte(value)
	}
	pub fn not(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::AvailableCapacityNot(value)
	}
}
pub struct LocationSetAvailableCapacity(i32);
impl From<LocationSetAvailableCapacity> for LocationSetParam {
	fn from(value: LocationSetAvailableCapacity) -> Self {
		Self::SetAvailableCapacity(value.0)
	}
}
pub struct LocationFilesystemField {}
impl LocationFilesystemField {
	pub fn set<T: From<LocationSetFilesystem>>(&self, value: String) -> T {
		LocationSetFilesystem(value).into()
	}
	pub fn equals(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::Filesystem(direction)
	}
	pub fn cursor(&self, cursor: String) -> LocationCursor {
		LocationCursor::Filesystem(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> LocationWhereParam {
		LocationWhereParam::FilesystemInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> LocationWhereParam {
		LocationWhereParam::FilesystemNotInVec(value)
	}
	pub fn lt(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemLt(value)
	}
	pub fn lte(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemLte(value)
	}
	pub fn gt(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemGt(value)
	}
	pub fn gte(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemGte(value)
	}
	pub fn contains(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemContains(value)
	}
	pub fn starts_with(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemEndsWith(value)
	}
	pub fn not(&self, value: String) -> LocationWhereParam {
		LocationWhereParam::FilesystemNot(value)
	}
}
pub struct LocationSetFilesystem(String);
impl From<LocationSetFilesystem> for LocationSetParam {
	fn from(value: LocationSetFilesystem) -> Self {
		Self::SetFilesystem(value.0)
	}
}
pub struct LocationDiskTypeField {}
impl LocationDiskTypeField {
	pub fn set<T: From<LocationSetDiskType>>(&self, value: i32) -> T {
		LocationSetDiskType(value).into()
	}
	pub fn equals(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::DiskTypeEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::DiskType(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LocationCursor {
		LocationCursor::DiskType(cursor)
	}
	pub fn increment(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetDiskType(value)
	}
	pub fn decrement(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetDiskType(value)
	}
	pub fn multiply(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetDiskType(value)
	}
	pub fn divide(&self, value: i32) -> LocationSetParam {
		LocationSetParam::SetDiskType(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LocationWhereParam {
		LocationWhereParam::DiskTypeInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LocationWhereParam {
		LocationWhereParam::DiskTypeNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::DiskTypeLt(value)
	}
	pub fn lte(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::DiskTypeLte(value)
	}
	pub fn gt(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::DiskTypeGt(value)
	}
	pub fn gte(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::DiskTypeGte(value)
	}
	pub fn not(&self, value: i32) -> LocationWhereParam {
		LocationWhereParam::DiskTypeNot(value)
	}
}
pub struct LocationSetDiskType(i32);
impl From<LocationSetDiskType> for LocationSetParam {
	fn from(value: LocationSetDiskType) -> Self {
		Self::SetDiskType(value.0)
	}
}
pub struct LocationIsRemovableField {}
impl LocationIsRemovableField {
	pub fn set<T: From<LocationSetIsRemovable>>(&self, value: bool) -> T {
		LocationSetIsRemovable(value).into()
	}
	pub fn equals(&self, value: bool) -> LocationWhereParam {
		LocationWhereParam::IsRemovableEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::IsRemovable(direction)
	}
	pub fn cursor(&self, cursor: bool) -> LocationCursor {
		LocationCursor::IsRemovable(cursor)
	}
}
pub struct LocationSetIsRemovable(bool);
impl From<LocationSetIsRemovable> for LocationSetParam {
	fn from(value: LocationSetIsRemovable) -> Self {
		Self::SetIsRemovable(value.0)
	}
}
pub struct LocationIsEjectableField {}
impl LocationIsEjectableField {
	pub fn set<T: From<LocationSetIsEjectable>>(&self, value: bool) -> T {
		LocationSetIsEjectable(value).into()
	}
	pub fn equals(&self, value: bool) -> LocationWhereParam {
		LocationWhereParam::IsEjectableEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::IsEjectable(direction)
	}
	pub fn cursor(&self, cursor: bool) -> LocationCursor {
		LocationCursor::IsEjectable(cursor)
	}
}
pub struct LocationSetIsEjectable(bool);
impl From<LocationSetIsEjectable> for LocationSetParam {
	fn from(value: LocationSetIsEjectable) -> Self {
		Self::SetIsEjectable(value.0)
	}
}
pub struct LocationIsRootFilesystemField {}
impl LocationIsRootFilesystemField {
	pub fn set<T: From<LocationSetIsRootFilesystem>>(&self, value: bool) -> T {
		LocationSetIsRootFilesystem(value).into()
	}
	pub fn equals(&self, value: bool) -> LocationWhereParam {
		LocationWhereParam::IsRootFilesystemEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::IsRootFilesystem(direction)
	}
	pub fn cursor(&self, cursor: bool) -> LocationCursor {
		LocationCursor::IsRootFilesystem(cursor)
	}
}
pub struct LocationSetIsRootFilesystem(bool);
impl From<LocationSetIsRootFilesystem> for LocationSetParam {
	fn from(value: LocationSetIsRootFilesystem) -> Self {
		Self::SetIsRootFilesystem(value.0)
	}
}
pub struct LocationIsOnlineField {}
impl LocationIsOnlineField {
	pub fn set<T: From<LocationSetIsOnline>>(&self, value: bool) -> T {
		LocationSetIsOnline(value).into()
	}
	pub fn equals(&self, value: bool) -> LocationWhereParam {
		LocationWhereParam::IsOnlineEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::IsOnline(direction)
	}
	pub fn cursor(&self, cursor: bool) -> LocationCursor {
		LocationCursor::IsOnline(cursor)
	}
}
pub struct LocationSetIsOnline(bool);
impl From<LocationSetIsOnline> for LocationSetParam {
	fn from(value: LocationSetIsOnline) -> Self {
		Self::SetIsOnline(value.0)
	}
}
pub struct LocationDateCreatedField {}
impl LocationDateCreatedField {
	pub fn set<T: From<LocationSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		LocationSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
		LocationWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LocationOrderByParam {
		LocationOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> LocationCursor {
		LocationCursor::DateCreated(cursor)
	}
	pub fn in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> LocationWhereParam {
		LocationWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> LocationWhereParam {
		LocationWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
		LocationWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
		LocationWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
		LocationWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
		LocationWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> LocationWhereParam {
		LocationWhereParam::DateCreatedNot(value)
	}
}
pub struct LocationSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<LocationSetDateCreated> for LocationSetParam {
	fn from(value: LocationSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct LocationFilePathsField {}
impl LocationFilePathsField {
	pub fn some(&self, value: Vec<FilePathWhereParam>) -> LocationWhereParam {
		LocationWhereParam::FilePathsSome(value)
	}
	pub fn every(&self, value: Vec<FilePathWhereParam>) -> LocationWhereParam {
		LocationWhereParam::FilePathsEvery(value)
	}
	pub fn fetch(&self, params: Vec<FilePathWhereParam>) -> LocationWithParam {
		LocationWithParam::FilePaths(params)
	}
	pub fn link<T: From<LocationLinkFilePaths>>(
		&self,
		params: Vec<FilePathWhereUniqueParam>,
	) -> T {
		LocationLinkFilePaths(params).into()
	}
	pub fn unlink(&self, params: Vec<FilePathWhereUniqueParam>) -> LocationSetParam {
		LocationSetParam::UnLinkFilePaths(params)
	}
}
pub struct LocationLinkFilePaths(Vec<FilePathWhereUniqueParam>);
impl From<LocationLinkFilePaths> for LocationSetParam {
	fn from(value: LocationLinkFilePaths) -> Self {
		Self::LinkFilePaths(value.0)
	}
}
pub enum LocationWithParam {
	FilePaths(Vec<FilePathWhereParam>),
}
impl LocationWithParam {
	pub fn to_output(self) -> Output {
		match self {
			Self::FilePaths(where_params) => Output {
				name: "file_paths".into(),
				outputs: file_path_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params
							.into_iter()
							.map(|param| {
								Into::<FilePathWhereParam>::into(param).to_field()
							})
							.collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
		}
	}
}
pub enum LocationSetParam {
	SetId(i32),
	SetName(String),
	SetLocalPath(String),
	SetTotalCapacity(i32),
	SetAvailableCapacity(i32),
	SetFilesystem(String),
	SetDiskType(i32),
	SetIsRemovable(bool),
	SetIsEjectable(bool),
	SetIsRootFilesystem(bool),
	SetIsOnline(bool),
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	LinkFilePaths(Vec<FilePathWhereUniqueParam>),
	UnLinkFilePaths(Vec<FilePathWhereUniqueParam>),
}
impl LocationSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetName(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetLocalPath(value) => Field {
				name: "local_path".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetTotalCapacity(value) => Field {
				name: "total_capacity".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetAvailableCapacity(value) => Field {
				name: "available_capacity".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetFilesystem(value) => Field {
				name: "filesystem".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDiskType(value) => Field {
				name: "disk_type".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetIsRemovable(value) => Field {
				name: "is_removable".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetIsEjectable(value) => Field {
				name: "is_ejectable".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetIsRootFilesystem(value) => Field {
				name: "is_root_filesystem".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetIsOnline(value) => Field {
				name: "is_online".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFilePaths(where_params) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<FilePathWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkFilePaths(where_params) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<FilePathWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum LocationOrderByParam {
	Id(Direction),
	Name(Direction),
	LocalPath(Direction),
	TotalCapacity(Direction),
	AvailableCapacity(Direction),
	Filesystem(Direction),
	DiskType(Direction),
	IsRemovable(Direction),
	IsEjectable(Direction),
	IsRootFilesystem(Direction),
	IsOnline(Direction),
	DateCreated(Direction),
}
impl LocationOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Name(direction) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::LocalPath(direction) => Field {
				name: "local_path".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::TotalCapacity(direction) => Field {
				name: "total_capacity".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::AvailableCapacity(direction) => Field {
				name: "available_capacity".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Filesystem(direction) => Field {
				name: "filesystem".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DiskType(direction) => Field {
				name: "disk_type".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::IsRemovable(direction) => Field {
				name: "is_removable".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::IsEjectable(direction) => Field {
				name: "is_ejectable".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::IsRootFilesystem(direction) => Field {
				name: "is_root_filesystem".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::IsOnline(direction) => Field {
				name: "is_online".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum LocationCursor {
	Id(i32),
	Name(String),
	LocalPath(String),
	TotalCapacity(i32),
	AvailableCapacity(i32),
	Filesystem(String),
	DiskType(i32),
	IsRemovable(bool),
	IsEjectable(bool),
	IsRootFilesystem(bool),
	IsOnline(bool),
	DateCreated(chrono::DateTime<chrono::Utc>),
}
impl LocationCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LocalPath(value) => Field {
				name: "local_path".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalCapacity(value) => Field {
				name: "total_capacity".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::AvailableCapacity(value) => Field {
				name: "available_capacity".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Filesystem(value) => Field {
				name: "filesystem".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DiskType(value) => Field {
				name: "disk_type".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsRemovable(value) => Field {
				name: "is_removable".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsEjectable(value) => Field {
				name: "is_ejectable".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsRootFilesystem(value) => Field {
				name: "is_root_filesystem".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsOnline(value) => Field {
				name: "is_online".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum LocationWhereParam {
	Not(Vec<LocationWhereParam>),
	Or(Vec<LocationWhereParam>),
	And(Vec<LocationWhereParam>),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	NameEquals(String),
	NameInVec(Vec<String>),
	NameNotInVec(Vec<String>),
	NameLt(String),
	NameLte(String),
	NameGt(String),
	NameGte(String),
	NameContains(String),
	NameStartsWith(String),
	NameEndsWith(String),
	NameNot(String),
	LocalPathEquals(String),
	LocalPathInVec(Vec<String>),
	LocalPathNotInVec(Vec<String>),
	LocalPathLt(String),
	LocalPathLte(String),
	LocalPathGt(String),
	LocalPathGte(String),
	LocalPathContains(String),
	LocalPathStartsWith(String),
	LocalPathEndsWith(String),
	LocalPathNot(String),
	TotalCapacityEquals(i32),
	TotalCapacityInVec(Vec<i32>),
	TotalCapacityNotInVec(Vec<i32>),
	TotalCapacityLt(i32),
	TotalCapacityLte(i32),
	TotalCapacityGt(i32),
	TotalCapacityGte(i32),
	TotalCapacityNot(i32),
	AvailableCapacityEquals(i32),
	AvailableCapacityInVec(Vec<i32>),
	AvailableCapacityNotInVec(Vec<i32>),
	AvailableCapacityLt(i32),
	AvailableCapacityLte(i32),
	AvailableCapacityGt(i32),
	AvailableCapacityGte(i32),
	AvailableCapacityNot(i32),
	FilesystemEquals(String),
	FilesystemInVec(Vec<String>),
	FilesystemNotInVec(Vec<String>),
	FilesystemLt(String),
	FilesystemLte(String),
	FilesystemGt(String),
	FilesystemGte(String),
	FilesystemContains(String),
	FilesystemStartsWith(String),
	FilesystemEndsWith(String),
	FilesystemNot(String),
	DiskTypeEquals(i32),
	DiskTypeInVec(Vec<i32>),
	DiskTypeNotInVec(Vec<i32>),
	DiskTypeLt(i32),
	DiskTypeLte(i32),
	DiskTypeGt(i32),
	DiskTypeGte(i32),
	DiskTypeNot(i32),
	IsRemovableEquals(bool),
	IsEjectableEquals(bool),
	IsRootFilesystemEquals(bool),
	IsOnlineEquals(bool),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	FilePathsSome(Vec<FilePathWhereParam>),
	FilePathsEvery(Vec<FilePathWhereParam>),
}
impl LocationWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNotInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameStartsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEndsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNot(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathEquals(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathInVec(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathNotInVec(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathLt(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathLte(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathGt(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathGte(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathContains(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathStartsWith(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathEndsWith(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocalPathNot(value) => Field {
				name: "local_path".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityEquals(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityInVec(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityNotInVec(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityLt(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityLte(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityGt(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityGte(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalCapacityNot(value) => Field {
				name: "total_capacity".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityEquals(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityInVec(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityNotInVec(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityLt(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityLte(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityGt(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityGte(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::AvailableCapacityNot(value) => Field {
				name: "available_capacity".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemEquals(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemInVec(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemNotInVec(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemLt(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemLte(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemGt(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemGte(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemContains(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemStartsWith(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemEndsWith(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilesystemNot(value) => Field {
				name: "filesystem".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeEquals(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeInVec(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeNotInVec(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeLt(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeLte(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeGt(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeGte(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DiskTypeNot(value) => Field {
				name: "disk_type".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsRemovableEquals(value) => Field {
				name: "is_removable".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsEjectableEquals(value) => Field {
				name: "is_ejectable".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsRootFilesystemEquals(value) => Field {
				name: "is_root_filesystem".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsOnlineEquals(value) => Field {
				name: "is_online".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilePathsSome(value) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "some".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilePathsEvery(value) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "every".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum LocationWhereUniqueParam {
	IdEquals(i32),
}
impl From<LocationWhereUniqueParam> for LocationWhereParam {
	fn from(value: LocationWhereUniqueParam) -> Self {
		match value {
			LocationWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
		}
	}
}
impl From<Operator<Self>> for LocationWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct LocationFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<LocationOrderByParam>,
	with_params: Vec<LocationWithParam>,
}
impl<'a> LocationFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<LocationData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> LocationDelete<'a> {
		LocationDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Location".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LocationSetParam>) -> LocationUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LocationUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: LocationOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: LocationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: LocationCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct LocationFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<LocationOrderByParam>,
	with_params: Vec<LocationWithParam>,
}
impl<'a> LocationFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<LocationData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: LocationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: LocationOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: LocationCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct LocationFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<LocationWithParam>,
}
impl<'a> LocationFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<LocationData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> LocationDelete<'a> {
		LocationDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Location".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LocationSetParam>) -> LocationUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LocationUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: LocationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LocationCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<LocationWithParam>,
}
impl<'a> LocationCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<LocationData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: LocationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LocationUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<LocationWithParam>,
}
impl<'a> LocationUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<LocationData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: LocationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LocationUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<LocationWithParam>,
}
impl<'a> LocationUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<LocationData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: LocationWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LocationUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> LocationUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<LocationData> {
		self.query.perform().await
	}
	pub fn create(mut self, params: Vec<LocationSetParam>) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<LocationSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct LocationDelete<'a> {
	query: Query<'a>,
}
impl<'a> LocationDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct LocationActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> LocationActions<'a> {
	pub fn find_unique(&self, param: LocationWhereUniqueParam) -> LocationFindUnique {
		let param: LocationWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Location".into(),
			outputs: location_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LocationFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<LocationWhereParam>) -> LocationFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Location".into(),
			outputs: location_outputs(),
			inputs,
		};
		LocationFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<LocationWhereParam>) -> LocationFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Location".into(),
			outputs: location_outputs(),
			inputs,
		};
		LocationFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(&self, params: Vec<LocationSetParam>) -> LocationCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Location".into(),
			outputs: location_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		LocationCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: LocationWhereUniqueParam) -> LocationUpsertOne {
		let param: LocationWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "Location".into(),
			outputs: location_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LocationUpsertOne { query }
	}
}
fn file_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("kind"),
		Output::new("size_in_bytes"),
		Output::new("partial_checksum"),
		Output::new("checksum"),
		Output::new("encryption"),
		Output::new("ipfs_id"),
		Output::new("date_created"),
		Output::new("date_modified"),
		Output::new("date_indexed"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "kind")]
	pub kind: i32,
	#[serde(rename = "size_in_bytes")]
	pub size_in_bytes: String,
	#[serde(rename = "partial_checksum")]
	pub partial_checksum: String,
	#[serde(rename = "checksum")]
	pub checksum: Option<String>,
	#[serde(rename = "encryption")]
	pub encryption: i32,
	#[serde(rename = "ipfs_id")]
	pub ipfs_id: Option<String>,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_indexed")]
	pub date_indexed: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "file_tags")]
	file_tags: Option<Vec<TagOnFileData>>,
	#[serde(rename = "file_labels")]
	file_labels: Option<Vec<LabelOnFileData>>,
	#[serde(rename = "file_paths")]
	file_paths: Option<Vec<FilePathData>>,
	#[serde(rename = "comments")]
	comments: Option<Vec<CommentData>>,
}
impl FileData {
	pub fn file_tags(&self) -> Result<&Vec<TagOnFileData>, String> {
		match self . file_tags . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access file_tags but did not fetch it using the .with() syntax" . to_string ()) , }
	}
	pub fn file_labels(&self) -> Result<&Vec<LabelOnFileData>, String> {
		match self . file_labels . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access file_labels but did not fetch it using the .with() syntax" . to_string ()) , }
	}
	pub fn file_paths(&self) -> Result<&Vec<FilePathData>, String> {
		match self . file_paths . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access file_paths but did not fetch it using the .with() syntax" . to_string ()) , }
	}
	pub fn comments(&self) -> Result<&Vec<CommentData>, String> {
		match self . comments . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access comments but did not fetch it using the .with() syntax" . to_string ()) , }
	}
}
pub struct File;
impl File {
	pub fn id() -> FileIdField {
		FileIdField {}
	}
	pub fn kind() -> FileKindField {
		FileKindField {}
	}
	pub fn size_in_bytes() -> FileSizeInBytesField {
		FileSizeInBytesField {}
	}
	pub fn partial_checksum() -> FilePartialChecksumField {
		FilePartialChecksumField {}
	}
	pub fn checksum() -> FileChecksumField {
		FileChecksumField {}
	}
	pub fn encryption() -> FileEncryptionField {
		FileEncryptionField {}
	}
	pub fn ipfs_id() -> FileIpfsIdField {
		FileIpfsIdField {}
	}
	pub fn date_created() -> FileDateCreatedField {
		FileDateCreatedField {}
	}
	pub fn date_modified() -> FileDateModifiedField {
		FileDateModifiedField {}
	}
	pub fn date_indexed() -> FileDateIndexedField {
		FileDateIndexedField {}
	}
	pub fn file_tags() -> FileFileTagsField {
		FileFileTagsField {}
	}
	pub fn file_labels() -> FileFileLabelsField {
		FileFileLabelsField {}
	}
	pub fn file_paths() -> FileFilePathsField {
		FileFilePathsField {}
	}
	pub fn comments() -> FileCommentsField {
		FileCommentsField {}
	}
}
pub struct FileIdField {}
impl FileIdField {
	pub fn set<T: From<FileSetId>>(&self, value: i32) -> T {
		FileSetId(value).into()
	}
	pub fn equals<T: From<FileWhereUniqueParam>>(&self, value: i32) -> T {
		FileWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FileOrderByParam {
		FileOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> FileCursor {
		FileCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> FileSetParam {
		FileSetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> FileSetParam {
		FileSetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> FileSetParam {
		FileSetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> FileSetParam {
		FileSetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> FileWhereParam {
		FileWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> FileWhereParam {
		FileWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> FileWhereParam {
		FileWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> FileWhereParam {
		FileWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> FileWhereParam {
		FileWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> FileWhereParam {
		FileWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> FileWhereParam {
		FileWhereParam::IdNot(value)
	}
}
pub struct FileSetId(i32);
impl From<FileSetId> for FileSetParam {
	fn from(value: FileSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct FileKindField {}
impl FileKindField {
	pub fn set<T: From<FileSetKind>>(&self, value: i32) -> T {
		FileSetKind(value).into()
	}
	pub fn equals(&self, value: i32) -> FileWhereParam {
		FileWhereParam::KindEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FileOrderByParam {
		FileOrderByParam::Kind(direction)
	}
	pub fn cursor(&self, cursor: i32) -> FileCursor {
		FileCursor::Kind(cursor)
	}
	pub fn increment(&self, value: i32) -> FileSetParam {
		FileSetParam::SetKind(value)
	}
	pub fn decrement(&self, value: i32) -> FileSetParam {
		FileSetParam::SetKind(value)
	}
	pub fn multiply(&self, value: i32) -> FileSetParam {
		FileSetParam::SetKind(value)
	}
	pub fn divide(&self, value: i32) -> FileSetParam {
		FileSetParam::SetKind(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> FileWhereParam {
		FileWhereParam::KindInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> FileWhereParam {
		FileWhereParam::KindNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> FileWhereParam {
		FileWhereParam::KindLt(value)
	}
	pub fn lte(&self, value: i32) -> FileWhereParam {
		FileWhereParam::KindLte(value)
	}
	pub fn gt(&self, value: i32) -> FileWhereParam {
		FileWhereParam::KindGt(value)
	}
	pub fn gte(&self, value: i32) -> FileWhereParam {
		FileWhereParam::KindGte(value)
	}
	pub fn not(&self, value: i32) -> FileWhereParam {
		FileWhereParam::KindNot(value)
	}
}
pub struct FileSetKind(i32);
impl From<FileSetKind> for FileSetParam {
	fn from(value: FileSetKind) -> Self {
		Self::SetKind(value.0)
	}
}
pub struct FileSizeInBytesField {}
impl FileSizeInBytesField {
	pub fn set<T: From<FileSetSizeInBytes>>(&self, value: String) -> T {
		FileSetSizeInBytes(value).into()
	}
	pub fn equals(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FileOrderByParam {
		FileOrderByParam::SizeInBytes(direction)
	}
	pub fn cursor(&self, cursor: String) -> FileCursor {
		FileCursor::SizeInBytes(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> FileWhereParam {
		FileWhereParam::SizeInBytesInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> FileWhereParam {
		FileWhereParam::SizeInBytesNotInVec(value)
	}
	pub fn lt(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesLt(value)
	}
	pub fn lte(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesLte(value)
	}
	pub fn gt(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesGt(value)
	}
	pub fn gte(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesGte(value)
	}
	pub fn contains(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesContains(value)
	}
	pub fn starts_with(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesEndsWith(value)
	}
	pub fn not(&self, value: String) -> FileWhereParam {
		FileWhereParam::SizeInBytesNot(value)
	}
}
pub struct FileSetSizeInBytes(String);
impl From<FileSetSizeInBytes> for FileSetParam {
	fn from(value: FileSetSizeInBytes) -> Self {
		Self::SetSizeInBytes(value.0)
	}
}
pub struct FilePartialChecksumField {}
impl FilePartialChecksumField {
	pub fn set<T: From<FileSetPartialChecksum>>(&self, value: String) -> T {
		FileSetPartialChecksum(value).into()
	}
	pub fn equals(&self, value: String) -> FileWhereParam {
		FileWhereParam::PartialChecksumEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FileOrderByParam {
		FileOrderByParam::PartialChecksum(direction)
	}
	pub fn cursor(&self, cursor: String) -> FileCursor {
		FileCursor::PartialChecksum(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> FileWhereParam {
		FileWhereParam::PartialChecksumInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> FileWhereParam {
		FileWhereParam::PartialChecksumNotInVec(value)
	}
	pub fn lt(&self, value: String) -> FileWhereParam {
		FileWhereParam::PartialChecksumLt(value)
	}
	pub fn lte(&self, value: String) -> FileWhereParam {
		FileWhereParam::PartialChecksumLte(value)
	}
	pub fn gt(&self, value: String) -> FileWhereParam {
		FileWhereParam::PartialChecksumGt(value)
	}
	pub fn gte(&self, value: String) -> FileWhereParam {
		FileWhereParam::PartialChecksumGte(value)
	}
	pub fn contains(&self, value: String) -> FileWhereParam {
		FileWhereParam::PartialChecksumContains(value)
	}
	pub fn starts_with(&self, value: String) -> FileWhereParam {
		FileWhereParam::PartialChecksumStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> FileWhereParam {
		FileWhereParam::PartialChecksumEndsWith(value)
	}
	pub fn not(&self, value: String) -> FileWhereParam {
		FileWhereParam::PartialChecksumNot(value)
	}
}
pub struct FileSetPartialChecksum(String);
impl From<FileSetPartialChecksum> for FileSetParam {
	fn from(value: FileSetPartialChecksum) -> Self {
		Self::SetPartialChecksum(value.0)
	}
}
pub struct FileChecksumField {}
impl FileChecksumField {
	pub fn set<T: From<FileSetChecksum>>(&self, value: String) -> T {
		FileSetChecksum(value).into()
	}
	pub fn equals<T: From<FileWhereUniqueParam>>(&self, value: String) -> T {
		FileWhereUniqueParam::ChecksumEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FileOrderByParam {
		FileOrderByParam::Checksum(direction)
	}
	pub fn cursor(&self, cursor: String) -> FileCursor {
		FileCursor::Checksum(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> FileWhereParam {
		FileWhereParam::ChecksumInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> FileWhereParam {
		FileWhereParam::ChecksumNotInVec(value)
	}
	pub fn lt(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumLt(value)
	}
	pub fn lte(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumLte(value)
	}
	pub fn gt(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumGt(value)
	}
	pub fn gte(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumGte(value)
	}
	pub fn contains(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumContains(value)
	}
	pub fn starts_with(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumEndsWith(value)
	}
	pub fn not(&self, value: String) -> FileWhereParam {
		FileWhereParam::ChecksumNot(value)
	}
}
pub struct FileSetChecksum(String);
impl From<FileSetChecksum> for FileSetParam {
	fn from(value: FileSetChecksum) -> Self {
		Self::SetChecksum(value.0)
	}
}
pub struct FileEncryptionField {}
impl FileEncryptionField {
	pub fn set<T: From<FileSetEncryption>>(&self, value: i32) -> T {
		FileSetEncryption(value).into()
	}
	pub fn equals(&self, value: i32) -> FileWhereParam {
		FileWhereParam::EncryptionEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FileOrderByParam {
		FileOrderByParam::Encryption(direction)
	}
	pub fn cursor(&self, cursor: i32) -> FileCursor {
		FileCursor::Encryption(cursor)
	}
	pub fn increment(&self, value: i32) -> FileSetParam {
		FileSetParam::SetEncryption(value)
	}
	pub fn decrement(&self, value: i32) -> FileSetParam {
		FileSetParam::SetEncryption(value)
	}
	pub fn multiply(&self, value: i32) -> FileSetParam {
		FileSetParam::SetEncryption(value)
	}
	pub fn divide(&self, value: i32) -> FileSetParam {
		FileSetParam::SetEncryption(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> FileWhereParam {
		FileWhereParam::EncryptionInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> FileWhereParam {
		FileWhereParam::EncryptionNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> FileWhereParam {
		FileWhereParam::EncryptionLt(value)
	}
	pub fn lte(&self, value: i32) -> FileWhereParam {
		FileWhereParam::EncryptionLte(value)
	}
	pub fn gt(&self, value: i32) -> FileWhereParam {
		FileWhereParam::EncryptionGt(value)
	}
	pub fn gte(&self, value: i32) -> FileWhereParam {
		FileWhereParam::EncryptionGte(value)
	}
	pub fn not(&self, value: i32) -> FileWhereParam {
		FileWhereParam::EncryptionNot(value)
	}
}
pub struct FileSetEncryption(i32);
impl From<FileSetEncryption> for FileSetParam {
	fn from(value: FileSetEncryption) -> Self {
		Self::SetEncryption(value.0)
	}
}
pub struct FileIpfsIdField {}
impl FileIpfsIdField {
	pub fn set<T: From<FileSetIpfsId>>(&self, value: String) -> T {
		FileSetIpfsId(value).into()
	}
	pub fn equals(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FileOrderByParam {
		FileOrderByParam::IpfsId(direction)
	}
	pub fn cursor(&self, cursor: String) -> FileCursor {
		FileCursor::IpfsId(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> FileWhereParam {
		FileWhereParam::IpfsIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> FileWhereParam {
		FileWhereParam::IpfsIdNotInVec(value)
	}
	pub fn lt(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdLt(value)
	}
	pub fn lte(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdLte(value)
	}
	pub fn gt(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdGt(value)
	}
	pub fn gte(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdGte(value)
	}
	pub fn contains(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdContains(value)
	}
	pub fn starts_with(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdEndsWith(value)
	}
	pub fn not(&self, value: String) -> FileWhereParam {
		FileWhereParam::IpfsIdNot(value)
	}
}
pub struct FileSetIpfsId(String);
impl From<FileSetIpfsId> for FileSetParam {
	fn from(value: FileSetIpfsId) -> Self {
		Self::SetIpfsId(value.0)
	}
}
pub struct FileDateCreatedField {}
impl FileDateCreatedField {
	pub fn set<T: From<FileSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		FileSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FileOrderByParam {
		FileOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> FileCursor {
		FileCursor::DateCreated(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> FileWhereParam {
		FileWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> FileWhereParam {
		FileWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateCreatedNot(value)
	}
}
pub struct FileSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<FileSetDateCreated> for FileSetParam {
	fn from(value: FileSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct FileDateModifiedField {}
impl FileDateModifiedField {
	pub fn set<T: From<FileSetDateModified>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		FileSetDateModified(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateModifiedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FileOrderByParam {
		FileOrderByParam::DateModified(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> FileCursor {
		FileCursor::DateModified(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> FileWhereParam {
		FileWhereParam::DateModifiedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> FileWhereParam {
		FileWhereParam::DateModifiedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateModifiedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateModifiedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateModifiedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateModifiedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateModifiedNot(value)
	}
}
pub struct FileSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<FileSetDateModified> for FileSetParam {
	fn from(value: FileSetDateModified) -> Self {
		Self::SetDateModified(value.0)
	}
}
pub struct FileDateIndexedField {}
impl FileDateIndexedField {
	pub fn set<T: From<FileSetDateIndexed>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		FileSetDateIndexed(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateIndexedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FileOrderByParam {
		FileOrderByParam::DateIndexed(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> FileCursor {
		FileCursor::DateIndexed(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> FileWhereParam {
		FileWhereParam::DateIndexedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> FileWhereParam {
		FileWhereParam::DateIndexedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateIndexedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateIndexedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateIndexedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateIndexedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> FileWhereParam {
		FileWhereParam::DateIndexedNot(value)
	}
}
pub struct FileSetDateIndexed(chrono::DateTime<chrono::Utc>);
impl From<FileSetDateIndexed> for FileSetParam {
	fn from(value: FileSetDateIndexed) -> Self {
		Self::SetDateIndexed(value.0)
	}
}
pub struct FileFileTagsField {}
impl FileFileTagsField {
	pub fn some(&self, value: Vec<TagOnFileWhereParam>) -> FileWhereParam {
		FileWhereParam::FileTagsSome(value)
	}
	pub fn every(&self, value: Vec<TagOnFileWhereParam>) -> FileWhereParam {
		FileWhereParam::FileTagsEvery(value)
	}
	pub fn fetch(&self, params: Vec<TagOnFileWhereParam>) -> FileWithParam {
		FileWithParam::FileTags(params)
	}
	pub fn link<T: From<FileLinkFileTags>>(
		&self,
		params: Vec<TagOnFileWhereUniqueParam>,
	) -> T {
		FileLinkFileTags(params).into()
	}
	pub fn unlink(&self, params: Vec<TagOnFileWhereUniqueParam>) -> FileSetParam {
		FileSetParam::UnLinkFileTags(params)
	}
}
pub struct FileLinkFileTags(Vec<TagOnFileWhereUniqueParam>);
impl From<FileLinkFileTags> for FileSetParam {
	fn from(value: FileLinkFileTags) -> Self {
		Self::LinkFileTags(value.0)
	}
}
pub struct FileFileLabelsField {}
impl FileFileLabelsField {
	pub fn some(&self, value: Vec<LabelOnFileWhereParam>) -> FileWhereParam {
		FileWhereParam::FileLabelsSome(value)
	}
	pub fn every(&self, value: Vec<LabelOnFileWhereParam>) -> FileWhereParam {
		FileWhereParam::FileLabelsEvery(value)
	}
	pub fn fetch(&self, params: Vec<LabelOnFileWhereParam>) -> FileWithParam {
		FileWithParam::FileLabels(params)
	}
	pub fn link<T: From<FileLinkFileLabels>>(
		&self,
		params: Vec<LabelOnFileWhereUniqueParam>,
	) -> T {
		FileLinkFileLabels(params).into()
	}
	pub fn unlink(&self, params: Vec<LabelOnFileWhereUniqueParam>) -> FileSetParam {
		FileSetParam::UnLinkFileLabels(params)
	}
}
pub struct FileLinkFileLabels(Vec<LabelOnFileWhereUniqueParam>);
impl From<FileLinkFileLabels> for FileSetParam {
	fn from(value: FileLinkFileLabels) -> Self {
		Self::LinkFileLabels(value.0)
	}
}
pub struct FileFilePathsField {}
impl FileFilePathsField {
	pub fn some(&self, value: Vec<FilePathWhereParam>) -> FileWhereParam {
		FileWhereParam::FilePathsSome(value)
	}
	pub fn every(&self, value: Vec<FilePathWhereParam>) -> FileWhereParam {
		FileWhereParam::FilePathsEvery(value)
	}
	pub fn fetch(&self, params: Vec<FilePathWhereParam>) -> FileWithParam {
		FileWithParam::FilePaths(params)
	}
	pub fn link<T: From<FileLinkFilePaths>>(
		&self,
		params: Vec<FilePathWhereUniqueParam>,
	) -> T {
		FileLinkFilePaths(params).into()
	}
	pub fn unlink(&self, params: Vec<FilePathWhereUniqueParam>) -> FileSetParam {
		FileSetParam::UnLinkFilePaths(params)
	}
}
pub struct FileLinkFilePaths(Vec<FilePathWhereUniqueParam>);
impl From<FileLinkFilePaths> for FileSetParam {
	fn from(value: FileLinkFilePaths) -> Self {
		Self::LinkFilePaths(value.0)
	}
}
pub struct FileCommentsField {}
impl FileCommentsField {
	pub fn some(&self, value: Vec<CommentWhereParam>) -> FileWhereParam {
		FileWhereParam::CommentsSome(value)
	}
	pub fn every(&self, value: Vec<CommentWhereParam>) -> FileWhereParam {
		FileWhereParam::CommentsEvery(value)
	}
	pub fn fetch(&self, params: Vec<CommentWhereParam>) -> FileWithParam {
		FileWithParam::Comments(params)
	}
	pub fn link<T: From<FileLinkComments>>(
		&self,
		params: Vec<CommentWhereUniqueParam>,
	) -> T {
		FileLinkComments(params).into()
	}
	pub fn unlink(&self, params: Vec<CommentWhereUniqueParam>) -> FileSetParam {
		FileSetParam::UnLinkComments(params)
	}
}
pub struct FileLinkComments(Vec<CommentWhereUniqueParam>);
impl From<FileLinkComments> for FileSetParam {
	fn from(value: FileLinkComments) -> Self {
		Self::LinkComments(value.0)
	}
}
pub enum FileWithParam {
	FileTags(Vec<TagOnFileWhereParam>),
	FileLabels(Vec<LabelOnFileWhereParam>),
	FilePaths(Vec<FilePathWhereParam>),
	Comments(Vec<CommentWhereParam>),
}
impl FileWithParam {
	pub fn to_output(self) -> Output {
		match self {
			Self::FileTags(where_params) => Output {
				name: "file_tags".into(),
				outputs: tag_on_file_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params
							.into_iter()
							.map(|param| {
								Into::<TagOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
			Self::FileLabels(where_params) => Output {
				name: "file_labels".into(),
				outputs: label_on_file_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params
							.into_iter()
							.map(|param| {
								Into::<LabelOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
			Self::FilePaths(where_params) => Output {
				name: "file_paths".into(),
				outputs: file_path_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params
							.into_iter()
							.map(|param| {
								Into::<FilePathWhereParam>::into(param).to_field()
							})
							.collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
			Self::Comments(where_params) => Output {
				name: "comments".into(),
				outputs: comment_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params
							.into_iter()
							.map(|param| {
								Into::<CommentWhereParam>::into(param).to_field()
							})
							.collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
		}
	}
}
pub enum FileSetParam {
	SetId(i32),
	SetKind(i32),
	SetSizeInBytes(String),
	SetPartialChecksum(String),
	SetChecksum(String),
	SetEncryption(i32),
	SetIpfsId(String),
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	SetDateModified(chrono::DateTime<chrono::Utc>),
	SetDateIndexed(chrono::DateTime<chrono::Utc>),
	LinkFileTags(Vec<TagOnFileWhereUniqueParam>),
	UnLinkFileTags(Vec<TagOnFileWhereUniqueParam>),
	LinkFileLabels(Vec<LabelOnFileWhereUniqueParam>),
	UnLinkFileLabels(Vec<LabelOnFileWhereUniqueParam>),
	LinkFilePaths(Vec<FilePathWhereUniqueParam>),
	UnLinkFilePaths(Vec<FilePathWhereUniqueParam>),
	LinkComments(Vec<CommentWhereUniqueParam>),
	UnLinkComments(Vec<CommentWhereUniqueParam>),
}
impl FileSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetKind(value) => Field {
				name: "kind".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetSizeInBytes(value) => Field {
				name: "size_in_bytes".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetPartialChecksum(value) => Field {
				name: "partial_checksum".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetChecksum(value) => Field {
				name: "checksum".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetEncryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetIpfsId(value) => Field {
				name: "ipfs_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateIndexed(value) => Field {
				name: "date_indexed".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFileTags(where_params) => Field {
				name: "file_tags".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<TagOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkFileTags(where_params) => Field {
				name: "file_tags".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<TagOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LinkFileLabels(where_params) => Field {
				name: "file_labels".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<LabelOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkFileLabels(where_params) => Field {
				name: "file_labels".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<LabelOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LinkFilePaths(where_params) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<FilePathWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkFilePaths(where_params) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<FilePathWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LinkComments(where_params) => Field {
				name: "comments".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<CommentWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkComments(where_params) => Field {
				name: "comments".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<CommentWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum FileOrderByParam {
	Id(Direction),
	Kind(Direction),
	SizeInBytes(Direction),
	PartialChecksum(Direction),
	Checksum(Direction),
	Encryption(Direction),
	IpfsId(Direction),
	DateCreated(Direction),
	DateModified(Direction),
	DateIndexed(Direction),
}
impl FileOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Kind(direction) => Field {
				name: "kind".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::SizeInBytes(direction) => Field {
				name: "size_in_bytes".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::PartialChecksum(direction) => Field {
				name: "partial_checksum".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Checksum(direction) => Field {
				name: "checksum".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Encryption(direction) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::IpfsId(direction) => Field {
				name: "ipfs_id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateModified(direction) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateIndexed(direction) => Field {
				name: "date_indexed".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum FileCursor {
	Id(i32),
	Kind(i32),
	SizeInBytes(String),
	PartialChecksum(String),
	Checksum(String),
	Encryption(i32),
	IpfsId(String),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
	DateIndexed(chrono::DateTime<chrono::Utc>),
}
impl FileCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Kind(value) => Field {
				name: "kind".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SizeInBytes(value) => Field {
				name: "size_in_bytes".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::PartialChecksum(value) => Field {
				name: "partial_checksum".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Checksum(value) => Field {
				name: "checksum".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Encryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IpfsId(value) => Field {
				name: "ipfs_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateIndexed(value) => Field {
				name: "date_indexed".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum FileWhereParam {
	Not(Vec<FileWhereParam>),
	Or(Vec<FileWhereParam>),
	And(Vec<FileWhereParam>),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	KindEquals(i32),
	KindInVec(Vec<i32>),
	KindNotInVec(Vec<i32>),
	KindLt(i32),
	KindLte(i32),
	KindGt(i32),
	KindGte(i32),
	KindNot(i32),
	SizeInBytesEquals(String),
	SizeInBytesInVec(Vec<String>),
	SizeInBytesNotInVec(Vec<String>),
	SizeInBytesLt(String),
	SizeInBytesLte(String),
	SizeInBytesGt(String),
	SizeInBytesGte(String),
	SizeInBytesContains(String),
	SizeInBytesStartsWith(String),
	SizeInBytesEndsWith(String),
	SizeInBytesNot(String),
	PartialChecksumEquals(String),
	PartialChecksumInVec(Vec<String>),
	PartialChecksumNotInVec(Vec<String>),
	PartialChecksumLt(String),
	PartialChecksumLte(String),
	PartialChecksumGt(String),
	PartialChecksumGte(String),
	PartialChecksumContains(String),
	PartialChecksumStartsWith(String),
	PartialChecksumEndsWith(String),
	PartialChecksumNot(String),
	ChecksumEquals(String),
	ChecksumInVec(Vec<String>),
	ChecksumNotInVec(Vec<String>),
	ChecksumLt(String),
	ChecksumLte(String),
	ChecksumGt(String),
	ChecksumGte(String),
	ChecksumContains(String),
	ChecksumStartsWith(String),
	ChecksumEndsWith(String),
	ChecksumNot(String),
	EncryptionEquals(i32),
	EncryptionInVec(Vec<i32>),
	EncryptionNotInVec(Vec<i32>),
	EncryptionLt(i32),
	EncryptionLte(i32),
	EncryptionGt(i32),
	EncryptionGte(i32),
	EncryptionNot(i32),
	IpfsIdEquals(String),
	IpfsIdInVec(Vec<String>),
	IpfsIdNotInVec(Vec<String>),
	IpfsIdLt(String),
	IpfsIdLte(String),
	IpfsIdGt(String),
	IpfsIdGte(String),
	IpfsIdContains(String),
	IpfsIdStartsWith(String),
	IpfsIdEndsWith(String),
	IpfsIdNot(String),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedLt(chrono::DateTime<chrono::Utc>),
	DateModifiedLte(chrono::DateTime<chrono::Utc>),
	DateModifiedGt(chrono::DateTime<chrono::Utc>),
	DateModifiedGte(chrono::DateTime<chrono::Utc>),
	DateModifiedNot(chrono::DateTime<chrono::Utc>),
	DateIndexedEquals(chrono::DateTime<chrono::Utc>),
	DateIndexedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateIndexedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateIndexedLt(chrono::DateTime<chrono::Utc>),
	DateIndexedLte(chrono::DateTime<chrono::Utc>),
	DateIndexedGt(chrono::DateTime<chrono::Utc>),
	DateIndexedGte(chrono::DateTime<chrono::Utc>),
	DateIndexedNot(chrono::DateTime<chrono::Utc>),
	FileTagsSome(Vec<TagOnFileWhereParam>),
	FileTagsEvery(Vec<TagOnFileWhereParam>),
	FileLabelsSome(Vec<LabelOnFileWhereParam>),
	FileLabelsEvery(Vec<LabelOnFileWhereParam>),
	FilePathsSome(Vec<FilePathWhereParam>),
	FilePathsEvery(Vec<FilePathWhereParam>),
	CommentsSome(Vec<CommentWhereParam>),
	CommentsEvery(Vec<CommentWhereParam>),
}
impl FileWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::KindEquals(value) => Field {
				name: "kind".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::KindInVec(value) => Field {
				name: "kind".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::KindNotInVec(value) => Field {
				name: "kind".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::KindLt(value) => Field {
				name: "kind".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::KindLte(value) => Field {
				name: "kind".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::KindGt(value) => Field {
				name: "kind".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::KindGte(value) => Field {
				name: "kind".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::KindNot(value) => Field {
				name: "kind".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesEquals(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesInVec(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesNotInVec(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesLt(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesLte(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesGt(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesGte(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesContains(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesStartsWith(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesEndsWith(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SizeInBytesNot(value) => Field {
				name: "size_in_bytes".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PartialChecksumEquals(value) => Field {
				name: "partial_checksum".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PartialChecksumInVec(value) => Field {
				name: "partial_checksum".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PartialChecksumNotInVec(value) => Field {
				name: "partial_checksum".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PartialChecksumLt(value) => Field {
				name: "partial_checksum".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PartialChecksumLte(value) => Field {
				name: "partial_checksum".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PartialChecksumGt(value) => Field {
				name: "partial_checksum".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PartialChecksumGte(value) => Field {
				name: "partial_checksum".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PartialChecksumContains(value) => Field {
				name: "partial_checksum".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PartialChecksumStartsWith(value) => Field {
				name: "partial_checksum".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PartialChecksumEndsWith(value) => Field {
				name: "partial_checksum".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PartialChecksumNot(value) => Field {
				name: "partial_checksum".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumEquals(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumInVec(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumNotInVec(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumLt(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumLte(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumGt(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumGte(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumContains(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumStartsWith(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumEndsWith(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChecksumNot(value) => Field {
				name: "checksum".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionEquals(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionInVec(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionNotInVec(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLt(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLte(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGt(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGte(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionNot(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdEquals(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdInVec(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdNotInVec(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdLt(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdLte(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdGt(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdGte(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdContains(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdStartsWith(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdEndsWith(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IpfsIdNot(value) => Field {
				name: "ipfs_id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNotInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNot(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedEquals(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedInVec(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedNotInVec(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedLt(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedLte(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedGt(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedGte(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedNot(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileTagsSome(value) => Field {
				name: "file_tags".into(),
				fields: Some(vec![Field {
					name: "some".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileTagsEvery(value) => Field {
				name: "file_tags".into(),
				fields: Some(vec![Field {
					name: "every".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileLabelsSome(value) => Field {
				name: "file_labels".into(),
				fields: Some(vec![Field {
					name: "some".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileLabelsEvery(value) => Field {
				name: "file_labels".into(),
				fields: Some(vec![Field {
					name: "every".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilePathsSome(value) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "some".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FilePathsEvery(value) => Field {
				name: "file_paths".into(),
				fields: Some(vec![Field {
					name: "every".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CommentsSome(value) => Field {
				name: "comments".into(),
				fields: Some(vec![Field {
					name: "some".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CommentsEvery(value) => Field {
				name: "comments".into(),
				fields: Some(vec![Field {
					name: "every".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum FileWhereUniqueParam {
	IdEquals(i32),
	ChecksumEquals(String),
}
impl From<FileWhereUniqueParam> for FileWhereParam {
	fn from(value: FileWhereUniqueParam) -> Self {
		match value {
			FileWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
			FileWhereUniqueParam::ChecksumEquals(value) => Self::ChecksumEquals(value),
		}
	}
}
impl From<Operator<Self>> for FileWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct FileFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<FileOrderByParam>,
	with_params: Vec<FileWithParam>,
}
impl<'a> FileFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<FileData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> FileDelete<'a> {
		FileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "File".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<FileSetParam>) -> FileUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		FileUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: FileOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: FileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: FileCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct FileFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<FileOrderByParam>,
	with_params: Vec<FileWithParam>,
}
impl<'a> FileFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<FileData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: FileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: FileOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: FileCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct FileFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<FileWithParam>,
}
impl<'a> FileFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<FileData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> FileDelete<'a> {
		FileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "File".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<FileSetParam>) -> FileUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		FileUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: FileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct FileCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<FileWithParam>,
}
impl<'a> FileCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<FileData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: FileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct FileUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<FileWithParam>,
}
impl<'a> FileUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<FileData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: FileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct FileUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<FileWithParam>,
}
impl<'a> FileUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<FileData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: FileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct FileUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> FileUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<FileData> {
		self.query.perform().await
	}
	pub fn create(
		mut self,
		size_in_bytes: FileSetSizeInBytes,
		partial_checksum: FileSetPartialChecksum,
		params: Vec<FileSetParam>,
	) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(FileSetParam::from(size_in_bytes).to_field());
		input_fields.push(FileSetParam::from(partial_checksum).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<FileSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct FileDelete<'a> {
	query: Query<'a>,
}
impl<'a> FileDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct FileActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> FileActions<'a> {
	pub fn find_unique(&self, param: FileWhereUniqueParam) -> FileFindUnique {
		let param: FileWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "File".into(),
			outputs: file_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		FileFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<FileWhereParam>) -> FileFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "File".into(),
			outputs: file_outputs(),
			inputs,
		};
		FileFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<FileWhereParam>) -> FileFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "File".into(),
			outputs: file_outputs(),
			inputs,
		};
		FileFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		size_in_bytes: FileSetSizeInBytes,
		partial_checksum: FileSetPartialChecksum,
		params: Vec<FileSetParam>,
	) -> FileCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(FileSetParam::from(size_in_bytes).to_field());
		input_fields.push(FileSetParam::from(partial_checksum).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "File".into(),
			outputs: file_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		FileCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: FileWhereUniqueParam) -> FileUpsertOne {
		let param: FileWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "File".into(),
			outputs: file_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		FileUpsertOne { query }
	}
}
fn file_path_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("is_dir"),
		Output::new("location_id"),
		Output::new("materialized_path"),
		Output::new("name"),
		Output::new("extension"),
		Output::new("file_id"),
		Output::new("parent_id"),
		Output::new("encryption"),
		Output::new("permissions"),
		Output::new("date_created"),
		Output::new("date_modified"),
		Output::new("date_indexed"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FilePathData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "is_dir")]
	pub is_dir: bool,
	#[serde(rename = "location_id")]
	pub location_id: i32,
	#[serde(rename = "materialized_path")]
	pub materialized_path: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "extension")]
	pub extension: Option<String>,
	#[serde(rename = "file_id")]
	pub file_id: Option<i32>,
	#[serde(rename = "parent_id")]
	pub parent_id: Option<i32>,
	#[serde(rename = "encryption")]
	pub encryption: i32,
	#[serde(rename = "permissions")]
	pub permissions: Option<String>,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_indexed")]
	pub date_indexed: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "file")]
	file: Option<Box<FileData>>,
	#[serde(rename = "location")]
	location: Option<Box<LocationData>>,
	#[serde(rename = "parent")]
	parent: Option<Box<FilePathData>>,
	#[serde(rename = "children")]
	children: Option<Vec<FilePathData>>,
}
impl FilePathData {
	pub fn file(&self) -> Result<&FileData, String> {
		match self.file.as_ref() {
			Some(v) => Ok(v),
			None => Err(
				"Attempted to access file but did not fetch it using the .with() syntax"
					.to_string(),
			),
		}
	}
	pub fn location(&self) -> Result<&LocationData, String> {
		match self . location . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access location but did not fetch it using the .with() syntax" . to_string ()) , }
	}
	pub fn parent(&self) -> Result<&FilePathData, String> {
		match self . parent . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access parent but did not fetch it using the .with() syntax" . to_string ()) , }
	}
	pub fn children(&self) -> Result<&Vec<FilePathData>, String> {
		match self . children . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access children but did not fetch it using the .with() syntax" . to_string ()) , }
	}
}
pub struct FilePath;
impl FilePath {
	pub fn location_id_materialized_path_name_extension<
		T: From<FilePathWhereUniqueParam>,
	>(
		location_id: i32,
		materialized_path: String,
		name: String,
		extension: String,
	) -> T {
		FilePathWhereUniqueParam::LocationIdMaterializedPathNameExtensionEquals(
			location_id,
			materialized_path,
			name,
			extension,
		)
		.into()
	}
	pub fn id() -> FilePathIdField {
		FilePathIdField {}
	}
	pub fn is_dir() -> FilePathIsDirField {
		FilePathIsDirField {}
	}
	pub fn location_id() -> FilePathLocationIdField {
		FilePathLocationIdField {}
	}
	pub fn materialized_path() -> FilePathMaterializedPathField {
		FilePathMaterializedPathField {}
	}
	pub fn name() -> FilePathNameField {
		FilePathNameField {}
	}
	pub fn extension() -> FilePathExtensionField {
		FilePathExtensionField {}
	}
	pub fn file_id() -> FilePathFileIdField {
		FilePathFileIdField {}
	}
	pub fn parent_id() -> FilePathParentIdField {
		FilePathParentIdField {}
	}
	pub fn encryption() -> FilePathEncryptionField {
		FilePathEncryptionField {}
	}
	pub fn permissions() -> FilePathPermissionsField {
		FilePathPermissionsField {}
	}
	pub fn date_created() -> FilePathDateCreatedField {
		FilePathDateCreatedField {}
	}
	pub fn date_modified() -> FilePathDateModifiedField {
		FilePathDateModifiedField {}
	}
	pub fn date_indexed() -> FilePathDateIndexedField {
		FilePathDateIndexedField {}
	}
	pub fn file() -> FilePathFileField {
		FilePathFileField {}
	}
	pub fn location() -> FilePathLocationField {
		FilePathLocationField {}
	}
	pub fn parent() -> FilePathParentField {
		FilePathParentField {}
	}
	pub fn children() -> FilePathChildrenField {
		FilePathChildrenField {}
	}
}
pub struct FilePathIdField {}
impl FilePathIdField {
	pub fn set<T: From<FilePathSetId>>(&self, value: i32) -> T {
		FilePathSetId(value).into()
	}
	pub fn equals<T: From<FilePathWhereUniqueParam>>(&self, value: i32) -> T {
		FilePathWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> FilePathCursor {
		FilePathCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> FilePathWhereParam {
		FilePathWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> FilePathWhereParam {
		FilePathWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::IdNot(value)
	}
}
pub struct FilePathSetId(i32);
impl From<FilePathSetId> for FilePathSetParam {
	fn from(value: FilePathSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct FilePathIsDirField {}
impl FilePathIsDirField {
	pub fn set<T: From<FilePathSetIsDir>>(&self, value: bool) -> T {
		FilePathSetIsDir(value).into()
	}
	pub fn equals(&self, value: bool) -> FilePathWhereParam {
		FilePathWhereParam::IsDirEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::IsDir(direction)
	}
	pub fn cursor(&self, cursor: bool) -> FilePathCursor {
		FilePathCursor::IsDir(cursor)
	}
}
pub struct FilePathSetIsDir(bool);
impl From<FilePathSetIsDir> for FilePathSetParam {
	fn from(value: FilePathSetIsDir) -> Self {
		Self::SetIsDir(value.0)
	}
}
pub struct FilePathLocationIdField {}
impl FilePathLocationIdField {
	pub fn set<T: From<FilePathSetLocationId>>(&self, value: i32) -> T {
		FilePathSetLocationId(value).into()
	}
	pub fn equals(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::LocationId(direction)
	}
	pub fn cursor(&self, cursor: i32) -> FilePathCursor {
		FilePathCursor::LocationId(cursor)
	}
	pub fn increment(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetLocationId(value)
	}
	pub fn decrement(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetLocationId(value)
	}
	pub fn multiply(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetLocationId(value)
	}
	pub fn divide(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetLocationId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdLt(value)
	}
	pub fn lte(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdLte(value)
	}
	pub fn gt(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdGt(value)
	}
	pub fn gte(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdGte(value)
	}
	pub fn not(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::LocationIdNot(value)
	}
}
pub struct FilePathSetLocationId(i32);
impl From<FilePathSetLocationId> for FilePathSetParam {
	fn from(value: FilePathSetLocationId) -> Self {
		Self::SetLocationId(value.0)
	}
}
pub struct FilePathMaterializedPathField {}
impl FilePathMaterializedPathField {
	pub fn set<T: From<FilePathSetMaterializedPath>>(&self, value: String) -> T {
		FilePathSetMaterializedPath(value).into()
	}
	pub fn equals(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::MaterializedPath(direction)
	}
	pub fn cursor(&self, cursor: String) -> FilePathCursor {
		FilePathCursor::MaterializedPath(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathNotInVec(value)
	}
	pub fn lt(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathLt(value)
	}
	pub fn lte(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathLte(value)
	}
	pub fn gt(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathGt(value)
	}
	pub fn gte(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathGte(value)
	}
	pub fn contains(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathContains(value)
	}
	pub fn starts_with(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathEndsWith(value)
	}
	pub fn not(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::MaterializedPathNot(value)
	}
}
pub struct FilePathSetMaterializedPath(String);
impl From<FilePathSetMaterializedPath> for FilePathSetParam {
	fn from(value: FilePathSetMaterializedPath) -> Self {
		Self::SetMaterializedPath(value.0)
	}
}
pub struct FilePathNameField {}
impl FilePathNameField {
	pub fn set<T: From<FilePathSetName>>(&self, value: String) -> T {
		FilePathSetName(value).into()
	}
	pub fn equals(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::NameEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::Name(direction)
	}
	pub fn cursor(&self, cursor: String) -> FilePathCursor {
		FilePathCursor::Name(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> FilePathWhereParam {
		FilePathWhereParam::NameInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> FilePathWhereParam {
		FilePathWhereParam::NameNotInVec(value)
	}
	pub fn lt(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::NameLt(value)
	}
	pub fn lte(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::NameLte(value)
	}
	pub fn gt(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::NameGt(value)
	}
	pub fn gte(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::NameGte(value)
	}
	pub fn contains(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::NameContains(value)
	}
	pub fn starts_with(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::NameStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::NameEndsWith(value)
	}
	pub fn not(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::NameNot(value)
	}
}
pub struct FilePathSetName(String);
impl From<FilePathSetName> for FilePathSetParam {
	fn from(value: FilePathSetName) -> Self {
		Self::SetName(value.0)
	}
}
pub struct FilePathExtensionField {}
impl FilePathExtensionField {
	pub fn set<T: From<FilePathSetExtension>>(&self, value: String) -> T {
		FilePathSetExtension(value).into()
	}
	pub fn equals(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::ExtensionEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::Extension(direction)
	}
	pub fn cursor(&self, cursor: String) -> FilePathCursor {
		FilePathCursor::Extension(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> FilePathWhereParam {
		FilePathWhereParam::ExtensionInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> FilePathWhereParam {
		FilePathWhereParam::ExtensionNotInVec(value)
	}
	pub fn lt(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::ExtensionLt(value)
	}
	pub fn lte(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::ExtensionLte(value)
	}
	pub fn gt(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::ExtensionGt(value)
	}
	pub fn gte(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::ExtensionGte(value)
	}
	pub fn contains(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::ExtensionContains(value)
	}
	pub fn starts_with(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::ExtensionStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::ExtensionEndsWith(value)
	}
	pub fn not(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::ExtensionNot(value)
	}
}
pub struct FilePathSetExtension(String);
impl From<FilePathSetExtension> for FilePathSetParam {
	fn from(value: FilePathSetExtension) -> Self {
		Self::SetExtension(value.0)
	}
}
pub struct FilePathFileIdField {}
impl FilePathFileIdField {
	pub fn set<T: From<FilePathSetFileId>>(&self, value: i32) -> T {
		FilePathSetFileId(value).into()
	}
	pub fn equals(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::FileIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::FileId(direction)
	}
	pub fn cursor(&self, cursor: i32) -> FilePathCursor {
		FilePathCursor::FileId(cursor)
	}
	pub fn increment(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetFileId(value)
	}
	pub fn decrement(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetFileId(value)
	}
	pub fn multiply(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetFileId(value)
	}
	pub fn divide(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetFileId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> FilePathWhereParam {
		FilePathWhereParam::FileIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> FilePathWhereParam {
		FilePathWhereParam::FileIdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::FileIdLt(value)
	}
	pub fn lte(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::FileIdLte(value)
	}
	pub fn gt(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::FileIdGt(value)
	}
	pub fn gte(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::FileIdGte(value)
	}
	pub fn not(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::FileIdNot(value)
	}
}
pub struct FilePathSetFileId(i32);
impl From<FilePathSetFileId> for FilePathSetParam {
	fn from(value: FilePathSetFileId) -> Self {
		Self::SetFileId(value.0)
	}
}
pub struct FilePathParentIdField {}
impl FilePathParentIdField {
	pub fn set<T: From<FilePathSetParentId>>(&self, value: i32) -> T {
		FilePathSetParentId(value).into()
	}
	pub fn equals(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::ParentId(direction)
	}
	pub fn cursor(&self, cursor: i32) -> FilePathCursor {
		FilePathCursor::ParentId(cursor)
	}
	pub fn increment(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetParentId(value)
	}
	pub fn decrement(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetParentId(value)
	}
	pub fn multiply(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetParentId(value)
	}
	pub fn divide(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetParentId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdLt(value)
	}
	pub fn lte(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdLte(value)
	}
	pub fn gt(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdGt(value)
	}
	pub fn gte(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdGte(value)
	}
	pub fn not(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::ParentIdNot(value)
	}
}
pub struct FilePathSetParentId(i32);
impl From<FilePathSetParentId> for FilePathSetParam {
	fn from(value: FilePathSetParentId) -> Self {
		Self::SetParentId(value.0)
	}
}
pub struct FilePathEncryptionField {}
impl FilePathEncryptionField {
	pub fn set<T: From<FilePathSetEncryption>>(&self, value: i32) -> T {
		FilePathSetEncryption(value).into()
	}
	pub fn equals(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::EncryptionEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::Encryption(direction)
	}
	pub fn cursor(&self, cursor: i32) -> FilePathCursor {
		FilePathCursor::Encryption(cursor)
	}
	pub fn increment(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetEncryption(value)
	}
	pub fn decrement(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetEncryption(value)
	}
	pub fn multiply(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetEncryption(value)
	}
	pub fn divide(&self, value: i32) -> FilePathSetParam {
		FilePathSetParam::SetEncryption(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> FilePathWhereParam {
		FilePathWhereParam::EncryptionInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> FilePathWhereParam {
		FilePathWhereParam::EncryptionNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::EncryptionLt(value)
	}
	pub fn lte(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::EncryptionLte(value)
	}
	pub fn gt(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::EncryptionGt(value)
	}
	pub fn gte(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::EncryptionGte(value)
	}
	pub fn not(&self, value: i32) -> FilePathWhereParam {
		FilePathWhereParam::EncryptionNot(value)
	}
}
pub struct FilePathSetEncryption(i32);
impl From<FilePathSetEncryption> for FilePathSetParam {
	fn from(value: FilePathSetEncryption) -> Self {
		Self::SetEncryption(value.0)
	}
}
pub struct FilePathPermissionsField {}
impl FilePathPermissionsField {
	pub fn set<T: From<FilePathSetPermissions>>(&self, value: String) -> T {
		FilePathSetPermissions(value).into()
	}
	pub fn equals(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::Permissions(direction)
	}
	pub fn cursor(&self, cursor: String) -> FilePathCursor {
		FilePathCursor::Permissions(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsNotInVec(value)
	}
	pub fn lt(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsLt(value)
	}
	pub fn lte(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsLte(value)
	}
	pub fn gt(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsGt(value)
	}
	pub fn gte(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsGte(value)
	}
	pub fn contains(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsContains(value)
	}
	pub fn starts_with(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsEndsWith(value)
	}
	pub fn not(&self, value: String) -> FilePathWhereParam {
		FilePathWhereParam::PermissionsNot(value)
	}
}
pub struct FilePathSetPermissions(String);
impl From<FilePathSetPermissions> for FilePathSetParam {
	fn from(value: FilePathSetPermissions) -> Self {
		Self::SetPermissions(value.0)
	}
}
pub struct FilePathDateCreatedField {}
impl FilePathDateCreatedField {
	pub fn set<T: From<FilePathSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		FilePathSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> FilePathCursor {
		FilePathCursor::DateCreated(cursor)
	}
	pub fn in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> FilePathWhereParam {
		FilePathWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> FilePathWhereParam {
		FilePathWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateCreatedNot(value)
	}
}
pub struct FilePathSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<FilePathSetDateCreated> for FilePathSetParam {
	fn from(value: FilePathSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct FilePathDateModifiedField {}
impl FilePathDateModifiedField {
	pub fn set<T: From<FilePathSetDateModified>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		FilePathSetDateModified(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateModifiedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::DateModified(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> FilePathCursor {
		FilePathCursor::DateModified(cursor)
	}
	pub fn in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> FilePathWhereParam {
		FilePathWhereParam::DateModifiedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> FilePathWhereParam {
		FilePathWhereParam::DateModifiedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateModifiedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateModifiedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateModifiedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateModifiedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateModifiedNot(value)
	}
}
pub struct FilePathSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<FilePathSetDateModified> for FilePathSetParam {
	fn from(value: FilePathSetDateModified) -> Self {
		Self::SetDateModified(value.0)
	}
}
pub struct FilePathDateIndexedField {}
impl FilePathDateIndexedField {
	pub fn set<T: From<FilePathSetDateIndexed>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		FilePathSetDateIndexed(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> FilePathOrderByParam {
		FilePathOrderByParam::DateIndexed(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> FilePathCursor {
		FilePathCursor::DateIndexed(cursor)
	}
	pub fn in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> FilePathWhereParam {
		FilePathWhereParam::DateIndexedNot(value)
	}
}
pub struct FilePathSetDateIndexed(chrono::DateTime<chrono::Utc>);
impl From<FilePathSetDateIndexed> for FilePathSetParam {
	fn from(value: FilePathSetDateIndexed) -> Self {
		Self::SetDateIndexed(value.0)
	}
}
pub struct FilePathFileField {}
impl FilePathFileField {
	pub fn is(&self, value: Vec<FileWhereParam>) -> FilePathWhereParam {
		FilePathWhereParam::FileIs(value)
	}
	pub fn fetch(&self) -> FilePathWithParam {
		FilePathWithParam::File
	}
	pub fn link<T: From<FilePathLinkFile>>(&self, value: FileWhereUniqueParam) -> T {
		FilePathLinkFile(value).into()
	}
	pub fn unlink(&self) -> FilePathSetParam {
		FilePathSetParam::UnLinkFile
	}
}
pub struct FilePathLinkFile(FileWhereUniqueParam);
impl From<FilePathLinkFile> for FilePathSetParam {
	fn from(value: FilePathLinkFile) -> Self {
		Self::LinkFile(value.0)
	}
}
pub struct FilePathLocationField {}
impl FilePathLocationField {
	pub fn is(&self, value: Vec<LocationWhereParam>) -> FilePathWhereParam {
		FilePathWhereParam::LocationIs(value)
	}
	pub fn fetch(&self) -> FilePathWithParam {
		FilePathWithParam::Location
	}
	pub fn link<T: From<FilePathLinkLocation>>(
		&self,
		value: LocationWhereUniqueParam,
	) -> T {
		FilePathLinkLocation(value).into()
	}
	pub fn unlink(&self) -> FilePathSetParam {
		FilePathSetParam::UnLinkLocation
	}
}
pub struct FilePathLinkLocation(LocationWhereUniqueParam);
impl From<FilePathLinkLocation> for FilePathSetParam {
	fn from(value: FilePathLinkLocation) -> Self {
		Self::LinkLocation(value.0)
	}
}
pub struct FilePathParentField {}
impl FilePathParentField {
	pub fn is(&self, value: Vec<FilePathWhereParam>) -> FilePathWhereParam {
		FilePathWhereParam::ParentIs(value)
	}
	pub fn fetch(&self) -> FilePathWithParam {
		FilePathWithParam::Parent
	}
	pub fn link<T: From<FilePathLinkParent>>(
		&self,
		value: FilePathWhereUniqueParam,
	) -> T {
		FilePathLinkParent(value).into()
	}
	pub fn unlink(&self) -> FilePathSetParam {
		FilePathSetParam::UnLinkParent
	}
}
pub struct FilePathLinkParent(FilePathWhereUniqueParam);
impl From<FilePathLinkParent> for FilePathSetParam {
	fn from(value: FilePathLinkParent) -> Self {
		Self::LinkParent(value.0)
	}
}
pub struct FilePathChildrenField {}
impl FilePathChildrenField {
	pub fn some(&self, value: Vec<FilePathWhereParam>) -> FilePathWhereParam {
		FilePathWhereParam::ChildrenSome(value)
	}
	pub fn every(&self, value: Vec<FilePathWhereParam>) -> FilePathWhereParam {
		FilePathWhereParam::ChildrenEvery(value)
	}
	pub fn fetch(&self, params: Vec<FilePathWhereParam>) -> FilePathWithParam {
		FilePathWithParam::Children(params)
	}
	pub fn link<T: From<FilePathLinkChildren>>(
		&self,
		params: Vec<FilePathWhereUniqueParam>,
	) -> T {
		FilePathLinkChildren(params).into()
	}
	pub fn unlink(&self, params: Vec<FilePathWhereUniqueParam>) -> FilePathSetParam {
		FilePathSetParam::UnLinkChildren(params)
	}
}
pub struct FilePathLinkChildren(Vec<FilePathWhereUniqueParam>);
impl From<FilePathLinkChildren> for FilePathSetParam {
	fn from(value: FilePathLinkChildren) -> Self {
		Self::LinkChildren(value.0)
	}
}
pub enum FilePathWithParam {
	File,
	Location,
	Parent,
	Children(Vec<FilePathWhereParam>),
}
impl FilePathWithParam {
	pub fn to_output(self) -> Output {
		match self {
			Self::File => Output {
				name: "file".into(),
				outputs: file_outputs(),
				..Default::default()
			},
			Self::Location => Output {
				name: "location".into(),
				outputs: location_outputs(),
				..Default::default()
			},
			Self::Parent => Output {
				name: "parent".into(),
				outputs: file_path_outputs(),
				..Default::default()
			},
			Self::Children(where_params) => Output {
				name: "children".into(),
				outputs: file_path_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params
							.into_iter()
							.map(|param| {
								Into::<FilePathWhereParam>::into(param).to_field()
							})
							.collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
		}
	}
}
pub enum FilePathSetParam {
	SetId(i32),
	SetIsDir(bool),
	SetLocationId(i32),
	SetMaterializedPath(String),
	SetName(String),
	SetExtension(String),
	SetFileId(i32),
	SetParentId(i32),
	SetEncryption(i32),
	SetPermissions(String),
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	SetDateModified(chrono::DateTime<chrono::Utc>),
	SetDateIndexed(chrono::DateTime<chrono::Utc>),
	LinkFile(FileWhereUniqueParam),
	UnLinkFile,
	LinkLocation(LocationWhereUniqueParam),
	UnLinkLocation,
	LinkParent(FilePathWhereUniqueParam),
	UnLinkParent,
	LinkChildren(Vec<FilePathWhereUniqueParam>),
	UnLinkChildren(Vec<FilePathWhereUniqueParam>),
}
impl FilePathSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetIsDir(value) => Field {
				name: "is_dir".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetLocationId(value) => Field {
				name: "location_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetMaterializedPath(value) => Field {
				name: "materialized_path".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetName(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetExtension(value) => Field {
				name: "extension".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetFileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetParentId(value) => Field {
				name: "parent_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetEncryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetPermissions(value) => Field {
				name: "permissions".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateIndexed(value) => Field {
				name: "date_indexed".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFile(where_param) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![Into::<FileWhereParam>::into(
						where_param,
					)
					.to_field()])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkFile => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					value: Some(true.into()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LinkLocation(where_param) => Field {
				name: "location".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![
						Into::<LocationWhereParam>::into(where_param).to_field(),
					])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkLocation => Field {
				name: "location".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					value: Some(true.into()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LinkParent(where_param) => Field {
				name: "parent".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![
						Into::<FilePathWhereParam>::into(where_param).to_field(),
					])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkParent => Field {
				name: "parent".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					value: Some(true.into()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LinkChildren(where_params) => Field {
				name: "children".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<FilePathWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkChildren(where_params) => Field {
				name: "children".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<FilePathWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum FilePathOrderByParam {
	Id(Direction),
	IsDir(Direction),
	LocationId(Direction),
	MaterializedPath(Direction),
	Name(Direction),
	Extension(Direction),
	FileId(Direction),
	ParentId(Direction),
	Encryption(Direction),
	Permissions(Direction),
	DateCreated(Direction),
	DateModified(Direction),
	DateIndexed(Direction),
}
impl FilePathOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::IsDir(direction) => Field {
				name: "is_dir".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::LocationId(direction) => Field {
				name: "location_id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::MaterializedPath(direction) => Field {
				name: "materialized_path".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Name(direction) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Extension(direction) => Field {
				name: "extension".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::FileId(direction) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::ParentId(direction) => Field {
				name: "parent_id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Encryption(direction) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Permissions(direction) => Field {
				name: "permissions".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateModified(direction) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateIndexed(direction) => Field {
				name: "date_indexed".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum FilePathCursor {
	Id(i32),
	IsDir(bool),
	LocationId(i32),
	MaterializedPath(String),
	Name(String),
	Extension(String),
	FileId(i32),
	ParentId(i32),
	Encryption(i32),
	Permissions(String),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
	DateIndexed(chrono::DateTime<chrono::Utc>),
}
impl FilePathCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsDir(value) => Field {
				name: "is_dir".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LocationId(value) => Field {
				name: "location_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::MaterializedPath(value) => Field {
				name: "materialized_path".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Extension(value) => Field {
				name: "extension".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::FileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::ParentId(value) => Field {
				name: "parent_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Encryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Permissions(value) => Field {
				name: "permissions".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateIndexed(value) => Field {
				name: "date_indexed".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum FilePathWhereParam {
	Not(Vec<FilePathWhereParam>),
	Or(Vec<FilePathWhereParam>),
	And(Vec<FilePathWhereParam>),
	LocationIdMaterializedPathNameExtensionEquals(i32, String, String, String),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	IsDirEquals(bool),
	LocationIdEquals(i32),
	LocationIdInVec(Vec<i32>),
	LocationIdNotInVec(Vec<i32>),
	LocationIdLt(i32),
	LocationIdLte(i32),
	LocationIdGt(i32),
	LocationIdGte(i32),
	LocationIdNot(i32),
	MaterializedPathEquals(String),
	MaterializedPathInVec(Vec<String>),
	MaterializedPathNotInVec(Vec<String>),
	MaterializedPathLt(String),
	MaterializedPathLte(String),
	MaterializedPathGt(String),
	MaterializedPathGte(String),
	MaterializedPathContains(String),
	MaterializedPathStartsWith(String),
	MaterializedPathEndsWith(String),
	MaterializedPathNot(String),
	NameEquals(String),
	NameInVec(Vec<String>),
	NameNotInVec(Vec<String>),
	NameLt(String),
	NameLte(String),
	NameGt(String),
	NameGte(String),
	NameContains(String),
	NameStartsWith(String),
	NameEndsWith(String),
	NameNot(String),
	ExtensionEquals(String),
	ExtensionInVec(Vec<String>),
	ExtensionNotInVec(Vec<String>),
	ExtensionLt(String),
	ExtensionLte(String),
	ExtensionGt(String),
	ExtensionGte(String),
	ExtensionContains(String),
	ExtensionStartsWith(String),
	ExtensionEndsWith(String),
	ExtensionNot(String),
	FileIdEquals(i32),
	FileIdInVec(Vec<i32>),
	FileIdNotInVec(Vec<i32>),
	FileIdLt(i32),
	FileIdLte(i32),
	FileIdGt(i32),
	FileIdGte(i32),
	FileIdNot(i32),
	ParentIdEquals(i32),
	ParentIdInVec(Vec<i32>),
	ParentIdNotInVec(Vec<i32>),
	ParentIdLt(i32),
	ParentIdLte(i32),
	ParentIdGt(i32),
	ParentIdGte(i32),
	ParentIdNot(i32),
	EncryptionEquals(i32),
	EncryptionInVec(Vec<i32>),
	EncryptionNotInVec(Vec<i32>),
	EncryptionLt(i32),
	EncryptionLte(i32),
	EncryptionGt(i32),
	EncryptionGte(i32),
	EncryptionNot(i32),
	PermissionsEquals(String),
	PermissionsInVec(Vec<String>),
	PermissionsNotInVec(Vec<String>),
	PermissionsLt(String),
	PermissionsLte(String),
	PermissionsGt(String),
	PermissionsGte(String),
	PermissionsContains(String),
	PermissionsStartsWith(String),
	PermissionsEndsWith(String),
	PermissionsNot(String),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedLt(chrono::DateTime<chrono::Utc>),
	DateModifiedLte(chrono::DateTime<chrono::Utc>),
	DateModifiedGt(chrono::DateTime<chrono::Utc>),
	DateModifiedGte(chrono::DateTime<chrono::Utc>),
	DateModifiedNot(chrono::DateTime<chrono::Utc>),
	DateIndexedEquals(chrono::DateTime<chrono::Utc>),
	DateIndexedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateIndexedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateIndexedLt(chrono::DateTime<chrono::Utc>),
	DateIndexedLte(chrono::DateTime<chrono::Utc>),
	DateIndexedGt(chrono::DateTime<chrono::Utc>),
	DateIndexedGte(chrono::DateTime<chrono::Utc>),
	DateIndexedNot(chrono::DateTime<chrono::Utc>),
	FileIs(Vec<FileWhereParam>),
	LocationIs(Vec<LocationWhereParam>),
	ParentIs(Vec<FilePathWhereParam>),
	ChildrenSome(Vec<FilePathWhereParam>),
	ChildrenEvery(Vec<FilePathWhereParam>),
}
impl FilePathWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::LocationIdMaterializedPathNameExtensionEquals(
				location_id,
				materialized_path,
				name,
				extension,
			) => Field {
				name: "location_id_materialized_path_name_extension".into(),
				fields: Some(transform_equals(
					vec![
						FilePathWhereParam::LocationIdEquals(location_id),
						FilePathWhereParam::MaterializedPathEquals(materialized_path),
						FilePathWhereParam::NameEquals(name),
						FilePathWhereParam::ExtensionEquals(extension),
					]
					.into_iter()
					.map(|f| f.to_field())
					.collect(),
				)),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsDirEquals(value) => Field {
				name: "is_dir".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdEquals(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdInVec(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdNotInVec(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdLt(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdLte(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdGt(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdGte(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIdNot(value) => Field {
				name: "location_id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathEquals(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathInVec(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathNotInVec(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathLt(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathLte(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathGt(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathGte(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathContains(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathStartsWith(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathEndsWith(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::MaterializedPathNot(value) => Field {
				name: "materialized_path".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNotInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameStartsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEndsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNot(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionEquals(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionInVec(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionNotInVec(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionLt(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionLte(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionGt(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionGte(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionContains(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionStartsWith(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionEndsWith(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ExtensionNot(value) => Field {
				name: "extension".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdEquals(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdInVec(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdNotInVec(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLt(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLte(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGt(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGte(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdNot(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdEquals(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdInVec(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdNotInVec(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdLt(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdLte(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdGt(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdGte(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIdNot(value) => Field {
				name: "parent_id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionEquals(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionInVec(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionNotInVec(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLt(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLte(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGt(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGte(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionNot(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsEquals(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsInVec(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsNotInVec(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsLt(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsLte(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsGt(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsGte(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsContains(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsStartsWith(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsEndsWith(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::PermissionsNot(value) => Field {
				name: "permissions".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNotInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNot(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedEquals(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedInVec(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedNotInVec(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedLt(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedLte(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedGt(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedGte(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateIndexedNot(value) => Field {
				name: "date_indexed".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIs(value) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "is".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LocationIs(value) => Field {
				name: "location".into(),
				fields: Some(vec![Field {
					name: "is".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ParentIs(value) => Field {
				name: "parent".into(),
				fields: Some(vec![Field {
					name: "is".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChildrenSome(value) => Field {
				name: "children".into(),
				fields: Some(vec![Field {
					name: "some".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ChildrenEvery(value) => Field {
				name: "children".into(),
				fields: Some(vec![Field {
					name: "every".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum FilePathWhereUniqueParam {
	LocationIdMaterializedPathNameExtensionEquals(i32, String, String, String),
	IdEquals(i32),
}
impl From<FilePathWhereUniqueParam> for FilePathWhereParam {
	fn from(value: FilePathWhereUniqueParam) -> Self {
		match value {
			FilePathWhereUniqueParam::LocationIdMaterializedPathNameExtensionEquals(
				location_id,
				materialized_path,
				name,
				extension,
			) => Self::LocationIdMaterializedPathNameExtensionEquals(
				location_id,
				materialized_path,
				name,
				extension,
			),
			FilePathWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
		}
	}
}
impl From<Operator<Self>> for FilePathWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct FilePathFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<FilePathOrderByParam>,
	with_params: Vec<FilePathWithParam>,
}
impl<'a> FilePathFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<FilePathData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> FilePathDelete<'a> {
		FilePathDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "FilePath".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<FilePathSetParam>) -> FilePathUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		FilePathUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: FilePathOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: FilePathWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: FilePathCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct FilePathFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<FilePathOrderByParam>,
	with_params: Vec<FilePathWithParam>,
}
impl<'a> FilePathFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<FilePathData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: FilePathWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: FilePathOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: FilePathCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct FilePathFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<FilePathWithParam>,
}
impl<'a> FilePathFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<FilePathData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> FilePathDelete<'a> {
		FilePathDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "FilePath".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<FilePathSetParam>) -> FilePathUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		FilePathUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: FilePathWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct FilePathCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<FilePathWithParam>,
}
impl<'a> FilePathCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<FilePathData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: FilePathWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct FilePathUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<FilePathWithParam>,
}
impl<'a> FilePathUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<FilePathData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: FilePathWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct FilePathUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<FilePathWithParam>,
}
impl<'a> FilePathUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<FilePathData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: FilePathWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct FilePathUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> FilePathUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<FilePathData> {
		self.query.perform().await
	}
	pub fn create(
		mut self,
		materialized_path: FilePathSetMaterializedPath,
		name: FilePathSetName,
		params: Vec<FilePathSetParam>,
	) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(FilePathSetParam::from(materialized_path).to_field());
		input_fields.push(FilePathSetParam::from(name).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<FilePathSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct FilePathDelete<'a> {
	query: Query<'a>,
}
impl<'a> FilePathDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct FilePathActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> FilePathActions<'a> {
	pub fn find_unique(&self, param: FilePathWhereUniqueParam) -> FilePathFindUnique {
		let param: FilePathWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "FilePath".into(),
			outputs: file_path_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		FilePathFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<FilePathWhereParam>) -> FilePathFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "FilePath".into(),
			outputs: file_path_outputs(),
			inputs,
		};
		FilePathFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<FilePathWhereParam>) -> FilePathFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "FilePath".into(),
			outputs: file_path_outputs(),
			inputs,
		};
		FilePathFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		materialized_path: FilePathSetMaterializedPath,
		name: FilePathSetName,
		params: Vec<FilePathSetParam>,
	) -> FilePathCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(FilePathSetParam::from(materialized_path).to_field());
		input_fields.push(FilePathSetParam::from(name).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "FilePath".into(),
			outputs: file_path_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		FilePathCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: FilePathWhereUniqueParam) -> FilePathUpsertOne {
		let param: FilePathWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "FilePath".into(),
			outputs: file_path_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		FilePathUpsertOne { query }
	}
}
fn tag_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("encryption"),
		Output::new("total_files"),
		Output::new("redundancy_goal"),
		Output::new("date_created"),
		Output::new("date_modified"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TagData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "name")]
	pub name: Option<String>,
	#[serde(rename = "encryption")]
	pub encryption: Option<i32>,
	#[serde(rename = "total_files")]
	pub total_files: Option<i32>,
	#[serde(rename = "redundancy_goal")]
	pub redundancy_goal: Option<i32>,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "tag_files")]
	tag_files: Option<Vec<TagOnFileData>>,
}
impl TagData {
	pub fn tag_files(&self) -> Result<&Vec<TagOnFileData>, String> {
		match self . tag_files . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access tag_files but did not fetch it using the .with() syntax" . to_string ()) , }
	}
}
pub struct Tag;
impl Tag {
	pub fn id() -> TagIdField {
		TagIdField {}
	}
	pub fn name() -> TagNameField {
		TagNameField {}
	}
	pub fn encryption() -> TagEncryptionField {
		TagEncryptionField {}
	}
	pub fn total_files() -> TagTotalFilesField {
		TagTotalFilesField {}
	}
	pub fn redundancy_goal() -> TagRedundancyGoalField {
		TagRedundancyGoalField {}
	}
	pub fn date_created() -> TagDateCreatedField {
		TagDateCreatedField {}
	}
	pub fn date_modified() -> TagDateModifiedField {
		TagDateModifiedField {}
	}
	pub fn tag_files() -> TagTagFilesField {
		TagTagFilesField {}
	}
}
pub struct TagIdField {}
impl TagIdField {
	pub fn set<T: From<TagSetId>>(&self, value: i32) -> T {
		TagSetId(value).into()
	}
	pub fn equals<T: From<TagWhereUniqueParam>>(&self, value: i32) -> T {
		TagWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> TagOrderByParam {
		TagOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> TagCursor {
		TagCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> TagSetParam {
		TagSetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> TagSetParam {
		TagSetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> TagSetParam {
		TagSetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> TagSetParam {
		TagSetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> TagWhereParam {
		TagWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> TagWhereParam {
		TagWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> TagWhereParam {
		TagWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> TagWhereParam {
		TagWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> TagWhereParam {
		TagWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> TagWhereParam {
		TagWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> TagWhereParam {
		TagWhereParam::IdNot(value)
	}
}
pub struct TagSetId(i32);
impl From<TagSetId> for TagSetParam {
	fn from(value: TagSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct TagNameField {}
impl TagNameField {
	pub fn set<T: From<TagSetName>>(&self, value: String) -> T {
		TagSetName(value).into()
	}
	pub fn equals(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> TagOrderByParam {
		TagOrderByParam::Name(direction)
	}
	pub fn cursor(&self, cursor: String) -> TagCursor {
		TagCursor::Name(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> TagWhereParam {
		TagWhereParam::NameInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> TagWhereParam {
		TagWhereParam::NameNotInVec(value)
	}
	pub fn lt(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameLt(value)
	}
	pub fn lte(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameLte(value)
	}
	pub fn gt(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameGt(value)
	}
	pub fn gte(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameGte(value)
	}
	pub fn contains(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameContains(value)
	}
	pub fn starts_with(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameEndsWith(value)
	}
	pub fn not(&self, value: String) -> TagWhereParam {
		TagWhereParam::NameNot(value)
	}
}
pub struct TagSetName(String);
impl From<TagSetName> for TagSetParam {
	fn from(value: TagSetName) -> Self {
		Self::SetName(value.0)
	}
}
pub struct TagEncryptionField {}
impl TagEncryptionField {
	pub fn set<T: From<TagSetEncryption>>(&self, value: i32) -> T {
		TagSetEncryption(value).into()
	}
	pub fn equals(&self, value: i32) -> TagWhereParam {
		TagWhereParam::EncryptionEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> TagOrderByParam {
		TagOrderByParam::Encryption(direction)
	}
	pub fn cursor(&self, cursor: i32) -> TagCursor {
		TagCursor::Encryption(cursor)
	}
	pub fn increment(&self, value: i32) -> TagSetParam {
		TagSetParam::SetEncryption(value)
	}
	pub fn decrement(&self, value: i32) -> TagSetParam {
		TagSetParam::SetEncryption(value)
	}
	pub fn multiply(&self, value: i32) -> TagSetParam {
		TagSetParam::SetEncryption(value)
	}
	pub fn divide(&self, value: i32) -> TagSetParam {
		TagSetParam::SetEncryption(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> TagWhereParam {
		TagWhereParam::EncryptionInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> TagWhereParam {
		TagWhereParam::EncryptionNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> TagWhereParam {
		TagWhereParam::EncryptionLt(value)
	}
	pub fn lte(&self, value: i32) -> TagWhereParam {
		TagWhereParam::EncryptionLte(value)
	}
	pub fn gt(&self, value: i32) -> TagWhereParam {
		TagWhereParam::EncryptionGt(value)
	}
	pub fn gte(&self, value: i32) -> TagWhereParam {
		TagWhereParam::EncryptionGte(value)
	}
	pub fn not(&self, value: i32) -> TagWhereParam {
		TagWhereParam::EncryptionNot(value)
	}
}
pub struct TagSetEncryption(i32);
impl From<TagSetEncryption> for TagSetParam {
	fn from(value: TagSetEncryption) -> Self {
		Self::SetEncryption(value.0)
	}
}
pub struct TagTotalFilesField {}
impl TagTotalFilesField {
	pub fn set<T: From<TagSetTotalFiles>>(&self, value: i32) -> T {
		TagSetTotalFiles(value).into()
	}
	pub fn equals(&self, value: i32) -> TagWhereParam {
		TagWhereParam::TotalFilesEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> TagOrderByParam {
		TagOrderByParam::TotalFiles(direction)
	}
	pub fn cursor(&self, cursor: i32) -> TagCursor {
		TagCursor::TotalFiles(cursor)
	}
	pub fn increment(&self, value: i32) -> TagSetParam {
		TagSetParam::SetTotalFiles(value)
	}
	pub fn decrement(&self, value: i32) -> TagSetParam {
		TagSetParam::SetTotalFiles(value)
	}
	pub fn multiply(&self, value: i32) -> TagSetParam {
		TagSetParam::SetTotalFiles(value)
	}
	pub fn divide(&self, value: i32) -> TagSetParam {
		TagSetParam::SetTotalFiles(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> TagWhereParam {
		TagWhereParam::TotalFilesInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> TagWhereParam {
		TagWhereParam::TotalFilesNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> TagWhereParam {
		TagWhereParam::TotalFilesLt(value)
	}
	pub fn lte(&self, value: i32) -> TagWhereParam {
		TagWhereParam::TotalFilesLte(value)
	}
	pub fn gt(&self, value: i32) -> TagWhereParam {
		TagWhereParam::TotalFilesGt(value)
	}
	pub fn gte(&self, value: i32) -> TagWhereParam {
		TagWhereParam::TotalFilesGte(value)
	}
	pub fn not(&self, value: i32) -> TagWhereParam {
		TagWhereParam::TotalFilesNot(value)
	}
}
pub struct TagSetTotalFiles(i32);
impl From<TagSetTotalFiles> for TagSetParam {
	fn from(value: TagSetTotalFiles) -> Self {
		Self::SetTotalFiles(value.0)
	}
}
pub struct TagRedundancyGoalField {}
impl TagRedundancyGoalField {
	pub fn set<T: From<TagSetRedundancyGoal>>(&self, value: i32) -> T {
		TagSetRedundancyGoal(value).into()
	}
	pub fn equals(&self, value: i32) -> TagWhereParam {
		TagWhereParam::RedundancyGoalEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> TagOrderByParam {
		TagOrderByParam::RedundancyGoal(direction)
	}
	pub fn cursor(&self, cursor: i32) -> TagCursor {
		TagCursor::RedundancyGoal(cursor)
	}
	pub fn increment(&self, value: i32) -> TagSetParam {
		TagSetParam::SetRedundancyGoal(value)
	}
	pub fn decrement(&self, value: i32) -> TagSetParam {
		TagSetParam::SetRedundancyGoal(value)
	}
	pub fn multiply(&self, value: i32) -> TagSetParam {
		TagSetParam::SetRedundancyGoal(value)
	}
	pub fn divide(&self, value: i32) -> TagSetParam {
		TagSetParam::SetRedundancyGoal(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> TagWhereParam {
		TagWhereParam::RedundancyGoalInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> TagWhereParam {
		TagWhereParam::RedundancyGoalNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> TagWhereParam {
		TagWhereParam::RedundancyGoalLt(value)
	}
	pub fn lte(&self, value: i32) -> TagWhereParam {
		TagWhereParam::RedundancyGoalLte(value)
	}
	pub fn gt(&self, value: i32) -> TagWhereParam {
		TagWhereParam::RedundancyGoalGt(value)
	}
	pub fn gte(&self, value: i32) -> TagWhereParam {
		TagWhereParam::RedundancyGoalGte(value)
	}
	pub fn not(&self, value: i32) -> TagWhereParam {
		TagWhereParam::RedundancyGoalNot(value)
	}
}
pub struct TagSetRedundancyGoal(i32);
impl From<TagSetRedundancyGoal> for TagSetParam {
	fn from(value: TagSetRedundancyGoal) -> Self {
		Self::SetRedundancyGoal(value.0)
	}
}
pub struct TagDateCreatedField {}
impl TagDateCreatedField {
	pub fn set<T: From<TagSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		TagSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> TagOrderByParam {
		TagOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> TagCursor {
		TagCursor::DateCreated(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> TagWhereParam {
		TagWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> TagWhereParam {
		TagWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateCreatedNot(value)
	}
}
pub struct TagSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<TagSetDateCreated> for TagSetParam {
	fn from(value: TagSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct TagDateModifiedField {}
impl TagDateModifiedField {
	pub fn set<T: From<TagSetDateModified>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		TagSetDateModified(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateModifiedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> TagOrderByParam {
		TagOrderByParam::DateModified(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> TagCursor {
		TagCursor::DateModified(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> TagWhereParam {
		TagWhereParam::DateModifiedInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> TagWhereParam {
		TagWhereParam::DateModifiedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateModifiedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateModifiedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateModifiedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateModifiedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> TagWhereParam {
		TagWhereParam::DateModifiedNot(value)
	}
}
pub struct TagSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<TagSetDateModified> for TagSetParam {
	fn from(value: TagSetDateModified) -> Self {
		Self::SetDateModified(value.0)
	}
}
pub struct TagTagFilesField {}
impl TagTagFilesField {
	pub fn some(&self, value: Vec<TagOnFileWhereParam>) -> TagWhereParam {
		TagWhereParam::TagFilesSome(value)
	}
	pub fn every(&self, value: Vec<TagOnFileWhereParam>) -> TagWhereParam {
		TagWhereParam::TagFilesEvery(value)
	}
	pub fn fetch(&self, params: Vec<TagOnFileWhereParam>) -> TagWithParam {
		TagWithParam::TagFiles(params)
	}
	pub fn link<T: From<TagLinkTagFiles>>(
		&self,
		params: Vec<TagOnFileWhereUniqueParam>,
	) -> T {
		TagLinkTagFiles(params).into()
	}
	pub fn unlink(&self, params: Vec<TagOnFileWhereUniqueParam>) -> TagSetParam {
		TagSetParam::UnLinkTagFiles(params)
	}
}
pub struct TagLinkTagFiles(Vec<TagOnFileWhereUniqueParam>);
impl From<TagLinkTagFiles> for TagSetParam {
	fn from(value: TagLinkTagFiles) -> Self {
		Self::LinkTagFiles(value.0)
	}
}
pub enum TagWithParam {
	TagFiles(Vec<TagOnFileWhereParam>),
}
impl TagWithParam {
	pub fn to_output(self) -> Output {
		match self {
			Self::TagFiles(where_params) => Output {
				name: "tag_files".into(),
				outputs: tag_on_file_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params
							.into_iter()
							.map(|param| {
								Into::<TagOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
		}
	}
}
pub enum TagSetParam {
	SetId(i32),
	SetName(String),
	SetEncryption(i32),
	SetTotalFiles(i32),
	SetRedundancyGoal(i32),
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	SetDateModified(chrono::DateTime<chrono::Utc>),
	LinkTagFiles(Vec<TagOnFileWhereUniqueParam>),
	UnLinkTagFiles(Vec<TagOnFileWhereUniqueParam>),
}
impl TagSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetName(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetEncryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetTotalFiles(value) => Field {
				name: "total_files".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetRedundancyGoal(value) => Field {
				name: "redundancy_goal".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkTagFiles(where_params) => Field {
				name: "tag_files".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<TagOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkTagFiles(where_params) => Field {
				name: "tag_files".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<TagOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum TagOrderByParam {
	Id(Direction),
	Name(Direction),
	Encryption(Direction),
	TotalFiles(Direction),
	RedundancyGoal(Direction),
	DateCreated(Direction),
	DateModified(Direction),
}
impl TagOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Name(direction) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Encryption(direction) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::TotalFiles(direction) => Field {
				name: "total_files".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::RedundancyGoal(direction) => Field {
				name: "redundancy_goal".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateModified(direction) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum TagCursor {
	Id(i32),
	Name(String),
	Encryption(i32),
	TotalFiles(i32),
	RedundancyGoal(i32),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
}
impl TagCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Encryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TotalFiles(value) => Field {
				name: "total_files".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::RedundancyGoal(value) => Field {
				name: "redundancy_goal".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum TagWhereParam {
	Not(Vec<TagWhereParam>),
	Or(Vec<TagWhereParam>),
	And(Vec<TagWhereParam>),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	NameEquals(String),
	NameInVec(Vec<String>),
	NameNotInVec(Vec<String>),
	NameLt(String),
	NameLte(String),
	NameGt(String),
	NameGte(String),
	NameContains(String),
	NameStartsWith(String),
	NameEndsWith(String),
	NameNot(String),
	EncryptionEquals(i32),
	EncryptionInVec(Vec<i32>),
	EncryptionNotInVec(Vec<i32>),
	EncryptionLt(i32),
	EncryptionLte(i32),
	EncryptionGt(i32),
	EncryptionGte(i32),
	EncryptionNot(i32),
	TotalFilesEquals(i32),
	TotalFilesInVec(Vec<i32>),
	TotalFilesNotInVec(Vec<i32>),
	TotalFilesLt(i32),
	TotalFilesLte(i32),
	TotalFilesGt(i32),
	TotalFilesGte(i32),
	TotalFilesNot(i32),
	RedundancyGoalEquals(i32),
	RedundancyGoalInVec(Vec<i32>),
	RedundancyGoalNotInVec(Vec<i32>),
	RedundancyGoalLt(i32),
	RedundancyGoalLte(i32),
	RedundancyGoalGt(i32),
	RedundancyGoalGte(i32),
	RedundancyGoalNot(i32),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedLt(chrono::DateTime<chrono::Utc>),
	DateModifiedLte(chrono::DateTime<chrono::Utc>),
	DateModifiedGt(chrono::DateTime<chrono::Utc>),
	DateModifiedGte(chrono::DateTime<chrono::Utc>),
	DateModifiedNot(chrono::DateTime<chrono::Utc>),
	TagFilesSome(Vec<TagOnFileWhereParam>),
	TagFilesEvery(Vec<TagOnFileWhereParam>),
}
impl TagWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNotInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameStartsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEndsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNot(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionEquals(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionInVec(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionNotInVec(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLt(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLte(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGt(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGte(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionNot(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesEquals(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesInVec(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesNotInVec(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesLt(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesLte(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesGt(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesGte(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TotalFilesNot(value) => Field {
				name: "total_files".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalEquals(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalInVec(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalNotInVec(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalLt(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalLte(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalGt(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalGte(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::RedundancyGoalNot(value) => Field {
				name: "redundancy_goal".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNotInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNot(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagFilesSome(value) => Field {
				name: "tag_files".into(),
				fields: Some(vec![Field {
					name: "some".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagFilesEvery(value) => Field {
				name: "tag_files".into(),
				fields: Some(vec![Field {
					name: "every".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum TagWhereUniqueParam {
	IdEquals(i32),
}
impl From<TagWhereUniqueParam> for TagWhereParam {
	fn from(value: TagWhereUniqueParam) -> Self {
		match value {
			TagWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
		}
	}
}
impl From<Operator<Self>> for TagWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct TagFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<TagOrderByParam>,
	with_params: Vec<TagWithParam>,
}
impl<'a> TagFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<TagData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> TagDelete<'a> {
		TagDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Tag".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<TagSetParam>) -> TagUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		TagUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: TagOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: TagWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: TagCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct TagFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<TagOrderByParam>,
	with_params: Vec<TagWithParam>,
}
impl<'a> TagFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<TagData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: TagWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: TagOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: TagCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct TagFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<TagWithParam>,
}
impl<'a> TagFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<TagData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> TagDelete<'a> {
		TagDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Tag".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<TagSetParam>) -> TagUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		TagUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: TagWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct TagCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<TagWithParam>,
}
impl<'a> TagCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<TagData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: TagWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct TagUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<TagWithParam>,
}
impl<'a> TagUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<TagData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: TagWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct TagUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<TagWithParam>,
}
impl<'a> TagUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<TagData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: TagWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct TagUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> TagUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<TagData> {
		self.query.perform().await
	}
	pub fn create(mut self, params: Vec<TagSetParam>) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<TagSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct TagDelete<'a> {
	query: Query<'a>,
}
impl<'a> TagDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct TagActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> TagActions<'a> {
	pub fn find_unique(&self, param: TagWhereUniqueParam) -> TagFindUnique {
		let param: TagWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Tag".into(),
			outputs: tag_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		TagFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<TagWhereParam>) -> TagFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Tag".into(),
			outputs: tag_outputs(),
			inputs,
		};
		TagFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<TagWhereParam>) -> TagFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Tag".into(),
			outputs: tag_outputs(),
			inputs,
		};
		TagFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(&self, params: Vec<TagSetParam>) -> TagCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Tag".into(),
			outputs: tag_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		TagCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: TagWhereUniqueParam) -> TagUpsertOne {
		let param: TagWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "Tag".into(),
			outputs: tag_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		TagUpsertOne { query }
	}
}
fn tag_on_file_outputs() -> Vec<Output> {
	vec![
		Output::new("date_created"),
		Output::new("tag_id"),
		Output::new("file_id"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TagOnFileData {
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "tag_id")]
	pub tag_id: i32,
	#[serde(rename = "tag")]
	tag: Option<Box<TagData>>,
	#[serde(rename = "file_id")]
	pub file_id: i32,
	#[serde(rename = "file")]
	file: Option<Box<FileData>>,
}
impl TagOnFileData {
	pub fn tag(&self) -> Result<&TagData, String> {
		match self.tag.as_ref() {
			Some(v) => Ok(v),
			None => Err(
				"Attempted to access tag but did not fetch it using the .with() syntax"
					.to_string(),
			),
		}
	}
	pub fn file(&self) -> Result<&FileData, String> {
		match self.file.as_ref() {
			Some(v) => Ok(v),
			None => Err(
				"Attempted to access file but did not fetch it using the .with() syntax"
					.to_string(),
			),
		}
	}
}
pub struct TagOnFile;
impl TagOnFile {
	pub fn tag_id_file_id<T: From<TagOnFileWhereUniqueParam>>(
		tag_id: i32,
		file_id: i32,
	) -> T {
		TagOnFileWhereUniqueParam::TagIdFileIdEquals(tag_id, file_id).into()
	}
	pub fn date_created() -> TagOnFileDateCreatedField {
		TagOnFileDateCreatedField {}
	}
	pub fn tag_id() -> TagOnFileTagIdField {
		TagOnFileTagIdField {}
	}
	pub fn tag() -> TagOnFileTagField {
		TagOnFileTagField {}
	}
	pub fn file_id() -> TagOnFileFileIdField {
		TagOnFileFileIdField {}
	}
	pub fn file() -> TagOnFileFileField {
		TagOnFileFileField {}
	}
}
pub struct TagOnFileDateCreatedField {}
impl TagOnFileDateCreatedField {
	pub fn set<T: From<TagOnFileSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		TagOnFileSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> TagOnFileOrderByParam {
		TagOnFileOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> TagOnFileCursor {
		TagOnFileCursor::DateCreated(cursor)
	}
	pub fn in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::DateCreatedNot(value)
	}
}
pub struct TagOnFileSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<TagOnFileSetDateCreated> for TagOnFileSetParam {
	fn from(value: TagOnFileSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct TagOnFileTagIdField {}
impl TagOnFileTagIdField {
	pub fn set<T: From<TagOnFileSetTagId>>(&self, value: i32) -> T {
		TagOnFileSetTagId(value).into()
	}
	pub fn equals(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> TagOnFileOrderByParam {
		TagOnFileOrderByParam::TagId(direction)
	}
	pub fn cursor(&self, cursor: i32) -> TagOnFileCursor {
		TagOnFileCursor::TagId(cursor)
	}
	pub fn increment(&self, value: i32) -> TagOnFileSetParam {
		TagOnFileSetParam::SetTagId(value)
	}
	pub fn decrement(&self, value: i32) -> TagOnFileSetParam {
		TagOnFileSetParam::SetTagId(value)
	}
	pub fn multiply(&self, value: i32) -> TagOnFileSetParam {
		TagOnFileSetParam::SetTagId(value)
	}
	pub fn divide(&self, value: i32) -> TagOnFileSetParam {
		TagOnFileSetParam::SetTagId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdLt(value)
	}
	pub fn lte(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdLte(value)
	}
	pub fn gt(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdGt(value)
	}
	pub fn gte(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdGte(value)
	}
	pub fn not(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIdNot(value)
	}
}
pub struct TagOnFileSetTagId(i32);
impl From<TagOnFileSetTagId> for TagOnFileSetParam {
	fn from(value: TagOnFileSetTagId) -> Self {
		Self::SetTagId(value.0)
	}
}
pub struct TagOnFileTagField {}
impl TagOnFileTagField {
	pub fn is(&self, value: Vec<TagWhereParam>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::TagIs(value)
	}
	pub fn fetch(&self) -> TagOnFileWithParam {
		TagOnFileWithParam::Tag
	}
	pub fn link<T: From<TagOnFileLinkTag>>(&self, value: TagWhereUniqueParam) -> T {
		TagOnFileLinkTag(value).into()
	}
}
pub struct TagOnFileLinkTag(TagWhereUniqueParam);
impl From<TagOnFileLinkTag> for TagOnFileSetParam {
	fn from(value: TagOnFileLinkTag) -> Self {
		Self::LinkTag(value.0)
	}
}
pub struct TagOnFileFileIdField {}
impl TagOnFileFileIdField {
	pub fn set<T: From<TagOnFileSetFileId>>(&self, value: i32) -> T {
		TagOnFileSetFileId(value).into()
	}
	pub fn equals(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> TagOnFileOrderByParam {
		TagOnFileOrderByParam::FileId(direction)
	}
	pub fn cursor(&self, cursor: i32) -> TagOnFileCursor {
		TagOnFileCursor::FileId(cursor)
	}
	pub fn increment(&self, value: i32) -> TagOnFileSetParam {
		TagOnFileSetParam::SetFileId(value)
	}
	pub fn decrement(&self, value: i32) -> TagOnFileSetParam {
		TagOnFileSetParam::SetFileId(value)
	}
	pub fn multiply(&self, value: i32) -> TagOnFileSetParam {
		TagOnFileSetParam::SetFileId(value)
	}
	pub fn divide(&self, value: i32) -> TagOnFileSetParam {
		TagOnFileSetParam::SetFileId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdLt(value)
	}
	pub fn lte(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdLte(value)
	}
	pub fn gt(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdGt(value)
	}
	pub fn gte(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdGte(value)
	}
	pub fn not(&self, value: i32) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIdNot(value)
	}
}
pub struct TagOnFileSetFileId(i32);
impl From<TagOnFileSetFileId> for TagOnFileSetParam {
	fn from(value: TagOnFileSetFileId) -> Self {
		Self::SetFileId(value.0)
	}
}
pub struct TagOnFileFileField {}
impl TagOnFileFileField {
	pub fn is(&self, value: Vec<FileWhereParam>) -> TagOnFileWhereParam {
		TagOnFileWhereParam::FileIs(value)
	}
	pub fn fetch(&self) -> TagOnFileWithParam {
		TagOnFileWithParam::File
	}
	pub fn link<T: From<TagOnFileLinkFile>>(&self, value: FileWhereUniqueParam) -> T {
		TagOnFileLinkFile(value).into()
	}
}
pub struct TagOnFileLinkFile(FileWhereUniqueParam);
impl From<TagOnFileLinkFile> for TagOnFileSetParam {
	fn from(value: TagOnFileLinkFile) -> Self {
		Self::LinkFile(value.0)
	}
}
pub enum TagOnFileWithParam {
	Tag,
	File,
}
impl TagOnFileWithParam {
	pub fn to_output(self) -> Output {
		match self {
			Self::Tag => Output {
				name: "tag".into(),
				outputs: tag_outputs(),
				..Default::default()
			},
			Self::File => Output {
				name: "file".into(),
				outputs: file_outputs(),
				..Default::default()
			},
		}
	}
}
pub enum TagOnFileSetParam {
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	SetTagId(i32),
	LinkTag(TagWhereUniqueParam),
	SetFileId(i32),
	LinkFile(FileWhereUniqueParam),
}
impl TagOnFileSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetTagId(value) => Field {
				name: "tag_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkTag(where_param) => Field {
				name: "tag".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![Into::<TagWhereParam>::into(
						where_param,
					)
					.to_field()])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SetFileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFile(where_param) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![Into::<FileWhereParam>::into(
						where_param,
					)
					.to_field()])),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum TagOnFileOrderByParam {
	DateCreated(Direction),
	TagId(Direction),
	FileId(Direction),
}
impl TagOnFileOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::TagId(direction) => Field {
				name: "tag_id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::FileId(direction) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum TagOnFileCursor {
	DateCreated(chrono::DateTime<chrono::Utc>),
	TagId(i32),
	FileId(i32),
}
impl TagOnFileCursor {
	fn to_field(self) -> Field {
		match self {
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TagId(value) => Field {
				name: "tag_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::FileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum TagOnFileWhereParam {
	Not(Vec<TagOnFileWhereParam>),
	Or(Vec<TagOnFileWhereParam>),
	And(Vec<TagOnFileWhereParam>),
	TagIdFileIdEquals(i32, i32),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	TagIdEquals(i32),
	TagIdInVec(Vec<i32>),
	TagIdNotInVec(Vec<i32>),
	TagIdLt(i32),
	TagIdLte(i32),
	TagIdGt(i32),
	TagIdGte(i32),
	TagIdNot(i32),
	TagIs(Vec<TagWhereParam>),
	FileIdEquals(i32),
	FileIdInVec(Vec<i32>),
	FileIdNotInVec(Vec<i32>),
	FileIdLt(i32),
	FileIdLte(i32),
	FileIdGt(i32),
	FileIdGte(i32),
	FileIdNot(i32),
	FileIs(Vec<FileWhereParam>),
}
impl TagOnFileWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::TagIdFileIdEquals(tag_id, file_id) => Field {
				name: "tag_id_file_id".into(),
				fields: Some(transform_equals(
					vec![
						TagOnFileWhereParam::TagIdEquals(tag_id),
						TagOnFileWhereParam::FileIdEquals(file_id),
					]
					.into_iter()
					.map(|f| f.to_field())
					.collect(),
				)),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdEquals(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdInVec(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdNotInVec(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdLt(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdLte(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdGt(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdGte(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIdNot(value) => Field {
				name: "tag_id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TagIs(value) => Field {
				name: "tag".into(),
				fields: Some(vec![Field {
					name: "is".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdEquals(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdInVec(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdNotInVec(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLt(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLte(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGt(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGte(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdNot(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIs(value) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "is".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum TagOnFileWhereUniqueParam {
	TagIdFileIdEquals(i32, i32),
}
impl From<TagOnFileWhereUniqueParam> for TagOnFileWhereParam {
	fn from(value: TagOnFileWhereUniqueParam) -> Self {
		match value {
			TagOnFileWhereUniqueParam::TagIdFileIdEquals(tag_id, file_id) => {
				Self::TagIdFileIdEquals(tag_id, file_id)
			},
		}
	}
}
impl From<Operator<Self>> for TagOnFileWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct TagOnFileFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<TagOnFileOrderByParam>,
	with_params: Vec<TagOnFileWithParam>,
}
impl<'a> TagOnFileFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<TagOnFileData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> TagOnFileDelete<'a> {
		TagOnFileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "TagOnFile".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<TagOnFileSetParam>) -> TagOnFileUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		TagOnFileUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: TagOnFileOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: TagOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: TagOnFileCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct TagOnFileFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<TagOnFileOrderByParam>,
	with_params: Vec<TagOnFileWithParam>,
}
impl<'a> TagOnFileFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<TagOnFileData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: TagOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: TagOnFileOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: TagOnFileCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct TagOnFileFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<TagOnFileWithParam>,
}
impl<'a> TagOnFileFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<TagOnFileData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> TagOnFileDelete<'a> {
		TagOnFileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "TagOnFile".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<TagOnFileSetParam>) -> TagOnFileUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		TagOnFileUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: TagOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct TagOnFileCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<TagOnFileWithParam>,
}
impl<'a> TagOnFileCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<TagOnFileData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: TagOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct TagOnFileUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<TagOnFileWithParam>,
}
impl<'a> TagOnFileUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<TagOnFileData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: TagOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct TagOnFileUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<TagOnFileWithParam>,
}
impl<'a> TagOnFileUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<TagOnFileData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: TagOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct TagOnFileUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> TagOnFileUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<TagOnFileData> {
		self.query.perform().await
	}
	pub fn create(
		mut self,
		tag: TagOnFileLinkTag,
		file: TagOnFileLinkFile,
		params: Vec<TagOnFileSetParam>,
	) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(TagOnFileSetParam::from(tag).to_field());
		input_fields.push(TagOnFileSetParam::from(file).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<TagOnFileSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct TagOnFileDelete<'a> {
	query: Query<'a>,
}
impl<'a> TagOnFileDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct TagOnFileActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> TagOnFileActions<'a> {
	pub fn find_unique(&self, param: TagOnFileWhereUniqueParam) -> TagOnFileFindUnique {
		let param: TagOnFileWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "TagOnFile".into(),
			outputs: tag_on_file_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		TagOnFileFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<TagOnFileWhereParam>) -> TagOnFileFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "TagOnFile".into(),
			outputs: tag_on_file_outputs(),
			inputs,
		};
		TagOnFileFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<TagOnFileWhereParam>) -> TagOnFileFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "TagOnFile".into(),
			outputs: tag_on_file_outputs(),
			inputs,
		};
		TagOnFileFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		tag: TagOnFileLinkTag,
		file: TagOnFileLinkFile,
		params: Vec<TagOnFileSetParam>,
	) -> TagOnFileCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(TagOnFileSetParam::from(tag).to_field());
		input_fields.push(TagOnFileSetParam::from(file).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "TagOnFile".into(),
			outputs: tag_on_file_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		TagOnFileCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: TagOnFileWhereUniqueParam) -> TagOnFileUpsertOne {
		let param: TagOnFileWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "TagOnFile".into(),
			outputs: tag_on_file_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		TagOnFileUpsertOne { query }
	}
}
fn label_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("date_created"),
		Output::new("date_modified"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LabelData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "name")]
	pub name: Option<String>,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "label_files")]
	label_files: Option<Vec<LabelOnFileData>>,
}
impl LabelData {
	pub fn label_files(&self) -> Result<&Vec<LabelOnFileData>, String> {
		match self . label_files . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access label_files but did not fetch it using the .with() syntax" . to_string ()) , }
	}
}
pub struct Label;
impl Label {
	pub fn id() -> LabelIdField {
		LabelIdField {}
	}
	pub fn name() -> LabelNameField {
		LabelNameField {}
	}
	pub fn date_created() -> LabelDateCreatedField {
		LabelDateCreatedField {}
	}
	pub fn date_modified() -> LabelDateModifiedField {
		LabelDateModifiedField {}
	}
	pub fn label_files() -> LabelLabelFilesField {
		LabelLabelFilesField {}
	}
}
pub struct LabelIdField {}
impl LabelIdField {
	pub fn set<T: From<LabelSetId>>(&self, value: i32) -> T {
		LabelSetId(value).into()
	}
	pub fn equals<T: From<LabelWhereUniqueParam>>(&self, value: i32) -> T {
		LabelWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LabelOrderByParam {
		LabelOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LabelCursor {
		LabelCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> LabelSetParam {
		LabelSetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> LabelSetParam {
		LabelSetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> LabelSetParam {
		LabelSetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> LabelSetParam {
		LabelSetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LabelWhereParam {
		LabelWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LabelWhereParam {
		LabelWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LabelWhereParam {
		LabelWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> LabelWhereParam {
		LabelWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> LabelWhereParam {
		LabelWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> LabelWhereParam {
		LabelWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> LabelWhereParam {
		LabelWhereParam::IdNot(value)
	}
}
pub struct LabelSetId(i32);
impl From<LabelSetId> for LabelSetParam {
	fn from(value: LabelSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct LabelNameField {}
impl LabelNameField {
	pub fn set<T: From<LabelSetName>>(&self, value: String) -> T {
		LabelSetName(value).into()
	}
	pub fn equals(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LabelOrderByParam {
		LabelOrderByParam::Name(direction)
	}
	pub fn cursor(&self, cursor: String) -> LabelCursor {
		LabelCursor::Name(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> LabelWhereParam {
		LabelWhereParam::NameInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> LabelWhereParam {
		LabelWhereParam::NameNotInVec(value)
	}
	pub fn lt(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameLt(value)
	}
	pub fn lte(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameLte(value)
	}
	pub fn gt(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameGt(value)
	}
	pub fn gte(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameGte(value)
	}
	pub fn contains(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameContains(value)
	}
	pub fn starts_with(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameEndsWith(value)
	}
	pub fn not(&self, value: String) -> LabelWhereParam {
		LabelWhereParam::NameNot(value)
	}
}
pub struct LabelSetName(String);
impl From<LabelSetName> for LabelSetParam {
	fn from(value: LabelSetName) -> Self {
		Self::SetName(value.0)
	}
}
pub struct LabelDateCreatedField {}
impl LabelDateCreatedField {
	pub fn set<T: From<LabelSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		LabelSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LabelOrderByParam {
		LabelOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> LabelCursor {
		LabelCursor::DateCreated(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> LabelWhereParam {
		LabelWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateCreatedNot(value)
	}
}
pub struct LabelSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<LabelSetDateCreated> for LabelSetParam {
	fn from(value: LabelSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct LabelDateModifiedField {}
impl LabelDateModifiedField {
	pub fn set<T: From<LabelSetDateModified>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		LabelSetDateModified(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LabelOrderByParam {
		LabelOrderByParam::DateModified(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> LabelCursor {
		LabelCursor::DateModified(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> LabelWhereParam {
		LabelWhereParam::DateModifiedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> LabelWhereParam {
		LabelWhereParam::DateModifiedNot(value)
	}
}
pub struct LabelSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<LabelSetDateModified> for LabelSetParam {
	fn from(value: LabelSetDateModified) -> Self {
		Self::SetDateModified(value.0)
	}
}
pub struct LabelLabelFilesField {}
impl LabelLabelFilesField {
	pub fn some(&self, value: Vec<LabelOnFileWhereParam>) -> LabelWhereParam {
		LabelWhereParam::LabelFilesSome(value)
	}
	pub fn every(&self, value: Vec<LabelOnFileWhereParam>) -> LabelWhereParam {
		LabelWhereParam::LabelFilesEvery(value)
	}
	pub fn fetch(&self, params: Vec<LabelOnFileWhereParam>) -> LabelWithParam {
		LabelWithParam::LabelFiles(params)
	}
	pub fn link<T: From<LabelLinkLabelFiles>>(
		&self,
		params: Vec<LabelOnFileWhereUniqueParam>,
	) -> T {
		LabelLinkLabelFiles(params).into()
	}
	pub fn unlink(&self, params: Vec<LabelOnFileWhereUniqueParam>) -> LabelSetParam {
		LabelSetParam::UnLinkLabelFiles(params)
	}
}
pub struct LabelLinkLabelFiles(Vec<LabelOnFileWhereUniqueParam>);
impl From<LabelLinkLabelFiles> for LabelSetParam {
	fn from(value: LabelLinkLabelFiles) -> Self {
		Self::LinkLabelFiles(value.0)
	}
}
pub enum LabelWithParam {
	LabelFiles(Vec<LabelOnFileWhereParam>),
}
impl LabelWithParam {
	pub fn to_output(self) -> Output {
		match self {
			Self::LabelFiles(where_params) => Output {
				name: "label_files".into(),
				outputs: label_on_file_outputs(),
				inputs: if where_params.len() > 0 {
					vec![Input {
						name: "where".into(),
						fields: where_params
							.into_iter()
							.map(|param| {
								Into::<LabelOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
						..Default::default()
					}]
				} else {
					vec![]
				},
				..Default::default()
			},
		}
	}
}
pub enum LabelSetParam {
	SetId(i32),
	SetName(String),
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	SetDateModified(chrono::DateTime<chrono::Utc>),
	LinkLabelFiles(Vec<LabelOnFileWhereUniqueParam>),
	UnLinkLabelFiles(Vec<LabelOnFileWhereUniqueParam>),
}
impl LabelSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetName(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkLabelFiles(where_params) => Field {
				name: "label_files".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<LabelOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					list: true,
					wrap_list: true,
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkLabelFiles(where_params) => Field {
				name: "label_files".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					list: true,
					wrap_list: true,
					fields: Some(transform_equals(
						where_params
							.into_iter()
							.map(|param| {
								Into::<LabelOnFileWhereParam>::into(param).to_field()
							})
							.collect(),
					)),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum LabelOrderByParam {
	Id(Direction),
	Name(Direction),
	DateCreated(Direction),
	DateModified(Direction),
}
impl LabelOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Name(direction) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateModified(direction) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum LabelCursor {
	Id(i32),
	Name(String),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
}
impl LabelCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum LabelWhereParam {
	Not(Vec<LabelWhereParam>),
	Or(Vec<LabelWhereParam>),
	And(Vec<LabelWhereParam>),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	NameEquals(String),
	NameInVec(Vec<String>),
	NameNotInVec(Vec<String>),
	NameLt(String),
	NameLte(String),
	NameGt(String),
	NameGte(String),
	NameContains(String),
	NameStartsWith(String),
	NameEndsWith(String),
	NameNot(String),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedLt(chrono::DateTime<chrono::Utc>),
	DateModifiedLte(chrono::DateTime<chrono::Utc>),
	DateModifiedGt(chrono::DateTime<chrono::Utc>),
	DateModifiedGte(chrono::DateTime<chrono::Utc>),
	DateModifiedNot(chrono::DateTime<chrono::Utc>),
	LabelFilesSome(Vec<LabelOnFileWhereParam>),
	LabelFilesEvery(Vec<LabelOnFileWhereParam>),
}
impl LabelWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNotInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameStartsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEndsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNot(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNotInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNot(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelFilesSome(value) => Field {
				name: "label_files".into(),
				fields: Some(vec![Field {
					name: "some".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelFilesEvery(value) => Field {
				name: "label_files".into(),
				fields: Some(vec![Field {
					name: "every".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum LabelWhereUniqueParam {
	IdEquals(i32),
}
impl From<LabelWhereUniqueParam> for LabelWhereParam {
	fn from(value: LabelWhereUniqueParam) -> Self {
		match value {
			LabelWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
		}
	}
}
impl From<Operator<Self>> for LabelWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct LabelFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<LabelOrderByParam>,
	with_params: Vec<LabelWithParam>,
}
impl<'a> LabelFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<LabelData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> LabelDelete<'a> {
		LabelDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Label".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LabelSetParam>) -> LabelUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LabelUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: LabelOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: LabelWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: LabelCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct LabelFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<LabelOrderByParam>,
	with_params: Vec<LabelWithParam>,
}
impl<'a> LabelFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<LabelData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: LabelWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: LabelOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: LabelCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct LabelFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<LabelWithParam>,
}
impl<'a> LabelFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<LabelData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> LabelDelete<'a> {
		LabelDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Label".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<LabelSetParam>) -> LabelUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LabelUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: LabelWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LabelCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<LabelWithParam>,
}
impl<'a> LabelCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<LabelData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: LabelWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LabelUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<LabelWithParam>,
}
impl<'a> LabelUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<LabelData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: LabelWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LabelUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<LabelWithParam>,
}
impl<'a> LabelUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<LabelData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: LabelWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LabelUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> LabelUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<LabelData> {
		self.query.perform().await
	}
	pub fn create(mut self, params: Vec<LabelSetParam>) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<LabelSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct LabelDelete<'a> {
	query: Query<'a>,
}
impl<'a> LabelDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct LabelActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> LabelActions<'a> {
	pub fn find_unique(&self, param: LabelWhereUniqueParam) -> LabelFindUnique {
		let param: LabelWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Label".into(),
			outputs: label_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LabelFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<LabelWhereParam>) -> LabelFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Label".into(),
			outputs: label_outputs(),
			inputs,
		};
		LabelFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<LabelWhereParam>) -> LabelFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Label".into(),
			outputs: label_outputs(),
			inputs,
		};
		LabelFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(&self, params: Vec<LabelSetParam>) -> LabelCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Label".into(),
			outputs: label_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		LabelCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: LabelWhereUniqueParam) -> LabelUpsertOne {
		let param: LabelWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "Label".into(),
			outputs: label_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LabelUpsertOne { query }
	}
}
fn label_on_file_outputs() -> Vec<Output> {
	vec![
		Output::new("date_created"),
		Output::new("label_id"),
		Output::new("file_id"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LabelOnFileData {
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "label_id")]
	pub label_id: i32,
	#[serde(rename = "label")]
	label: Option<Box<LabelData>>,
	#[serde(rename = "file_id")]
	pub file_id: i32,
	#[serde(rename = "file")]
	file: Option<Box<FileData>>,
}
impl LabelOnFileData {
	pub fn label(&self) -> Result<&LabelData, String> {
		match self.label.as_ref() {
			Some(v) => Ok(v),
			None => Err(
				"Attempted to access label but did not fetch it using the .with() syntax"
					.to_string(),
			),
		}
	}
	pub fn file(&self) -> Result<&FileData, String> {
		match self.file.as_ref() {
			Some(v) => Ok(v),
			None => Err(
				"Attempted to access file but did not fetch it using the .with() syntax"
					.to_string(),
			),
		}
	}
}
pub struct LabelOnFile;
impl LabelOnFile {
	pub fn label_id_file_id<T: From<LabelOnFileWhereUniqueParam>>(
		label_id: i32,
		file_id: i32,
	) -> T {
		LabelOnFileWhereUniqueParam::LabelIdFileIdEquals(label_id, file_id).into()
	}
	pub fn date_created() -> LabelOnFileDateCreatedField {
		LabelOnFileDateCreatedField {}
	}
	pub fn label_id() -> LabelOnFileLabelIdField {
		LabelOnFileLabelIdField {}
	}
	pub fn label() -> LabelOnFileLabelField {
		LabelOnFileLabelField {}
	}
	pub fn file_id() -> LabelOnFileFileIdField {
		LabelOnFileFileIdField {}
	}
	pub fn file() -> LabelOnFileFileField {
		LabelOnFileFileField {}
	}
}
pub struct LabelOnFileDateCreatedField {}
impl LabelOnFileDateCreatedField {
	pub fn set<T: From<LabelOnFileSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		LabelOnFileSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LabelOnFileOrderByParam {
		LabelOnFileOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> LabelOnFileCursor {
		LabelOnFileCursor::DateCreated(cursor)
	}
	pub fn in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::DateCreatedNot(value)
	}
}
pub struct LabelOnFileSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<LabelOnFileSetDateCreated> for LabelOnFileSetParam {
	fn from(value: LabelOnFileSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct LabelOnFileLabelIdField {}
impl LabelOnFileLabelIdField {
	pub fn set<T: From<LabelOnFileSetLabelId>>(&self, value: i32) -> T {
		LabelOnFileSetLabelId(value).into()
	}
	pub fn equals(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LabelOnFileOrderByParam {
		LabelOnFileOrderByParam::LabelId(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LabelOnFileCursor {
		LabelOnFileCursor::LabelId(cursor)
	}
	pub fn increment(&self, value: i32) -> LabelOnFileSetParam {
		LabelOnFileSetParam::SetLabelId(value)
	}
	pub fn decrement(&self, value: i32) -> LabelOnFileSetParam {
		LabelOnFileSetParam::SetLabelId(value)
	}
	pub fn multiply(&self, value: i32) -> LabelOnFileSetParam {
		LabelOnFileSetParam::SetLabelId(value)
	}
	pub fn divide(&self, value: i32) -> LabelOnFileSetParam {
		LabelOnFileSetParam::SetLabelId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdLt(value)
	}
	pub fn lte(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdLte(value)
	}
	pub fn gt(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdGt(value)
	}
	pub fn gte(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdGte(value)
	}
	pub fn not(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIdNot(value)
	}
}
pub struct LabelOnFileSetLabelId(i32);
impl From<LabelOnFileSetLabelId> for LabelOnFileSetParam {
	fn from(value: LabelOnFileSetLabelId) -> Self {
		Self::SetLabelId(value.0)
	}
}
pub struct LabelOnFileLabelField {}
impl LabelOnFileLabelField {
	pub fn is(&self, value: Vec<LabelWhereParam>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::LabelIs(value)
	}
	pub fn fetch(&self) -> LabelOnFileWithParam {
		LabelOnFileWithParam::Label
	}
	pub fn link<T: From<LabelOnFileLinkLabel>>(&self, value: LabelWhereUniqueParam) -> T {
		LabelOnFileLinkLabel(value).into()
	}
}
pub struct LabelOnFileLinkLabel(LabelWhereUniqueParam);
impl From<LabelOnFileLinkLabel> for LabelOnFileSetParam {
	fn from(value: LabelOnFileLinkLabel) -> Self {
		Self::LinkLabel(value.0)
	}
}
pub struct LabelOnFileFileIdField {}
impl LabelOnFileFileIdField {
	pub fn set<T: From<LabelOnFileSetFileId>>(&self, value: i32) -> T {
		LabelOnFileSetFileId(value).into()
	}
	pub fn equals(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> LabelOnFileOrderByParam {
		LabelOnFileOrderByParam::FileId(direction)
	}
	pub fn cursor(&self, cursor: i32) -> LabelOnFileCursor {
		LabelOnFileCursor::FileId(cursor)
	}
	pub fn increment(&self, value: i32) -> LabelOnFileSetParam {
		LabelOnFileSetParam::SetFileId(value)
	}
	pub fn decrement(&self, value: i32) -> LabelOnFileSetParam {
		LabelOnFileSetParam::SetFileId(value)
	}
	pub fn multiply(&self, value: i32) -> LabelOnFileSetParam {
		LabelOnFileSetParam::SetFileId(value)
	}
	pub fn divide(&self, value: i32) -> LabelOnFileSetParam {
		LabelOnFileSetParam::SetFileId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdLt(value)
	}
	pub fn lte(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdLte(value)
	}
	pub fn gt(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdGt(value)
	}
	pub fn gte(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdGte(value)
	}
	pub fn not(&self, value: i32) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIdNot(value)
	}
}
pub struct LabelOnFileSetFileId(i32);
impl From<LabelOnFileSetFileId> for LabelOnFileSetParam {
	fn from(value: LabelOnFileSetFileId) -> Self {
		Self::SetFileId(value.0)
	}
}
pub struct LabelOnFileFileField {}
impl LabelOnFileFileField {
	pub fn is(&self, value: Vec<FileWhereParam>) -> LabelOnFileWhereParam {
		LabelOnFileWhereParam::FileIs(value)
	}
	pub fn fetch(&self) -> LabelOnFileWithParam {
		LabelOnFileWithParam::File
	}
	pub fn link<T: From<LabelOnFileLinkFile>>(&self, value: FileWhereUniqueParam) -> T {
		LabelOnFileLinkFile(value).into()
	}
}
pub struct LabelOnFileLinkFile(FileWhereUniqueParam);
impl From<LabelOnFileLinkFile> for LabelOnFileSetParam {
	fn from(value: LabelOnFileLinkFile) -> Self {
		Self::LinkFile(value.0)
	}
}
pub enum LabelOnFileWithParam {
	Label,
	File,
}
impl LabelOnFileWithParam {
	pub fn to_output(self) -> Output {
		match self {
			Self::Label => Output {
				name: "label".into(),
				outputs: label_outputs(),
				..Default::default()
			},
			Self::File => Output {
				name: "file".into(),
				outputs: file_outputs(),
				..Default::default()
			},
		}
	}
}
pub enum LabelOnFileSetParam {
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	SetLabelId(i32),
	LinkLabel(LabelWhereUniqueParam),
	SetFileId(i32),
	LinkFile(FileWhereUniqueParam),
}
impl LabelOnFileSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetLabelId(value) => Field {
				name: "label_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkLabel(where_param) => Field {
				name: "label".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![Into::<LabelWhereParam>::into(
						where_param,
					)
					.to_field()])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SetFileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFile(where_param) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![Into::<FileWhereParam>::into(
						where_param,
					)
					.to_field()])),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum LabelOnFileOrderByParam {
	DateCreated(Direction),
	LabelId(Direction),
	FileId(Direction),
}
impl LabelOnFileOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::LabelId(direction) => Field {
				name: "label_id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::FileId(direction) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum LabelOnFileCursor {
	DateCreated(chrono::DateTime<chrono::Utc>),
	LabelId(i32),
	FileId(i32),
}
impl LabelOnFileCursor {
	fn to_field(self) -> Field {
		match self {
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LabelId(value) => Field {
				name: "label_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::FileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum LabelOnFileWhereParam {
	Not(Vec<LabelOnFileWhereParam>),
	Or(Vec<LabelOnFileWhereParam>),
	And(Vec<LabelOnFileWhereParam>),
	LabelIdFileIdEquals(i32, i32),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	LabelIdEquals(i32),
	LabelIdInVec(Vec<i32>),
	LabelIdNotInVec(Vec<i32>),
	LabelIdLt(i32),
	LabelIdLte(i32),
	LabelIdGt(i32),
	LabelIdGte(i32),
	LabelIdNot(i32),
	LabelIs(Vec<LabelWhereParam>),
	FileIdEquals(i32),
	FileIdInVec(Vec<i32>),
	FileIdNotInVec(Vec<i32>),
	FileIdLt(i32),
	FileIdLte(i32),
	FileIdGt(i32),
	FileIdGte(i32),
	FileIdNot(i32),
	FileIs(Vec<FileWhereParam>),
}
impl LabelOnFileWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::LabelIdFileIdEquals(label_id, file_id) => Field {
				name: "label_id_file_id".into(),
				fields: Some(transform_equals(
					vec![
						LabelOnFileWhereParam::LabelIdEquals(label_id),
						LabelOnFileWhereParam::FileIdEquals(file_id),
					]
					.into_iter()
					.map(|f| f.to_field())
					.collect(),
				)),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdEquals(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdInVec(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdNotInVec(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdLt(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdLte(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdGt(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdGte(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIdNot(value) => Field {
				name: "label_id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LabelIs(value) => Field {
				name: "label".into(),
				fields: Some(vec![Field {
					name: "is".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdEquals(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdInVec(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdNotInVec(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLt(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLte(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGt(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGte(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdNot(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIs(value) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "is".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum LabelOnFileWhereUniqueParam {
	LabelIdFileIdEquals(i32, i32),
}
impl From<LabelOnFileWhereUniqueParam> for LabelOnFileWhereParam {
	fn from(value: LabelOnFileWhereUniqueParam) -> Self {
		match value {
			LabelOnFileWhereUniqueParam::LabelIdFileIdEquals(label_id, file_id) => {
				Self::LabelIdFileIdEquals(label_id, file_id)
			},
		}
	}
}
impl From<Operator<Self>> for LabelOnFileWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct LabelOnFileFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<LabelOnFileOrderByParam>,
	with_params: Vec<LabelOnFileWithParam>,
}
impl<'a> LabelOnFileFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<LabelOnFileData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> LabelOnFileDelete<'a> {
		LabelOnFileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "LabelOnFile".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(
		mut self,
		params: Vec<LabelOnFileSetParam>,
	) -> LabelOnFileUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LabelOnFileUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: LabelOnFileOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: LabelOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: LabelOnFileCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct LabelOnFileFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<LabelOnFileOrderByParam>,
	with_params: Vec<LabelOnFileWithParam>,
}
impl<'a> LabelOnFileFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<LabelOnFileData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: LabelOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: LabelOnFileOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: LabelOnFileCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct LabelOnFileFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<LabelOnFileWithParam>,
}
impl<'a> LabelOnFileFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<LabelOnFileData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> LabelOnFileDelete<'a> {
		LabelOnFileDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "LabelOnFile".into(),
				..self.query
			},
		}
	}
	pub fn update(
		mut self,
		params: Vec<LabelOnFileSetParam>,
	) -> LabelOnFileUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		LabelOnFileUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: LabelOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LabelOnFileCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<LabelOnFileWithParam>,
}
impl<'a> LabelOnFileCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<LabelOnFileData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: LabelOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LabelOnFileUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<LabelOnFileWithParam>,
}
impl<'a> LabelOnFileUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<LabelOnFileData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: LabelOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LabelOnFileUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<LabelOnFileWithParam>,
}
impl<'a> LabelOnFileUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<LabelOnFileData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: LabelOnFileWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct LabelOnFileUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> LabelOnFileUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<LabelOnFileData> {
		self.query.perform().await
	}
	pub fn create(
		mut self,
		label: LabelOnFileLinkLabel,
		file: LabelOnFileLinkFile,
		params: Vec<LabelOnFileSetParam>,
	) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(LabelOnFileSetParam::from(label).to_field());
		input_fields.push(LabelOnFileSetParam::from(file).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<LabelOnFileSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct LabelOnFileDelete<'a> {
	query: Query<'a>,
}
impl<'a> LabelOnFileDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct LabelOnFileActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> LabelOnFileActions<'a> {
	pub fn find_unique(
		&self,
		param: LabelOnFileWhereUniqueParam,
	) -> LabelOnFileFindUnique {
		let param: LabelOnFileWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "LabelOnFile".into(),
			outputs: label_on_file_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LabelOnFileFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<LabelOnFileWhereParam>) -> LabelOnFileFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "LabelOnFile".into(),
			outputs: label_on_file_outputs(),
			inputs,
		};
		LabelOnFileFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<LabelOnFileWhereParam>) -> LabelOnFileFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "LabelOnFile".into(),
			outputs: label_on_file_outputs(),
			inputs,
		};
		LabelOnFileFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		label: LabelOnFileLinkLabel,
		file: LabelOnFileLinkFile,
		params: Vec<LabelOnFileSetParam>,
	) -> LabelOnFileCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(LabelOnFileSetParam::from(label).to_field());
		input_fields.push(LabelOnFileSetParam::from(file).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "LabelOnFile".into(),
			outputs: label_on_file_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		LabelOnFileCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: LabelOnFileWhereUniqueParam) -> LabelOnFileUpsertOne {
		let param: LabelOnFileWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "LabelOnFile".into(),
			outputs: label_on_file_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		LabelOnFileUpsertOne { query }
	}
}
fn job_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("action"),
		Output::new("status"),
		Output::new("task_count"),
		Output::new("completed_task_count"),
		Output::new("date_created"),
		Output::new("date_modified"),
		Output::new("seconds_elapsed"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JobData {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "action")]
	pub action: i32,
	#[serde(rename = "status")]
	pub status: i32,
	#[serde(rename = "task_count")]
	pub task_count: i32,
	#[serde(rename = "completed_task_count")]
	pub completed_task_count: i32,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "seconds_elapsed")]
	pub seconds_elapsed: i32,
}
impl JobData {}
pub struct Job;
impl Job {
	pub fn id() -> JobIdField {
		JobIdField {}
	}
	pub fn action() -> JobActionField {
		JobActionField {}
	}
	pub fn status() -> JobStatusField {
		JobStatusField {}
	}
	pub fn task_count() -> JobTaskCountField {
		JobTaskCountField {}
	}
	pub fn completed_task_count() -> JobCompletedTaskCountField {
		JobCompletedTaskCountField {}
	}
	pub fn date_created() -> JobDateCreatedField {
		JobDateCreatedField {}
	}
	pub fn date_modified() -> JobDateModifiedField {
		JobDateModifiedField {}
	}
	pub fn seconds_elapsed() -> JobSecondsElapsedField {
		JobSecondsElapsedField {}
	}
}
pub struct JobIdField {}
impl JobIdField {
	pub fn set<T: From<JobSetId>>(&self, value: String) -> T {
		JobSetId(value).into()
	}
	pub fn equals<T: From<JobWhereUniqueParam>>(&self, value: String) -> T {
		JobWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> JobOrderByParam {
		JobOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: String) -> JobCursor {
		JobCursor::Id(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> JobWhereParam {
		JobWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> JobWhereParam {
		JobWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdGte(value)
	}
	pub fn contains(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdContains(value)
	}
	pub fn starts_with(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdEndsWith(value)
	}
	pub fn not(&self, value: String) -> JobWhereParam {
		JobWhereParam::IdNot(value)
	}
}
pub struct JobSetId(String);
impl From<JobSetId> for JobSetParam {
	fn from(value: JobSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct JobActionField {}
impl JobActionField {
	pub fn set<T: From<JobSetAction>>(&self, value: i32) -> T {
		JobSetAction(value).into()
	}
	pub fn equals(&self, value: i32) -> JobWhereParam {
		JobWhereParam::ActionEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> JobOrderByParam {
		JobOrderByParam::Action(direction)
	}
	pub fn cursor(&self, cursor: i32) -> JobCursor {
		JobCursor::Action(cursor)
	}
	pub fn increment(&self, value: i32) -> JobSetParam {
		JobSetParam::SetAction(value)
	}
	pub fn decrement(&self, value: i32) -> JobSetParam {
		JobSetParam::SetAction(value)
	}
	pub fn multiply(&self, value: i32) -> JobSetParam {
		JobSetParam::SetAction(value)
	}
	pub fn divide(&self, value: i32) -> JobSetParam {
		JobSetParam::SetAction(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> JobWhereParam {
		JobWhereParam::ActionInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> JobWhereParam {
		JobWhereParam::ActionNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> JobWhereParam {
		JobWhereParam::ActionLt(value)
	}
	pub fn lte(&self, value: i32) -> JobWhereParam {
		JobWhereParam::ActionLte(value)
	}
	pub fn gt(&self, value: i32) -> JobWhereParam {
		JobWhereParam::ActionGt(value)
	}
	pub fn gte(&self, value: i32) -> JobWhereParam {
		JobWhereParam::ActionGte(value)
	}
	pub fn not(&self, value: i32) -> JobWhereParam {
		JobWhereParam::ActionNot(value)
	}
}
pub struct JobSetAction(i32);
impl From<JobSetAction> for JobSetParam {
	fn from(value: JobSetAction) -> Self {
		Self::SetAction(value.0)
	}
}
pub struct JobStatusField {}
impl JobStatusField {
	pub fn set<T: From<JobSetStatus>>(&self, value: i32) -> T {
		JobSetStatus(value).into()
	}
	pub fn equals(&self, value: i32) -> JobWhereParam {
		JobWhereParam::StatusEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> JobOrderByParam {
		JobOrderByParam::Status(direction)
	}
	pub fn cursor(&self, cursor: i32) -> JobCursor {
		JobCursor::Status(cursor)
	}
	pub fn increment(&self, value: i32) -> JobSetParam {
		JobSetParam::SetStatus(value)
	}
	pub fn decrement(&self, value: i32) -> JobSetParam {
		JobSetParam::SetStatus(value)
	}
	pub fn multiply(&self, value: i32) -> JobSetParam {
		JobSetParam::SetStatus(value)
	}
	pub fn divide(&self, value: i32) -> JobSetParam {
		JobSetParam::SetStatus(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> JobWhereParam {
		JobWhereParam::StatusInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> JobWhereParam {
		JobWhereParam::StatusNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> JobWhereParam {
		JobWhereParam::StatusLt(value)
	}
	pub fn lte(&self, value: i32) -> JobWhereParam {
		JobWhereParam::StatusLte(value)
	}
	pub fn gt(&self, value: i32) -> JobWhereParam {
		JobWhereParam::StatusGt(value)
	}
	pub fn gte(&self, value: i32) -> JobWhereParam {
		JobWhereParam::StatusGte(value)
	}
	pub fn not(&self, value: i32) -> JobWhereParam {
		JobWhereParam::StatusNot(value)
	}
}
pub struct JobSetStatus(i32);
impl From<JobSetStatus> for JobSetParam {
	fn from(value: JobSetStatus) -> Self {
		Self::SetStatus(value.0)
	}
}
pub struct JobTaskCountField {}
impl JobTaskCountField {
	pub fn set<T: From<JobSetTaskCount>>(&self, value: i32) -> T {
		JobSetTaskCount(value).into()
	}
	pub fn equals(&self, value: i32) -> JobWhereParam {
		JobWhereParam::TaskCountEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> JobOrderByParam {
		JobOrderByParam::TaskCount(direction)
	}
	pub fn cursor(&self, cursor: i32) -> JobCursor {
		JobCursor::TaskCount(cursor)
	}
	pub fn increment(&self, value: i32) -> JobSetParam {
		JobSetParam::SetTaskCount(value)
	}
	pub fn decrement(&self, value: i32) -> JobSetParam {
		JobSetParam::SetTaskCount(value)
	}
	pub fn multiply(&self, value: i32) -> JobSetParam {
		JobSetParam::SetTaskCount(value)
	}
	pub fn divide(&self, value: i32) -> JobSetParam {
		JobSetParam::SetTaskCount(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> JobWhereParam {
		JobWhereParam::TaskCountInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> JobWhereParam {
		JobWhereParam::TaskCountNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> JobWhereParam {
		JobWhereParam::TaskCountLt(value)
	}
	pub fn lte(&self, value: i32) -> JobWhereParam {
		JobWhereParam::TaskCountLte(value)
	}
	pub fn gt(&self, value: i32) -> JobWhereParam {
		JobWhereParam::TaskCountGt(value)
	}
	pub fn gte(&self, value: i32) -> JobWhereParam {
		JobWhereParam::TaskCountGte(value)
	}
	pub fn not(&self, value: i32) -> JobWhereParam {
		JobWhereParam::TaskCountNot(value)
	}
}
pub struct JobSetTaskCount(i32);
impl From<JobSetTaskCount> for JobSetParam {
	fn from(value: JobSetTaskCount) -> Self {
		Self::SetTaskCount(value.0)
	}
}
pub struct JobCompletedTaskCountField {}
impl JobCompletedTaskCountField {
	pub fn set<T: From<JobSetCompletedTaskCount>>(&self, value: i32) -> T {
		JobSetCompletedTaskCount(value).into()
	}
	pub fn equals(&self, value: i32) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> JobOrderByParam {
		JobOrderByParam::CompletedTaskCount(direction)
	}
	pub fn cursor(&self, cursor: i32) -> JobCursor {
		JobCursor::CompletedTaskCount(cursor)
	}
	pub fn increment(&self, value: i32) -> JobSetParam {
		JobSetParam::SetCompletedTaskCount(value)
	}
	pub fn decrement(&self, value: i32) -> JobSetParam {
		JobSetParam::SetCompletedTaskCount(value)
	}
	pub fn multiply(&self, value: i32) -> JobSetParam {
		JobSetParam::SetCompletedTaskCount(value)
	}
	pub fn divide(&self, value: i32) -> JobSetParam {
		JobSetParam::SetCompletedTaskCount(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountLt(value)
	}
	pub fn lte(&self, value: i32) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountLte(value)
	}
	pub fn gt(&self, value: i32) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountGt(value)
	}
	pub fn gte(&self, value: i32) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountGte(value)
	}
	pub fn not(&self, value: i32) -> JobWhereParam {
		JobWhereParam::CompletedTaskCountNot(value)
	}
}
pub struct JobSetCompletedTaskCount(i32);
impl From<JobSetCompletedTaskCount> for JobSetParam {
	fn from(value: JobSetCompletedTaskCount) -> Self {
		Self::SetCompletedTaskCount(value.0)
	}
}
pub struct JobDateCreatedField {}
impl JobDateCreatedField {
	pub fn set<T: From<JobSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		JobSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> JobOrderByParam {
		JobOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> JobCursor {
		JobCursor::DateCreated(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> JobWhereParam {
		JobWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> JobWhereParam {
		JobWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateCreatedNot(value)
	}
}
pub struct JobSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<JobSetDateCreated> for JobSetParam {
	fn from(value: JobSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct JobDateModifiedField {}
impl JobDateModifiedField {
	pub fn set<T: From<JobSetDateModified>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		JobSetDateModified(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateModifiedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> JobOrderByParam {
		JobOrderByParam::DateModified(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> JobCursor {
		JobCursor::DateModified(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> JobWhereParam {
		JobWhereParam::DateModifiedInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> JobWhereParam {
		JobWhereParam::DateModifiedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateModifiedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateModifiedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateModifiedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateModifiedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> JobWhereParam {
		JobWhereParam::DateModifiedNot(value)
	}
}
pub struct JobSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<JobSetDateModified> for JobSetParam {
	fn from(value: JobSetDateModified) -> Self {
		Self::SetDateModified(value.0)
	}
}
pub struct JobSecondsElapsedField {}
impl JobSecondsElapsedField {
	pub fn set<T: From<JobSetSecondsElapsed>>(&self, value: i32) -> T {
		JobSetSecondsElapsed(value).into()
	}
	pub fn equals(&self, value: i32) -> JobWhereParam {
		JobWhereParam::SecondsElapsedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> JobOrderByParam {
		JobOrderByParam::SecondsElapsed(direction)
	}
	pub fn cursor(&self, cursor: i32) -> JobCursor {
		JobCursor::SecondsElapsed(cursor)
	}
	pub fn increment(&self, value: i32) -> JobSetParam {
		JobSetParam::SetSecondsElapsed(value)
	}
	pub fn decrement(&self, value: i32) -> JobSetParam {
		JobSetParam::SetSecondsElapsed(value)
	}
	pub fn multiply(&self, value: i32) -> JobSetParam {
		JobSetParam::SetSecondsElapsed(value)
	}
	pub fn divide(&self, value: i32) -> JobSetParam {
		JobSetParam::SetSecondsElapsed(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> JobWhereParam {
		JobWhereParam::SecondsElapsedInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> JobWhereParam {
		JobWhereParam::SecondsElapsedNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> JobWhereParam {
		JobWhereParam::SecondsElapsedLt(value)
	}
	pub fn lte(&self, value: i32) -> JobWhereParam {
		JobWhereParam::SecondsElapsedLte(value)
	}
	pub fn gt(&self, value: i32) -> JobWhereParam {
		JobWhereParam::SecondsElapsedGt(value)
	}
	pub fn gte(&self, value: i32) -> JobWhereParam {
		JobWhereParam::SecondsElapsedGte(value)
	}
	pub fn not(&self, value: i32) -> JobWhereParam {
		JobWhereParam::SecondsElapsedNot(value)
	}
}
pub struct JobSetSecondsElapsed(i32);
impl From<JobSetSecondsElapsed> for JobSetParam {
	fn from(value: JobSetSecondsElapsed) -> Self {
		Self::SetSecondsElapsed(value.0)
	}
}
pub enum JobWithParam {}
impl JobWithParam {
	pub fn to_output(self) -> Output {
		match self {}
	}
}
pub enum JobSetParam {
	SetId(String),
	SetAction(i32),
	SetStatus(i32),
	SetTaskCount(i32),
	SetCompletedTaskCount(i32),
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	SetDateModified(chrono::DateTime<chrono::Utc>),
	SetSecondsElapsed(i32),
}
impl JobSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetAction(value) => Field {
				name: "action".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetStatus(value) => Field {
				name: "status".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetTaskCount(value) => Field {
				name: "task_count".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetCompletedTaskCount(value) => Field {
				name: "completed_task_count".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetSecondsElapsed(value) => Field {
				name: "seconds_elapsed".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum JobOrderByParam {
	Id(Direction),
	Action(Direction),
	Status(Direction),
	TaskCount(Direction),
	CompletedTaskCount(Direction),
	DateCreated(Direction),
	DateModified(Direction),
	SecondsElapsed(Direction),
}
impl JobOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Action(direction) => Field {
				name: "action".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Status(direction) => Field {
				name: "status".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::TaskCount(direction) => Field {
				name: "task_count".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::CompletedTaskCount(direction) => Field {
				name: "completed_task_count".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateModified(direction) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::SecondsElapsed(direction) => Field {
				name: "seconds_elapsed".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum JobCursor {
	Id(String),
	Action(i32),
	Status(i32),
	TaskCount(i32),
	CompletedTaskCount(i32),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
	SecondsElapsed(i32),
}
impl JobCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Action(value) => Field {
				name: "action".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Status(value) => Field {
				name: "status".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::TaskCount(value) => Field {
				name: "task_count".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::CompletedTaskCount(value) => Field {
				name: "completed_task_count".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SecondsElapsed(value) => Field {
				name: "seconds_elapsed".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum JobWhereParam {
	Not(Vec<JobWhereParam>),
	Or(Vec<JobWhereParam>),
	And(Vec<JobWhereParam>),
	IdEquals(String),
	IdInVec(Vec<String>),
	IdNotInVec(Vec<String>),
	IdLt(String),
	IdLte(String),
	IdGt(String),
	IdGte(String),
	IdContains(String),
	IdStartsWith(String),
	IdEndsWith(String),
	IdNot(String),
	ActionEquals(i32),
	ActionInVec(Vec<i32>),
	ActionNotInVec(Vec<i32>),
	ActionLt(i32),
	ActionLte(i32),
	ActionGt(i32),
	ActionGte(i32),
	ActionNot(i32),
	StatusEquals(i32),
	StatusInVec(Vec<i32>),
	StatusNotInVec(Vec<i32>),
	StatusLt(i32),
	StatusLte(i32),
	StatusGt(i32),
	StatusGte(i32),
	StatusNot(i32),
	TaskCountEquals(i32),
	TaskCountInVec(Vec<i32>),
	TaskCountNotInVec(Vec<i32>),
	TaskCountLt(i32),
	TaskCountLte(i32),
	TaskCountGt(i32),
	TaskCountGte(i32),
	TaskCountNot(i32),
	CompletedTaskCountEquals(i32),
	CompletedTaskCountInVec(Vec<i32>),
	CompletedTaskCountNotInVec(Vec<i32>),
	CompletedTaskCountLt(i32),
	CompletedTaskCountLte(i32),
	CompletedTaskCountGt(i32),
	CompletedTaskCountGte(i32),
	CompletedTaskCountNot(i32),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedLt(chrono::DateTime<chrono::Utc>),
	DateModifiedLte(chrono::DateTime<chrono::Utc>),
	DateModifiedGt(chrono::DateTime<chrono::Utc>),
	DateModifiedGte(chrono::DateTime<chrono::Utc>),
	DateModifiedNot(chrono::DateTime<chrono::Utc>),
	SecondsElapsedEquals(i32),
	SecondsElapsedInVec(Vec<i32>),
	SecondsElapsedNotInVec(Vec<i32>),
	SecondsElapsedLt(i32),
	SecondsElapsedLte(i32),
	SecondsElapsedGt(i32),
	SecondsElapsedGte(i32),
	SecondsElapsedNot(i32),
}
impl JobWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdContains(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdStartsWith(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdEndsWith(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionEquals(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionInVec(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionNotInVec(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionLt(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionLte(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionGt(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionGte(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ActionNot(value) => Field {
				name: "action".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusEquals(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusInVec(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusNotInVec(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusLt(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusLte(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusGt(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusGte(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::StatusNot(value) => Field {
				name: "status".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountEquals(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountInVec(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountNotInVec(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountLt(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountLte(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountGt(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountGte(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::TaskCountNot(value) => Field {
				name: "task_count".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountEquals(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountInVec(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountNotInVec(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountLt(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountLte(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountGt(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountGte(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::CompletedTaskCountNot(value) => Field {
				name: "completed_task_count".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNotInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNot(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedEquals(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedInVec(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedNotInVec(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedLt(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedLte(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedGt(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedGte(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SecondsElapsedNot(value) => Field {
				name: "seconds_elapsed".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum JobWhereUniqueParam {
	IdEquals(String),
}
impl From<JobWhereUniqueParam> for JobWhereParam {
	fn from(value: JobWhereUniqueParam) -> Self {
		match value {
			JobWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
		}
	}
}
impl From<Operator<Self>> for JobWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct JobFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<JobOrderByParam>,
	with_params: Vec<JobWithParam>,
}
impl<'a> JobFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<JobData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> JobDelete<'a> {
		JobDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Job".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<JobSetParam>) -> JobUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		JobUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: JobOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: JobWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: JobCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct JobFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<JobOrderByParam>,
	with_params: Vec<JobWithParam>,
}
impl<'a> JobFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<JobData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: JobWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: JobOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: JobCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct JobFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<JobWithParam>,
}
impl<'a> JobFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<JobData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> JobDelete<'a> {
		JobDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Job".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<JobSetParam>) -> JobUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		JobUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: JobWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct JobCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<JobWithParam>,
}
impl<'a> JobCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<JobData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: JobWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct JobUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<JobWithParam>,
}
impl<'a> JobUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<JobData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: JobWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct JobUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<JobWithParam>,
}
impl<'a> JobUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<JobData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: JobWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct JobUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> JobUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<JobData> {
		self.query.perform().await
	}
	pub fn create(
		mut self,
		id: JobSetId,
		action: JobSetAction,
		params: Vec<JobSetParam>,
	) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(JobSetParam::from(id).to_field());
		input_fields.push(JobSetParam::from(action).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<JobSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct JobDelete<'a> {
	query: Query<'a>,
}
impl<'a> JobDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct JobActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> JobActions<'a> {
	pub fn find_unique(&self, param: JobWhereUniqueParam) -> JobFindUnique {
		let param: JobWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Job".into(),
			outputs: job_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		JobFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<JobWhereParam>) -> JobFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Job".into(),
			outputs: job_outputs(),
			inputs,
		};
		JobFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<JobWhereParam>) -> JobFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Job".into(),
			outputs: job_outputs(),
			inputs,
		};
		JobFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		id: JobSetId,
		action: JobSetAction,
		params: Vec<JobSetParam>,
	) -> JobCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(JobSetParam::from(id).to_field());
		input_fields.push(JobSetParam::from(action).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Job".into(),
			outputs: job_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		JobCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: JobWhereUniqueParam) -> JobUpsertOne {
		let param: JobWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "Job".into(),
			outputs: job_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		JobUpsertOne { query }
	}
}
fn space_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("encryption"),
		Output::new("date_created"),
		Output::new("date_modified"),
		Output::new("libraryId"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpaceData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "encryption")]
	pub encryption: Option<i32>,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "Library")]
	library: Option<Box<LibraryData>>,
	#[serde(rename = "libraryId")]
	pub library_id: Option<i32>,
}
impl SpaceData {
	pub fn library(&self) -> Result<&LibraryData, String> {
		match self . library . as_ref () { Some (v) => Ok (v) , None => Err ("Attempted to access library but did not fetch it using the .with() syntax" . to_string ()) , }
	}
}
pub struct Space;
impl Space {
	pub fn id() -> SpaceIdField {
		SpaceIdField {}
	}
	pub fn name() -> SpaceNameField {
		SpaceNameField {}
	}
	pub fn encryption() -> SpaceEncryptionField {
		SpaceEncryptionField {}
	}
	pub fn date_created() -> SpaceDateCreatedField {
		SpaceDateCreatedField {}
	}
	pub fn date_modified() -> SpaceDateModifiedField {
		SpaceDateModifiedField {}
	}
	pub fn library() -> SpaceLibraryField {
		SpaceLibraryField {}
	}
	pub fn library_id() -> SpaceLibraryIdField {
		SpaceLibraryIdField {}
	}
}
pub struct SpaceIdField {}
impl SpaceIdField {
	pub fn set<T: From<SpaceSetId>>(&self, value: i32) -> T {
		SpaceSetId(value).into()
	}
	pub fn equals<T: From<SpaceWhereUniqueParam>>(&self, value: i32) -> T {
		SpaceWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> SpaceOrderByParam {
		SpaceOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> SpaceCursor {
		SpaceCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> SpaceWhereParam {
		SpaceWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> SpaceWhereParam {
		SpaceWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::IdNot(value)
	}
}
pub struct SpaceSetId(i32);
impl From<SpaceSetId> for SpaceSetParam {
	fn from(value: SpaceSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct SpaceNameField {}
impl SpaceNameField {
	pub fn set<T: From<SpaceSetName>>(&self, value: String) -> T {
		SpaceSetName(value).into()
	}
	pub fn equals(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> SpaceOrderByParam {
		SpaceOrderByParam::Name(direction)
	}
	pub fn cursor(&self, cursor: String) -> SpaceCursor {
		SpaceCursor::Name(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> SpaceWhereParam {
		SpaceWhereParam::NameInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> SpaceWhereParam {
		SpaceWhereParam::NameNotInVec(value)
	}
	pub fn lt(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameLt(value)
	}
	pub fn lte(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameLte(value)
	}
	pub fn gt(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameGt(value)
	}
	pub fn gte(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameGte(value)
	}
	pub fn contains(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameContains(value)
	}
	pub fn starts_with(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameEndsWith(value)
	}
	pub fn not(&self, value: String) -> SpaceWhereParam {
		SpaceWhereParam::NameNot(value)
	}
}
pub struct SpaceSetName(String);
impl From<SpaceSetName> for SpaceSetParam {
	fn from(value: SpaceSetName) -> Self {
		Self::SetName(value.0)
	}
}
pub struct SpaceEncryptionField {}
impl SpaceEncryptionField {
	pub fn set<T: From<SpaceSetEncryption>>(&self, value: i32) -> T {
		SpaceSetEncryption(value).into()
	}
	pub fn equals(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> SpaceOrderByParam {
		SpaceOrderByParam::Encryption(direction)
	}
	pub fn cursor(&self, cursor: i32) -> SpaceCursor {
		SpaceCursor::Encryption(cursor)
	}
	pub fn increment(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetEncryption(value)
	}
	pub fn decrement(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetEncryption(value)
	}
	pub fn multiply(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetEncryption(value)
	}
	pub fn divide(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetEncryption(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionLt(value)
	}
	pub fn lte(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionLte(value)
	}
	pub fn gt(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionGt(value)
	}
	pub fn gte(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionGte(value)
	}
	pub fn not(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::EncryptionNot(value)
	}
}
pub struct SpaceSetEncryption(i32);
impl From<SpaceSetEncryption> for SpaceSetParam {
	fn from(value: SpaceSetEncryption) -> Self {
		Self::SetEncryption(value.0)
	}
}
pub struct SpaceDateCreatedField {}
impl SpaceDateCreatedField {
	pub fn set<T: From<SpaceSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		SpaceSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> SpaceOrderByParam {
		SpaceOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> SpaceCursor {
		SpaceCursor::DateCreated(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateCreatedNot(value)
	}
}
pub struct SpaceSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<SpaceSetDateCreated> for SpaceSetParam {
	fn from(value: SpaceSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct SpaceDateModifiedField {}
impl SpaceDateModifiedField {
	pub fn set<T: From<SpaceSetDateModified>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		SpaceSetDateModified(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> SpaceOrderByParam {
		SpaceOrderByParam::DateModified(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> SpaceCursor {
		SpaceCursor::DateModified(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> SpaceWhereParam {
		SpaceWhereParam::DateModifiedNot(value)
	}
}
pub struct SpaceSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<SpaceSetDateModified> for SpaceSetParam {
	fn from(value: SpaceSetDateModified) -> Self {
		Self::SetDateModified(value.0)
	}
}
pub struct SpaceLibraryField {}
impl SpaceLibraryField {
	pub fn is(&self, value: Vec<LibraryWhereParam>) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIs(value)
	}
	pub fn fetch(&self) -> SpaceWithParam {
		SpaceWithParam::Library
	}
	pub fn link<T: From<SpaceLinkLibrary>>(&self, value: LibraryWhereUniqueParam) -> T {
		SpaceLinkLibrary(value).into()
	}
	pub fn unlink(&self) -> SpaceSetParam {
		SpaceSetParam::UnLinkLibrary
	}
}
pub struct SpaceLinkLibrary(LibraryWhereUniqueParam);
impl From<SpaceLinkLibrary> for SpaceSetParam {
	fn from(value: SpaceLinkLibrary) -> Self {
		Self::LinkLibrary(value.0)
	}
}
pub struct SpaceLibraryIdField {}
impl SpaceLibraryIdField {
	pub fn set<T: From<SpaceSetLibraryId>>(&self, value: i32) -> T {
		SpaceSetLibraryId(value).into()
	}
	pub fn equals(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> SpaceOrderByParam {
		SpaceOrderByParam::LibraryId(direction)
	}
	pub fn cursor(&self, cursor: i32) -> SpaceCursor {
		SpaceCursor::LibraryId(cursor)
	}
	pub fn increment(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetLibraryId(value)
	}
	pub fn decrement(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetLibraryId(value)
	}
	pub fn multiply(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetLibraryId(value)
	}
	pub fn divide(&self, value: i32) -> SpaceSetParam {
		SpaceSetParam::SetLibraryId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdLt(value)
	}
	pub fn lte(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdLte(value)
	}
	pub fn gt(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdGt(value)
	}
	pub fn gte(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdGte(value)
	}
	pub fn not(&self, value: i32) -> SpaceWhereParam {
		SpaceWhereParam::LibraryIdNot(value)
	}
}
pub struct SpaceSetLibraryId(i32);
impl From<SpaceSetLibraryId> for SpaceSetParam {
	fn from(value: SpaceSetLibraryId) -> Self {
		Self::SetLibraryId(value.0)
	}
}
pub enum SpaceWithParam {
	Library,
}
impl SpaceWithParam {
	pub fn to_output(self) -> Output {
		match self {
			Self::Library => Output {
				name: "Library".into(),
				outputs: library_outputs(),
				..Default::default()
			},
		}
	}
}
pub enum SpaceSetParam {
	SetId(i32),
	SetName(String),
	SetEncryption(i32),
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	SetDateModified(chrono::DateTime<chrono::Utc>),
	LinkLibrary(LibraryWhereUniqueParam),
	UnLinkLibrary,
	SetLibraryId(i32),
}
impl SpaceSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetName(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetEncryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkLibrary(where_param) => Field {
				name: "Library".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![
						Into::<LibraryWhereParam>::into(where_param).to_field(),
					])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkLibrary => Field {
				name: "Library".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					value: Some(true.into()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::SetLibraryId(value) => Field {
				name: "libraryId".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum SpaceOrderByParam {
	Id(Direction),
	Name(Direction),
	Encryption(Direction),
	DateCreated(Direction),
	DateModified(Direction),
	LibraryId(Direction),
}
impl SpaceOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Name(direction) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Encryption(direction) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateModified(direction) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::LibraryId(direction) => Field {
				name: "libraryId".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum SpaceCursor {
	Id(i32),
	Name(String),
	Encryption(i32),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
	LibraryId(i32),
}
impl SpaceCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Encryption(value) => Field {
				name: "encryption".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LibraryId(value) => Field {
				name: "libraryId".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum SpaceWhereParam {
	Not(Vec<SpaceWhereParam>),
	Or(Vec<SpaceWhereParam>),
	And(Vec<SpaceWhereParam>),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	NameEquals(String),
	NameInVec(Vec<String>),
	NameNotInVec(Vec<String>),
	NameLt(String),
	NameLte(String),
	NameGt(String),
	NameGte(String),
	NameContains(String),
	NameStartsWith(String),
	NameEndsWith(String),
	NameNot(String),
	EncryptionEquals(i32),
	EncryptionInVec(Vec<i32>),
	EncryptionNotInVec(Vec<i32>),
	EncryptionLt(i32),
	EncryptionLte(i32),
	EncryptionGt(i32),
	EncryptionGte(i32),
	EncryptionNot(i32),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedLt(chrono::DateTime<chrono::Utc>),
	DateModifiedLte(chrono::DateTime<chrono::Utc>),
	DateModifiedGt(chrono::DateTime<chrono::Utc>),
	DateModifiedGte(chrono::DateTime<chrono::Utc>),
	DateModifiedNot(chrono::DateTime<chrono::Utc>),
	LibraryIs(Vec<LibraryWhereParam>),
	LibraryIdEquals(i32),
	LibraryIdInVec(Vec<i32>),
	LibraryIdNotInVec(Vec<i32>),
	LibraryIdLt(i32),
	LibraryIdLte(i32),
	LibraryIdGt(i32),
	LibraryIdGte(i32),
	LibraryIdNot(i32),
}
impl SpaceWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNotInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameStartsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEndsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNot(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionEquals(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionInVec(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionNotInVec(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLt(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionLte(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGt(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionGte(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::EncryptionNot(value) => Field {
				name: "encryption".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNotInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNot(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIs(value) => Field {
				name: "Library".into(),
				fields: Some(vec![Field {
					name: "is".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdEquals(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdInVec(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdNotInVec(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdLt(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdLte(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdGt(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdGte(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::LibraryIdNot(value) => Field {
				name: "libraryId".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum SpaceWhereUniqueParam {
	IdEquals(i32),
}
impl From<SpaceWhereUniqueParam> for SpaceWhereParam {
	fn from(value: SpaceWhereUniqueParam) -> Self {
		match value {
			SpaceWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
		}
	}
}
impl From<Operator<Self>> for SpaceWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct SpaceFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<SpaceOrderByParam>,
	with_params: Vec<SpaceWithParam>,
}
impl<'a> SpaceFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<SpaceData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> SpaceDelete<'a> {
		SpaceDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Space".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<SpaceSetParam>) -> SpaceUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		SpaceUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: SpaceOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: SpaceWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: SpaceCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct SpaceFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<SpaceOrderByParam>,
	with_params: Vec<SpaceWithParam>,
}
impl<'a> SpaceFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<SpaceData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: SpaceWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: SpaceOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: SpaceCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct SpaceFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<SpaceWithParam>,
}
impl<'a> SpaceFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<SpaceData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> SpaceDelete<'a> {
		SpaceDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Space".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<SpaceSetParam>) -> SpaceUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		SpaceUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: SpaceWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct SpaceCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<SpaceWithParam>,
}
impl<'a> SpaceCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<SpaceData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: SpaceWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct SpaceUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<SpaceWithParam>,
}
impl<'a> SpaceUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<SpaceData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: SpaceWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct SpaceUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<SpaceWithParam>,
}
impl<'a> SpaceUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<SpaceData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: SpaceWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct SpaceUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> SpaceUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<SpaceData> {
		self.query.perform().await
	}
	pub fn create(mut self, name: SpaceSetName, params: Vec<SpaceSetParam>) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(SpaceSetParam::from(name).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<SpaceSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct SpaceDelete<'a> {
	query: Query<'a>,
}
impl<'a> SpaceDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct SpaceActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> SpaceActions<'a> {
	pub fn find_unique(&self, param: SpaceWhereUniqueParam) -> SpaceFindUnique {
		let param: SpaceWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Space".into(),
			outputs: space_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		SpaceFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<SpaceWhereParam>) -> SpaceFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Space".into(),
			outputs: space_outputs(),
			inputs,
		};
		SpaceFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<SpaceWhereParam>) -> SpaceFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Space".into(),
			outputs: space_outputs(),
			inputs,
		};
		SpaceFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		name: SpaceSetName,
		params: Vec<SpaceSetParam>,
	) -> SpaceCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(SpaceSetParam::from(name).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Space".into(),
			outputs: space_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		SpaceCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: SpaceWhereUniqueParam) -> SpaceUpsertOne {
		let param: SpaceWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "Space".into(),
			outputs: space_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		SpaceUpsertOne { query }
	}
}
fn album_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("name"),
		Output::new("is_hidden"),
		Output::new("date_created"),
		Output::new("date_modified"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlbumData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "is_hidden")]
	pub is_hidden: bool,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
}
impl AlbumData {}
pub struct Album;
impl Album {
	pub fn id() -> AlbumIdField {
		AlbumIdField {}
	}
	pub fn name() -> AlbumNameField {
		AlbumNameField {}
	}
	pub fn is_hidden() -> AlbumIsHiddenField {
		AlbumIsHiddenField {}
	}
	pub fn date_created() -> AlbumDateCreatedField {
		AlbumDateCreatedField {}
	}
	pub fn date_modified() -> AlbumDateModifiedField {
		AlbumDateModifiedField {}
	}
}
pub struct AlbumIdField {}
impl AlbumIdField {
	pub fn set<T: From<AlbumSetId>>(&self, value: i32) -> T {
		AlbumSetId(value).into()
	}
	pub fn equals<T: From<AlbumWhereUniqueParam>>(&self, value: i32) -> T {
		AlbumWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> AlbumOrderByParam {
		AlbumOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> AlbumCursor {
		AlbumCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> AlbumSetParam {
		AlbumSetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> AlbumSetParam {
		AlbumSetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> AlbumSetParam {
		AlbumSetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> AlbumSetParam {
		AlbumSetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> AlbumWhereParam {
		AlbumWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> AlbumWhereParam {
		AlbumWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> AlbumWhereParam {
		AlbumWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> AlbumWhereParam {
		AlbumWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> AlbumWhereParam {
		AlbumWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> AlbumWhereParam {
		AlbumWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> AlbumWhereParam {
		AlbumWhereParam::IdNot(value)
	}
}
pub struct AlbumSetId(i32);
impl From<AlbumSetId> for AlbumSetParam {
	fn from(value: AlbumSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct AlbumNameField {}
impl AlbumNameField {
	pub fn set<T: From<AlbumSetName>>(&self, value: String) -> T {
		AlbumSetName(value).into()
	}
	pub fn equals(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> AlbumOrderByParam {
		AlbumOrderByParam::Name(direction)
	}
	pub fn cursor(&self, cursor: String) -> AlbumCursor {
		AlbumCursor::Name(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> AlbumWhereParam {
		AlbumWhereParam::NameInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> AlbumWhereParam {
		AlbumWhereParam::NameNotInVec(value)
	}
	pub fn lt(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameLt(value)
	}
	pub fn lte(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameLte(value)
	}
	pub fn gt(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameGt(value)
	}
	pub fn gte(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameGte(value)
	}
	pub fn contains(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameContains(value)
	}
	pub fn starts_with(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameEndsWith(value)
	}
	pub fn not(&self, value: String) -> AlbumWhereParam {
		AlbumWhereParam::NameNot(value)
	}
}
pub struct AlbumSetName(String);
impl From<AlbumSetName> for AlbumSetParam {
	fn from(value: AlbumSetName) -> Self {
		Self::SetName(value.0)
	}
}
pub struct AlbumIsHiddenField {}
impl AlbumIsHiddenField {
	pub fn set<T: From<AlbumSetIsHidden>>(&self, value: bool) -> T {
		AlbumSetIsHidden(value).into()
	}
	pub fn equals(&self, value: bool) -> AlbumWhereParam {
		AlbumWhereParam::IsHiddenEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> AlbumOrderByParam {
		AlbumOrderByParam::IsHidden(direction)
	}
	pub fn cursor(&self, cursor: bool) -> AlbumCursor {
		AlbumCursor::IsHidden(cursor)
	}
}
pub struct AlbumSetIsHidden(bool);
impl From<AlbumSetIsHidden> for AlbumSetParam {
	fn from(value: AlbumSetIsHidden) -> Self {
		Self::SetIsHidden(value.0)
	}
}
pub struct AlbumDateCreatedField {}
impl AlbumDateCreatedField {
	pub fn set<T: From<AlbumSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		AlbumSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> AlbumOrderByParam {
		AlbumOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> AlbumCursor {
		AlbumCursor::DateCreated(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateCreatedNot(value)
	}
}
pub struct AlbumSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<AlbumSetDateCreated> for AlbumSetParam {
	fn from(value: AlbumSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct AlbumDateModifiedField {}
impl AlbumDateModifiedField {
	pub fn set<T: From<AlbumSetDateModified>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		AlbumSetDateModified(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> AlbumOrderByParam {
		AlbumOrderByParam::DateModified(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> AlbumCursor {
		AlbumCursor::DateModified(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> AlbumWhereParam {
		AlbumWhereParam::DateModifiedNot(value)
	}
}
pub struct AlbumSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<AlbumSetDateModified> for AlbumSetParam {
	fn from(value: AlbumSetDateModified) -> Self {
		Self::SetDateModified(value.0)
	}
}
pub enum AlbumWithParam {}
impl AlbumWithParam {
	pub fn to_output(self) -> Output {
		match self {}
	}
}
pub enum AlbumSetParam {
	SetId(i32),
	SetName(String),
	SetIsHidden(bool),
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	SetDateModified(chrono::DateTime<chrono::Utc>),
}
impl AlbumSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetName(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetIsHidden(value) => Field {
				name: "is_hidden".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum AlbumOrderByParam {
	Id(Direction),
	Name(Direction),
	IsHidden(Direction),
	DateCreated(Direction),
	DateModified(Direction),
}
impl AlbumOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Name(direction) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::IsHidden(direction) => Field {
				name: "is_hidden".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateModified(direction) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum AlbumCursor {
	Id(i32),
	Name(String),
	IsHidden(bool),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
}
impl AlbumCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Name(value) => Field {
				name: "name".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::IsHidden(value) => Field {
				name: "is_hidden".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum AlbumWhereParam {
	Not(Vec<AlbumWhereParam>),
	Or(Vec<AlbumWhereParam>),
	And(Vec<AlbumWhereParam>),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	NameEquals(String),
	NameInVec(Vec<String>),
	NameNotInVec(Vec<String>),
	NameLt(String),
	NameLte(String),
	NameGt(String),
	NameGte(String),
	NameContains(String),
	NameStartsWith(String),
	NameEndsWith(String),
	NameNot(String),
	IsHiddenEquals(bool),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedLt(chrono::DateTime<chrono::Utc>),
	DateModifiedLte(chrono::DateTime<chrono::Utc>),
	DateModifiedGt(chrono::DateTime<chrono::Utc>),
	DateModifiedGte(chrono::DateTime<chrono::Utc>),
	DateModifiedNot(chrono::DateTime<chrono::Utc>),
}
impl AlbumWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEquals(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNotInVec(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameLte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGt(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameGte(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameContains(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameStartsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameEndsWith(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::NameNot(value) => Field {
				name: "name".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IsHiddenEquals(value) => Field {
				name: "is_hidden".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNotInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNot(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum AlbumWhereUniqueParam {
	IdEquals(i32),
}
impl From<AlbumWhereUniqueParam> for AlbumWhereParam {
	fn from(value: AlbumWhereUniqueParam) -> Self {
		match value {
			AlbumWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
		}
	}
}
impl From<Operator<Self>> for AlbumWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct AlbumFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<AlbumOrderByParam>,
	with_params: Vec<AlbumWithParam>,
}
impl<'a> AlbumFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<AlbumData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> AlbumDelete<'a> {
		AlbumDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Album".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<AlbumSetParam>) -> AlbumUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		AlbumUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: AlbumOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: AlbumWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: AlbumCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct AlbumFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<AlbumOrderByParam>,
	with_params: Vec<AlbumWithParam>,
}
impl<'a> AlbumFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<AlbumData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: AlbumWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: AlbumOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: AlbumCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct AlbumFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<AlbumWithParam>,
}
impl<'a> AlbumFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<AlbumData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> AlbumDelete<'a> {
		AlbumDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Album".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<AlbumSetParam>) -> AlbumUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		AlbumUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: AlbumWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct AlbumCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<AlbumWithParam>,
}
impl<'a> AlbumCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<AlbumData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: AlbumWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct AlbumUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<AlbumWithParam>,
}
impl<'a> AlbumUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<AlbumData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: AlbumWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct AlbumUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<AlbumWithParam>,
}
impl<'a> AlbumUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<AlbumData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: AlbumWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct AlbumUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> AlbumUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<AlbumData> {
		self.query.perform().await
	}
	pub fn create(mut self, name: AlbumSetName, params: Vec<AlbumSetParam>) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(AlbumSetParam::from(name).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<AlbumSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct AlbumDelete<'a> {
	query: Query<'a>,
}
impl<'a> AlbumDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct AlbumActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> AlbumActions<'a> {
	pub fn find_unique(&self, param: AlbumWhereUniqueParam) -> AlbumFindUnique {
		let param: AlbumWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Album".into(),
			outputs: album_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		AlbumFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<AlbumWhereParam>) -> AlbumFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Album".into(),
			outputs: album_outputs(),
			inputs,
		};
		AlbumFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<AlbumWhereParam>) -> AlbumFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Album".into(),
			outputs: album_outputs(),
			inputs,
		};
		AlbumFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		name: AlbumSetName,
		params: Vec<AlbumSetParam>,
	) -> AlbumCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(AlbumSetParam::from(name).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Album".into(),
			outputs: album_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		AlbumCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: AlbumWhereUniqueParam) -> AlbumUpsertOne {
		let param: AlbumWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "Album".into(),
			outputs: album_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		AlbumUpsertOne { query }
	}
}
fn comment_outputs() -> Vec<Output> {
	vec![
		Output::new("id"),
		Output::new("content"),
		Output::new("date_created"),
		Output::new("date_modified"),
		Output::new("file_id"),
	]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommentData {
	#[serde(rename = "id")]
	pub id: i32,
	#[serde(rename = "content")]
	pub content: String,
	#[serde(rename = "date_created")]
	pub date_created: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "date_modified")]
	pub date_modified: chrono::DateTime<chrono::Utc>,
	#[serde(rename = "file_id")]
	pub file_id: Option<i32>,
	#[serde(rename = "file")]
	file: Option<Box<FileData>>,
}
impl CommentData {
	pub fn file(&self) -> Result<&FileData, String> {
		match self.file.as_ref() {
			Some(v) => Ok(v),
			None => Err(
				"Attempted to access file but did not fetch it using the .with() syntax"
					.to_string(),
			),
		}
	}
}
pub struct Comment;
impl Comment {
	pub fn id() -> CommentIdField {
		CommentIdField {}
	}
	pub fn content() -> CommentContentField {
		CommentContentField {}
	}
	pub fn date_created() -> CommentDateCreatedField {
		CommentDateCreatedField {}
	}
	pub fn date_modified() -> CommentDateModifiedField {
		CommentDateModifiedField {}
	}
	pub fn file_id() -> CommentFileIdField {
		CommentFileIdField {}
	}
	pub fn file() -> CommentFileField {
		CommentFileField {}
	}
}
pub struct CommentIdField {}
impl CommentIdField {
	pub fn set<T: From<CommentSetId>>(&self, value: i32) -> T {
		CommentSetId(value).into()
	}
	pub fn equals<T: From<CommentWhereUniqueParam>>(&self, value: i32) -> T {
		CommentWhereUniqueParam::IdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> CommentOrderByParam {
		CommentOrderByParam::Id(direction)
	}
	pub fn cursor(&self, cursor: i32) -> CommentCursor {
		CommentCursor::Id(cursor)
	}
	pub fn increment(&self, value: i32) -> CommentSetParam {
		CommentSetParam::SetId(value)
	}
	pub fn decrement(&self, value: i32) -> CommentSetParam {
		CommentSetParam::SetId(value)
	}
	pub fn multiply(&self, value: i32) -> CommentSetParam {
		CommentSetParam::SetId(value)
	}
	pub fn divide(&self, value: i32) -> CommentSetParam {
		CommentSetParam::SetId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> CommentWhereParam {
		CommentWhereParam::IdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> CommentWhereParam {
		CommentWhereParam::IdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> CommentWhereParam {
		CommentWhereParam::IdLt(value)
	}
	pub fn lte(&self, value: i32) -> CommentWhereParam {
		CommentWhereParam::IdLte(value)
	}
	pub fn gt(&self, value: i32) -> CommentWhereParam {
		CommentWhereParam::IdGt(value)
	}
	pub fn gte(&self, value: i32) -> CommentWhereParam {
		CommentWhereParam::IdGte(value)
	}
	pub fn not(&self, value: i32) -> CommentWhereParam {
		CommentWhereParam::IdNot(value)
	}
}
pub struct CommentSetId(i32);
impl From<CommentSetId> for CommentSetParam {
	fn from(value: CommentSetId) -> Self {
		Self::SetId(value.0)
	}
}
pub struct CommentContentField {}
impl CommentContentField {
	pub fn set<T: From<CommentSetContent>>(&self, value: String) -> T {
		CommentSetContent(value).into()
	}
	pub fn equals(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> CommentOrderByParam {
		CommentOrderByParam::Content(direction)
	}
	pub fn cursor(&self, cursor: String) -> CommentCursor {
		CommentCursor::Content(cursor)
	}
	pub fn in_vec(&self, value: Vec<String>) -> CommentWhereParam {
		CommentWhereParam::ContentInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<String>) -> CommentWhereParam {
		CommentWhereParam::ContentNotInVec(value)
	}
	pub fn lt(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentLt(value)
	}
	pub fn lte(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentLte(value)
	}
	pub fn gt(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentGt(value)
	}
	pub fn gte(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentGte(value)
	}
	pub fn contains(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentContains(value)
	}
	pub fn starts_with(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentStartsWith(value)
	}
	pub fn ends_with(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentEndsWith(value)
	}
	pub fn not(&self, value: String) -> CommentWhereParam {
		CommentWhereParam::ContentNot(value)
	}
}
pub struct CommentSetContent(String);
impl From<CommentSetContent> for CommentSetParam {
	fn from(value: CommentSetContent) -> Self {
		Self::SetContent(value.0)
	}
}
pub struct CommentDateCreatedField {}
impl CommentDateCreatedField {
	pub fn set<T: From<CommentSetDateCreated>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		CommentSetDateCreated(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> CommentOrderByParam {
		CommentOrderByParam::DateCreated(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> CommentCursor {
		CommentCursor::DateCreated(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> CommentWhereParam {
		CommentWhereParam::DateCreatedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateCreatedNot(value)
	}
}
pub struct CommentSetDateCreated(chrono::DateTime<chrono::Utc>);
impl From<CommentSetDateCreated> for CommentSetParam {
	fn from(value: CommentSetDateCreated) -> Self {
		Self::SetDateCreated(value.0)
	}
}
pub struct CommentDateModifiedField {}
impl CommentDateModifiedField {
	pub fn set<T: From<CommentSetDateModified>>(
		&self,
		value: chrono::DateTime<chrono::Utc>,
	) -> T {
		CommentSetDateModified(value).into()
	}
	pub fn equals(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> CommentOrderByParam {
		CommentOrderByParam::DateModified(direction)
	}
	pub fn cursor(&self, cursor: chrono::DateTime<chrono::Utc>) -> CommentCursor {
		CommentCursor::DateModified(cursor)
	}
	pub fn in_vec(&self, value: Vec<chrono::DateTime<chrono::Utc>>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedInVec(value)
	}
	pub fn not_in_vec(
		&self,
		value: Vec<chrono::DateTime<chrono::Utc>>,
	) -> CommentWhereParam {
		CommentWhereParam::DateModifiedNotInVec(value)
	}
	pub fn lt(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedLt(value)
	}
	pub fn lte(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedLte(value)
	}
	pub fn gt(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedGt(value)
	}
	pub fn gte(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedGte(value)
	}
	pub fn not(&self, value: chrono::DateTime<chrono::Utc>) -> CommentWhereParam {
		CommentWhereParam::DateModifiedNot(value)
	}
}
pub struct CommentSetDateModified(chrono::DateTime<chrono::Utc>);
impl From<CommentSetDateModified> for CommentSetParam {
	fn from(value: CommentSetDateModified) -> Self {
		Self::SetDateModified(value.0)
	}
}
pub struct CommentFileIdField {}
impl CommentFileIdField {
	pub fn set<T: From<CommentSetFileId>>(&self, value: i32) -> T {
		CommentSetFileId(value).into()
	}
	pub fn equals(&self, value: i32) -> CommentWhereParam {
		CommentWhereParam::FileIdEquals(value).into()
	}
	pub fn order(&self, direction: Direction) -> CommentOrderByParam {
		CommentOrderByParam::FileId(direction)
	}
	pub fn cursor(&self, cursor: i32) -> CommentCursor {
		CommentCursor::FileId(cursor)
	}
	pub fn increment(&self, value: i32) -> CommentSetParam {
		CommentSetParam::SetFileId(value)
	}
	pub fn decrement(&self, value: i32) -> CommentSetParam {
		CommentSetParam::SetFileId(value)
	}
	pub fn multiply(&self, value: i32) -> CommentSetParam {
		CommentSetParam::SetFileId(value)
	}
	pub fn divide(&self, value: i32) -> CommentSetParam {
		CommentSetParam::SetFileId(value)
	}
	pub fn in_vec(&self, value: Vec<i32>) -> CommentWhereParam {
		CommentWhereParam::FileIdInVec(value)
	}
	pub fn not_in_vec(&self, value: Vec<i32>) -> CommentWhereParam {
		CommentWhereParam::FileIdNotInVec(value)
	}
	pub fn lt(&self, value: i32) -> CommentWhereParam {
		CommentWhereParam::FileIdLt(value)
	}
	pub fn lte(&self, value: i32) -> CommentWhereParam {
		CommentWhereParam::FileIdLte(value)
	}
	pub fn gt(&self, value: i32) -> CommentWhereParam {
		CommentWhereParam::FileIdGt(value)
	}
	pub fn gte(&self, value: i32) -> CommentWhereParam {
		CommentWhereParam::FileIdGte(value)
	}
	pub fn not(&self, value: i32) -> CommentWhereParam {
		CommentWhereParam::FileIdNot(value)
	}
}
pub struct CommentSetFileId(i32);
impl From<CommentSetFileId> for CommentSetParam {
	fn from(value: CommentSetFileId) -> Self {
		Self::SetFileId(value.0)
	}
}
pub struct CommentFileField {}
impl CommentFileField {
	pub fn is(&self, value: Vec<FileWhereParam>) -> CommentWhereParam {
		CommentWhereParam::FileIs(value)
	}
	pub fn fetch(&self) -> CommentWithParam {
		CommentWithParam::File
	}
	pub fn link<T: From<CommentLinkFile>>(&self, value: FileWhereUniqueParam) -> T {
		CommentLinkFile(value).into()
	}
	pub fn unlink(&self) -> CommentSetParam {
		CommentSetParam::UnLinkFile
	}
}
pub struct CommentLinkFile(FileWhereUniqueParam);
impl From<CommentLinkFile> for CommentSetParam {
	fn from(value: CommentLinkFile) -> Self {
		Self::LinkFile(value.0)
	}
}
pub enum CommentWithParam {
	File,
}
impl CommentWithParam {
	pub fn to_output(self) -> Output {
		match self {
			Self::File => Output {
				name: "file".into(),
				outputs: file_outputs(),
				..Default::default()
			},
		}
	}
}
pub enum CommentSetParam {
	SetId(i32),
	SetContent(String),
	SetDateCreated(chrono::DateTime<chrono::Utc>),
	SetDateModified(chrono::DateTime<chrono::Utc>),
	SetFileId(i32),
	LinkFile(FileWhereUniqueParam),
	UnLinkFile,
}
impl CommentSetParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::SetId(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetContent(value) => Field {
				name: "content".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetDateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::SetFileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::LinkFile(where_param) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "connect".into(),
					fields: Some(transform_equals(vec![Into::<FileWhereParam>::into(
						where_param,
					)
					.to_field()])),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::UnLinkFile => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "disconnect".into(),
					value: Some(true.into()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum CommentOrderByParam {
	Id(Direction),
	Content(Direction),
	DateCreated(Direction),
	DateModified(Direction),
	FileId(Direction),
}
impl CommentOrderByParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Id(direction) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::Content(direction) => Field {
				name: "content".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateCreated(direction) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::DateModified(direction) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
			Self::FileId(direction) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(direction).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum CommentCursor {
	Id(i32),
	Content(String),
	DateCreated(chrono::DateTime<chrono::Utc>),
	DateModified(chrono::DateTime<chrono::Utc>),
	FileId(i32),
}
impl CommentCursor {
	fn to_field(self) -> Field {
		match self {
			Self::Id(value) => Field {
				name: "id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::Content(value) => Field {
				name: "content".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateCreated(value) => Field {
				name: "date_created".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::DateModified(value) => Field {
				name: "date_modified".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
			Self::FileId(value) => Field {
				name: "file_id".into(),
				value: Some(serde_json::to_value(value).unwrap()),
				..Default::default()
			},
		}
	}
}
pub enum CommentWhereParam {
	Not(Vec<CommentWhereParam>),
	Or(Vec<CommentWhereParam>),
	And(Vec<CommentWhereParam>),
	IdEquals(i32),
	IdInVec(Vec<i32>),
	IdNotInVec(Vec<i32>),
	IdLt(i32),
	IdLte(i32),
	IdGt(i32),
	IdGte(i32),
	IdNot(i32),
	ContentEquals(String),
	ContentInVec(Vec<String>),
	ContentNotInVec(Vec<String>),
	ContentLt(String),
	ContentLte(String),
	ContentGt(String),
	ContentGte(String),
	ContentContains(String),
	ContentStartsWith(String),
	ContentEndsWith(String),
	ContentNot(String),
	DateCreatedEquals(chrono::DateTime<chrono::Utc>),
	DateCreatedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateCreatedLt(chrono::DateTime<chrono::Utc>),
	DateCreatedLte(chrono::DateTime<chrono::Utc>),
	DateCreatedGt(chrono::DateTime<chrono::Utc>),
	DateCreatedGte(chrono::DateTime<chrono::Utc>),
	DateCreatedNot(chrono::DateTime<chrono::Utc>),
	DateModifiedEquals(chrono::DateTime<chrono::Utc>),
	DateModifiedInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedNotInVec(Vec<chrono::DateTime<chrono::Utc>>),
	DateModifiedLt(chrono::DateTime<chrono::Utc>),
	DateModifiedLte(chrono::DateTime<chrono::Utc>),
	DateModifiedGt(chrono::DateTime<chrono::Utc>),
	DateModifiedGte(chrono::DateTime<chrono::Utc>),
	DateModifiedNot(chrono::DateTime<chrono::Utc>),
	FileIdEquals(i32),
	FileIdInVec(Vec<i32>),
	FileIdNotInVec(Vec<i32>),
	FileIdLt(i32),
	FileIdLte(i32),
	FileIdGt(i32),
	FileIdGte(i32),
	FileIdNot(i32),
	FileIs(Vec<FileWhereParam>),
}
impl CommentWhereParam {
	pub fn to_field(self) -> Field {
		match self {
			Self::Not(value) => Field {
				name: "Not".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::Or(value) => Field {
				name: "Or".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::And(value) => Field {
				name: "And".into(),
				list: true,
				wrap_list: true,
				fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
				..Default::default()
			},
			Self::IdEquals(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNotInVec(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdLte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGt(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdGte(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::IdNot(value) => Field {
				name: "id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentEquals(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentInVec(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentNotInVec(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentLt(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentLte(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentGt(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentGte(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentContains(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "contains".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentStartsWith(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "startsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentEndsWith(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "endsWith".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::ContentNot(value) => Field {
				name: "content".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedEquals(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNotInVec(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedLte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGt(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedGte(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateCreatedNot(value) => Field {
				name: "date_created".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedEquals(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNotInVec(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedLte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGt(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedGte(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::DateModifiedNot(value) => Field {
				name: "date_modified".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdEquals(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "equals".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdInVec(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "in".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdNotInVec(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "notIn".into(),
					list: true,
					fields: Some(
						value
							.iter()
							.map(|v| Field {
								value: Some(serde_json::to_value(v).unwrap()),
								..Default::default()
							})
							.collect(),
					),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLt(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdLte(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "lte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGt(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gt".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdGte(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "gte".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIdNot(value) => Field {
				name: "file_id".into(),
				fields: Some(vec![Field {
					name: "not".into(),
					value: Some(serde_json::to_value(value).unwrap()),
					..Default::default()
				}]),
				..Default::default()
			},
			Self::FileIs(value) => Field {
				name: "file".into(),
				fields: Some(vec![Field {
					name: "is".into(),
					fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
					..Default::default()
				}]),
				..Default::default()
			},
		}
	}
}
pub enum CommentWhereUniqueParam {
	IdEquals(i32),
}
impl From<CommentWhereUniqueParam> for CommentWhereParam {
	fn from(value: CommentWhereUniqueParam) -> Self {
		match value {
			CommentWhereUniqueParam::IdEquals(value) => Self::IdEquals(value),
		}
	}
}
impl From<Operator<Self>> for CommentWhereParam {
	fn from(op: Operator<Self>) -> Self {
		match op {
			Operator::Not(value) => Self::Not(value),
			Operator::And(value) => Self::And(value),
			Operator::Or(value) => Self::Or(value),
		}
	}
}
pub struct CommentFindMany<'a> {
	query: Query<'a>,
	order_by_params: Vec<CommentOrderByParam>,
	with_params: Vec<CommentWithParam>,
}
impl<'a> CommentFindMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<CommentData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> CommentDelete<'a> {
		CommentDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteMany".into(),
				model: "Comment".into(),
				outputs: vec![Output::new("count")],
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<CommentSetParam>) -> CommentUpdateMany<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		CommentUpdateMany {
			query: Query {
				operation: "mutation".into(),
				method: "updateMany".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn order_by(mut self, param: CommentOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn with(mut self, param: CommentWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: CommentCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct CommentFindFirst<'a> {
	query: Query<'a>,
	order_by_params: Vec<CommentOrderByParam>,
	with_params: Vec<CommentWithParam>,
}
impl<'a> CommentFindFirst<'a> {
	pub async fn exec(self) -> QueryResult<Option<CommentData>> {
		let Self {
			mut query,
			order_by_params,
			with_params,
		} = self;
		if order_by_params.len() > 0 {
			query.inputs.push(Input {
				name: "orderBy".into(),
				fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
				..Default::default()
			});
		}
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: CommentWithParam) -> Self {
		self.with_params.push(param);
		self
	}
	pub fn order_by(mut self, param: CommentOrderByParam) -> Self {
		self.order_by_params.push(param);
		self
	}
	pub fn skip(mut self, skip: usize) -> Self {
		self.query.inputs.push(Input {
			name: "skip".into(),
			value: Some(serde_json::to_value(skip).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn take(mut self, take: usize) -> Self {
		self.query.inputs.push(Input {
			name: "take".into(),
			value: Some(serde_json::to_value(take).unwrap()),
			..Default::default()
		});
		self
	}
	pub fn cursor(mut self, cursor: CommentCursor) -> Self {
		self.query.inputs.push(Input {
			name: "cursor".into(),
			fields: vec![cursor.to_field()],
			..Default::default()
		});
		self
	}
}
pub struct CommentFindUnique<'a> {
	query: Query<'a>,
	with_params: Vec<CommentWithParam>,
}
impl<'a> CommentFindUnique<'a> {
	pub async fn exec(self) -> QueryResult<Option<CommentData>> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn delete(self) -> CommentDelete<'a> {
		CommentDelete {
			query: Query {
				operation: "mutation".into(),
				method: "deleteOne".into(),
				model: "Comment".into(),
				..self.query
			},
		}
	}
	pub fn update(mut self, params: Vec<CommentSetParam>) -> CommentUpdateUnique<'a> {
		self.query.inputs.push(Input {
			name: "data".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		CommentUpdateUnique {
			query: Query {
				operation: "mutation".into(),
				method: "updateOne".into(),
				..self.query
			},
			with_params: vec![],
		}
	}
	pub fn with(mut self, param: CommentWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct CommentCreateOne<'a> {
	query: Query<'a>,
	with_params: Vec<CommentWithParam>,
}
impl<'a> CommentCreateOne<'a> {
	pub async fn exec(self) -> QueryResult<CommentData> {
		let Self {
			mut query,
			with_params,
		} = self;
		query.outputs.extend(
			with_params
				.into_iter()
				.map(|f| f.to_output())
				.collect::<Vec<_>>(),
		);
		query.perform().await
	}
	pub fn with(mut self, param: CommentWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct CommentUpdateUnique<'a> {
	query: Query<'a>,
	with_params: Vec<CommentWithParam>,
}
impl<'a> CommentUpdateUnique<'a> {
	pub async fn exec(self) -> QueryResult<CommentData> {
		self.query.perform().await
	}
	pub fn with(mut self, param: CommentWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct CommentUpdateMany<'a> {
	query: Query<'a>,
	with_params: Vec<CommentWithParam>,
}
impl<'a> CommentUpdateMany<'a> {
	pub async fn exec(self) -> QueryResult<Vec<CommentData>> {
		self.query.perform().await
	}
	pub fn with(mut self, param: CommentWithParam) -> Self {
		self.with_params.push(param);
		self
	}
}
pub struct CommentUpsertOne<'a> {
	query: Query<'a>,
}
impl<'a> CommentUpsertOne<'a> {
	pub async fn exec(self) -> QueryResult<CommentData> {
		self.query.perform().await
	}
	pub fn create(
		mut self,
		content: CommentSetContent,
		params: Vec<CommentSetParam>,
	) -> Self {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(CommentSetParam::from(content).to_field());
		self.query.inputs.push(Input {
			name: "create".into(),
			fields: input_fields,
			..Default::default()
		});
		self
	}
	pub fn update(mut self, params: Vec<CommentSetParam>) -> Self {
		self.query.inputs.push(Input {
			name: "update".into(),
			fields: params
				.into_iter()
				.map(|param| {
					let mut field = param.to_field();
					if let Some(value) = field.value {
						field.fields = Some(vec![Field {
							name: "set".into(),
							value: Some(value),
							..Default::default()
						}]);
						field.value = None;
					}
					field
				})
				.collect(),
			..Default::default()
		});
		self
	}
}
pub struct CommentDelete<'a> {
	query: Query<'a>,
}
impl<'a> CommentDelete<'a> {
	pub async fn exec(self) -> QueryResult<isize> {
		self.query.perform::<DeleteResult>().await.map(|r| r.count)
	}
}
pub struct CommentActions<'a> {
	client: &'a PrismaClient,
}
impl<'a> CommentActions<'a> {
	pub fn find_unique(&self, param: CommentWhereUniqueParam) -> CommentFindUnique {
		let param: CommentWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findUnique".into(),
			model: "Comment".into(),
			outputs: comment_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		CommentFindUnique {
			query,
			with_params: vec![],
		}
	}
	pub fn find_first(&self, params: Vec<CommentWhereParam>) -> CommentFindFirst {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: vec![Field {
					name: "AND".into(),
					list: true,
					wrap_list: true,
					fields: Some(where_fields),
					..Default::default()
				}],
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findFirst".into(),
			model: "Comment".into(),
			outputs: comment_outputs(),
			inputs,
		};
		CommentFindFirst {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn find_many(&self, params: Vec<CommentWhereParam>) -> CommentFindMany {
		let where_fields: Vec<Field> =
			params.into_iter().map(|param| param.to_field()).collect();
		let inputs = if where_fields.len() > 0 {
			vec![Input {
				name: "where".into(),
				fields: where_fields,
				..Default::default()
			}]
		} else {
			Vec::new()
		};
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "query".into(),
			method: "findMany".into(),
			model: "Comment".into(),
			outputs: comment_outputs(),
			inputs,
		};
		CommentFindMany {
			query,
			order_by_params: vec![],
			with_params: vec![],
		}
	}
	pub fn create_one(
		&self,
		content: CommentSetContent,
		params: Vec<CommentSetParam>,
	) -> CommentCreateOne {
		let mut input_fields =
			params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
		input_fields.push(CommentSetParam::from(content).to_field());
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "createOne".into(),
			model: "Comment".into(),
			outputs: comment_outputs(),
			inputs: vec![Input {
				name: "data".into(),
				fields: input_fields,
				..Default::default()
			}],
		};
		CommentCreateOne {
			query,
			with_params: vec![],
		}
	}
	pub fn upsert_one(&self, param: CommentWhereUniqueParam) -> CommentUpsertOne {
		let param: CommentWhereParam = param.into();
		let fields = transform_equals(vec![param.to_field()]);
		let query = Query {
			ctx: QueryContext::new(
				&self.client.executor,
				self.client.query_schema.clone(),
			),
			name: String::new(),
			operation: "mutation".into(),
			method: "upsertOne".into(),
			model: "Comment".into(),
			outputs: comment_outputs(),
			inputs: vec![Input {
				name: "where".into(),
				fields,
				..Default::default()
			}],
		};
		CommentUpsertOne { query }
	}
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum MigrationScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "checksum")]
	Checksum,
	#[serde(rename = "steps_applied")]
	StepsApplied,
	#[serde(rename = "applied_at")]
	AppliedAt,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum LibraryScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "uuid")]
	Uuid,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "remote_id")]
	RemoteId,
	#[serde(rename = "is_primary")]
	IsPrimary,
	#[serde(rename = "encryption")]
	Encryption,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "timezone")]
	Timezone,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum LibraryStatisticsScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "date_captured")]
	DateCaptured,
	#[serde(rename = "library_id")]
	LibraryId,
	#[serde(rename = "total_file_count")]
	TotalFileCount,
	#[serde(rename = "total_bytes_used")]
	TotalBytesUsed,
	#[serde(rename = "total_byte_capacity")]
	TotalByteCapacity,
	#[serde(rename = "total_unique_bytes")]
	TotalUniqueBytes,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ClientScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "uuid")]
	Uuid,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "platform")]
	Platform,
	#[serde(rename = "version")]
	Version,
	#[serde(rename = "online")]
	Online,
	#[serde(rename = "last_seen")]
	LastSeen,
	#[serde(rename = "timezone")]
	Timezone,
	#[serde(rename = "date_created")]
	DateCreated,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum LocationScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "local_path")]
	LocalPath,
	#[serde(rename = "total_capacity")]
	TotalCapacity,
	#[serde(rename = "available_capacity")]
	AvailableCapacity,
	#[serde(rename = "filesystem")]
	Filesystem,
	#[serde(rename = "disk_type")]
	DiskType,
	#[serde(rename = "is_removable")]
	IsRemovable,
	#[serde(rename = "is_ejectable")]
	IsEjectable,
	#[serde(rename = "is_root_filesystem")]
	IsRootFilesystem,
	#[serde(rename = "is_online")]
	IsOnline,
	#[serde(rename = "date_created")]
	DateCreated,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum FileScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "kind")]
	Kind,
	#[serde(rename = "size_in_bytes")]
	SizeInBytes,
	#[serde(rename = "partial_checksum")]
	PartialChecksum,
	#[serde(rename = "checksum")]
	Checksum,
	#[serde(rename = "encryption")]
	Encryption,
	#[serde(rename = "ipfs_id")]
	IpfsId,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
	#[serde(rename = "date_indexed")]
	DateIndexed,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum FilePathScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "is_dir")]
	IsDir,
	#[serde(rename = "location_id")]
	LocationId,
	#[serde(rename = "materialized_path")]
	MaterializedPath,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "extension")]
	Extension,
	#[serde(rename = "file_id")]
	FileId,
	#[serde(rename = "parent_id")]
	ParentId,
	#[serde(rename = "encryption")]
	Encryption,
	#[serde(rename = "permissions")]
	Permissions,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
	#[serde(rename = "date_indexed")]
	DateIndexed,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum TagScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "encryption")]
	Encryption,
	#[serde(rename = "total_files")]
	TotalFiles,
	#[serde(rename = "redundancy_goal")]
	RedundancyGoal,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum TagOnFileScalarFieldEnum {
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "tag_id")]
	TagId,
	#[serde(rename = "file_id")]
	FileId,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum LabelScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum LabelOnFileScalarFieldEnum {
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "label_id")]
	LabelId,
	#[serde(rename = "file_id")]
	FileId,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum JobScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "action")]
	Action,
	#[serde(rename = "status")]
	Status,
	#[serde(rename = "task_count")]
	TaskCount,
	#[serde(rename = "completed_task_count")]
	CompletedTaskCount,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
	#[serde(rename = "seconds_elapsed")]
	SecondsElapsed,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SpaceScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "encryption")]
	Encryption,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
	#[serde(rename = "libraryId")]
	LibraryId,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum AlbumScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "is_hidden")]
	IsHidden,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum CommentScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "content")]
	Content,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
	#[serde(rename = "file_id")]
	FileId,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SortOrder {
	#[serde(rename = "asc")]
	Asc,
	#[serde(rename = "desc")]
	Desc,
}
